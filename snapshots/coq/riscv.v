(*Generated by Sail from riscv.*)
Require Import Sail2_instr_kinds.
Require Import Sail2_values.
Require Import Sail2_string.
Require Import Sail2_real.
Require Import Sail2_operators_mwords.
Require Import Sail2_prompt_monad.
Require Import Sail2_prompt.
Require Import Sail2_state.
Require Import riscv_types.
Require Import riscv_extras.
Import ListNotations.
Open Scope string.
Open Scope bool.
Section Content.

Definition cap_size := 32.
Hint Unfold cap_size : sail.
Axiom quotient : forall  (ex33401_ : Z) (ex33402_ : Z) , Z.

Axiom quotient_nat : forall

(ex33403_ : Z) (ex33404_ : Z)
`{ArithFact (0 <= ex33403_)} `{ArithFact (0 <= ex33404_)},
{n : Z & ArithFact (n >= 0)}.

Axiom quotient_real : forall  (_ : R) (_ : R) , R.

Definition eq_unit (g__112 : unit) (g__113 : unit) 
: {_bool : bool & ArithFact (_bool = true)} :=
   
   build_ex(true).

Definition neq_int (x : Z) (y : Z) 
: {_bool : bool & ArithFact (iff (_bool = true) (x <> y))} :=
   
   build_ex(negb (Z.eqb x y)).

Definition neq_bool (x : bool) (y : bool)  : bool :=  negb (Bool.eqb x y).

Axiom eq_real : forall  (_ : R) (_ : R) , bool.

Axiom lteq_real : forall  (_ : R) (_ : R) , bool.

Axiom lt_real : forall  (_ : R) (_ : R) , bool.

Axiom gteq_real : forall  (_ : R) (_ : R) , bool.

Axiom gt_real : forall  (_ : R) (_ : R) , bool.

Definition __id (x : Z)  : {_retval : Z & ArithFact (_retval = x)} :=  build_ex(x).

Axiom add_real : forall  (_ : R) (_ : R) , R.

Axiom sub_real : forall  (_ : R) (_ : R) , R.

Axiom negate_real : forall  (_ : R) , R.

Axiom mult_real : forall  (_ : R) (_ : R) , R.



Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) `{ArithFact (len >= 0 /\ v0 >= 0)} 
: mword len :=
   
   if sumbool_of_bool ((Z.leb len (length_mword v))) then vector_truncate v len
   else zero_extend v len.

Axiom real_power : forall  (_ : R) (ex33407_ : Z) , R.

Axiom vector_concat : forall {n : Z} {m : Z} {a : Type} (_ : vec a n) (_ : vec a m) , vec a (n + m).

Definition sail_ones (n : Z) `{ArithFact (n >= 0)}  : mword n :=  not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) `{ArithFact (n >= 0)} 
: mword n :=
   
   if sumbool_of_bool ((Z.geb l n)) then sail_ones n
   else
     let one : bits n := sail_mask n ((vec_of_bits [B1]  : mword 1)  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition is_none {a : Type} (opt : option a) 
: bool :=
   
   match opt with | Some (_) => false | None => true end.

Definition is_some {a : Type} (opt : option a) 
: bool :=
   
   match opt with | Some (_) => true | None => false end.

Definition hex_bits_1_forwards_matches (bv : mword 1)  : bool :=  true.

Definition hex_bits_1_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_1_matches_prefix s) with
           | Some (g__109,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__110 := Some ((g__109, n)) in
                false
           | g__110 => false
           end)) then
        true
      else
        let g__111 := s in
        false
   end.

Definition hex_bits_1_backwards (s : string) 
: M (mword 1) :=
   
   (match (hex_bits_1_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 1)
    | _ => exit tt  : M (mword 1)
    end)
    : M (mword 1).

Definition hex_bits_2_forwards_matches (bv : mword 2)  : bool :=  true.

Definition hex_bits_2_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_2_matches_prefix s) with
           | Some (g__106,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__107 := Some ((g__106, n)) in
                false
           | g__107 => false
           end)) then
        true
      else
        let g__108 := s in
        false
   end.

Definition hex_bits_2_backwards (s : string) 
: M (mword 2) :=
   
   (match (hex_bits_2_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 2)
    | _ => exit tt  : M (mword 2)
    end)
    : M (mword 2).

Definition hex_bits_3_forwards_matches (bv : mword 3)  : bool :=  true.

Definition hex_bits_3_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_3_matches_prefix s) with
           | Some (g__103,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__104 := Some ((g__103, n)) in
                false
           | g__104 => false
           end)) then
        true
      else
        let g__105 := s in
        false
   end.

Definition hex_bits_3_backwards (s : string) 
: M (mword 3) :=
   
   (match (hex_bits_3_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 3)
    | _ => exit tt  : M (mword 3)
    end)
    : M (mword 3).

Definition hex_bits_4_forwards_matches (bv : mword 4)  : bool :=  true.

Definition hex_bits_4_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_4_matches_prefix s) with
           | Some (g__100,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__101 := Some ((g__100, n)) in
                false
           | g__101 => false
           end)) then
        true
      else
        let g__102 := s in
        false
   end.

Definition hex_bits_4_backwards (s : string) 
: M (mword 4) :=
   
   (match (hex_bits_4_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 4)
    | _ => exit tt  : M (mword 4)
    end)
    : M (mword 4).

Definition hex_bits_5_forwards_matches (bv : mword 5)  : bool :=  true.

Definition hex_bits_5_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_5_matches_prefix s) with
           | Some (g__97,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__98 := Some ((g__97, n)) in
                false
           | g__98 => false
           end)) then
        true
      else
        let g__99 := s in
        false
   end.

Definition hex_bits_5_backwards (s : string) 
: M (mword 5) :=
   
   (match (hex_bits_5_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 5)
    | _ => exit tt  : M (mword 5)
    end)
    : M (mword 5).

Definition hex_bits_6_forwards_matches (bv : mword 6)  : bool :=  true.

Definition hex_bits_6_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_6_matches_prefix s) with
           | Some (g__94,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__95 := Some ((g__94, n)) in
                false
           | g__95 => false
           end)) then
        true
      else
        let g__96 := s in
        false
   end.

Definition hex_bits_6_backwards (s : string) 
: M (mword 6) :=
   
   (match (hex_bits_6_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 6)
    | _ => exit tt  : M (mword 6)
    end)
    : M (mword 6).

Definition hex_bits_7_forwards_matches (bv : mword 7)  : bool :=  true.

Definition hex_bits_7_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_7_matches_prefix s) with
           | Some (g__91,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__92 := Some ((g__91, n)) in
                false
           | g__92 => false
           end)) then
        true
      else
        let g__93 := s in
        false
   end.

Definition hex_bits_7_backwards (s : string) 
: M (mword 7) :=
   
   (match (hex_bits_7_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 7)
    | _ => exit tt  : M (mword 7)
    end)
    : M (mword 7).

Definition hex_bits_8_forwards_matches (bv : mword 8)  : bool :=  true.

Definition hex_bits_8_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_8_matches_prefix s) with
           | Some (g__88,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__89 := Some ((g__88, n)) in
                false
           | g__89 => false
           end)) then
        true
      else
        let g__90 := s in
        false
   end.

Definition hex_bits_8_backwards (s : string) 
: M (mword 8) :=
   
   (match (hex_bits_8_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 8)
    | _ => exit tt  : M (mword 8)
    end)
    : M (mword 8).

Definition hex_bits_9_forwards_matches (bv : mword 9)  : bool :=  true.

Definition hex_bits_9_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_9_matches_prefix s) with
           | Some (g__85,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__86 := Some ((g__85, n)) in
                false
           | g__86 => false
           end)) then
        true
      else
        let g__87 := s in
        false
   end.

Definition hex_bits_9_backwards (s : string) 
: M (mword 9) :=
   
   (match (hex_bits_9_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 9)
    | _ => exit tt  : M (mword 9)
    end)
    : M (mword 9).

Definition hex_bits_10_forwards_matches (bv : mword 10)  : bool :=  true.

Definition hex_bits_10_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_10_matches_prefix s) with
           | Some (g__82,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__83 := Some ((g__82, n)) in
                false
           | g__83 => false
           end)) then
        true
      else
        let g__84 := s in
        false
   end.

Definition hex_bits_10_backwards (s : string) 
: M (mword 10) :=
   
   (match (hex_bits_10_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 10)
    | _ => exit tt  : M (mword 10)
    end)
    : M (mword 10).

Definition hex_bits_11_forwards_matches (bv : mword 11)  : bool :=  true.

Definition hex_bits_11_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_11_matches_prefix s) with
           | Some (g__79,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__80 := Some ((g__79, n)) in
                false
           | g__80 => false
           end)) then
        true
      else
        let g__81 := s in
        false
   end.

Definition hex_bits_11_backwards (s : string) 
: M (mword 11) :=
   
   (match (hex_bits_11_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 11)
    | _ => exit tt  : M (mword 11)
    end)
    : M (mword 11).

Definition hex_bits_12_forwards_matches (bv : mword 12)  : bool :=  true.

Definition hex_bits_12_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_12_matches_prefix s) with
           | Some (g__76,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__77 := Some ((g__76, n)) in
                false
           | g__77 => false
           end)) then
        true
      else
        let g__78 := s in
        false
   end.

Definition hex_bits_12_backwards (s : string) 
: M (mword 12) :=
   
   (match (hex_bits_12_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 12)
    | _ => exit tt  : M (mword 12)
    end)
    : M (mword 12).

Definition hex_bits_13_forwards_matches (bv : mword 13)  : bool :=  true.

Definition hex_bits_13_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_13_matches_prefix s) with
           | Some (g__73,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__74 := Some ((g__73, n)) in
                false
           | g__74 => false
           end)) then
        true
      else
        let g__75 := s in
        false
   end.

Definition hex_bits_13_backwards (s : string) 
: M (mword 13) :=
   
   (match (hex_bits_13_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 13)
    | _ => exit tt  : M (mword 13)
    end)
    : M (mword 13).

Definition hex_bits_14_forwards_matches (bv : mword 14)  : bool :=  true.

Definition hex_bits_14_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_14_matches_prefix s) with
           | Some (g__70,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__71 := Some ((g__70, n)) in
                false
           | g__71 => false
           end)) then
        true
      else
        let g__72 := s in
        false
   end.

Definition hex_bits_14_backwards (s : string) 
: M (mword 14) :=
   
   (match (hex_bits_14_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 14)
    | _ => exit tt  : M (mword 14)
    end)
    : M (mword 14).

Definition hex_bits_15_forwards_matches (bv : mword 15)  : bool :=  true.

Definition hex_bits_15_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_15_matches_prefix s) with
           | Some (g__67,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__68 := Some ((g__67, n)) in
                false
           | g__68 => false
           end)) then
        true
      else
        let g__69 := s in
        false
   end.

Definition hex_bits_15_backwards (s : string) 
: M (mword 15) :=
   
   (match (hex_bits_15_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 15)
    | _ => exit tt  : M (mword 15)
    end)
    : M (mword 15).

Definition hex_bits_16_forwards_matches (bv : mword 16)  : bool :=  true.

Definition hex_bits_16_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_16_matches_prefix s) with
           | Some (g__64,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__65 := Some ((g__64, n)) in
                false
           | g__65 => false
           end)) then
        true
      else
        let g__66 := s in
        false
   end.

Definition hex_bits_16_backwards (s : string) 
: M (mword 16) :=
   
   (match (hex_bits_16_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 16)
    | _ => exit tt  : M (mword 16)
    end)
    : M (mword 16).

Definition hex_bits_17_forwards_matches (bv : mword 17)  : bool :=  true.

Definition hex_bits_17_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_17_matches_prefix s) with
           | Some (g__61,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__62 := Some ((g__61, n)) in
                false
           | g__62 => false
           end)) then
        true
      else
        let g__63 := s in
        false
   end.

Definition hex_bits_17_backwards (s : string) 
: M (mword 17) :=
   
   (match (hex_bits_17_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 17)
    | _ => exit tt  : M (mword 17)
    end)
    : M (mword 17).

Definition hex_bits_18_forwards_matches (bv : mword 18)  : bool :=  true.

Definition hex_bits_18_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_18_matches_prefix s) with
           | Some (g__58,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__59 := Some ((g__58, n)) in
                false
           | g__59 => false
           end)) then
        true
      else
        let g__60 := s in
        false
   end.

Definition hex_bits_18_backwards (s : string) 
: M (mword 18) :=
   
   (match (hex_bits_18_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 18)
    | _ => exit tt  : M (mword 18)
    end)
    : M (mword 18).

Definition hex_bits_19_forwards_matches (bv : mword 19)  : bool :=  true.

Definition hex_bits_19_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_19_matches_prefix s) with
           | Some (g__55,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__56 := Some ((g__55, n)) in
                false
           | g__56 => false
           end)) then
        true
      else
        let g__57 := s in
        false
   end.

Definition hex_bits_19_backwards (s : string) 
: M (mword 19) :=
   
   (match (hex_bits_19_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 19)
    | _ => exit tt  : M (mword 19)
    end)
    : M (mword 19).

Definition hex_bits_20_forwards_matches (bv : mword 20)  : bool :=  true.

Definition hex_bits_20_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_20_matches_prefix s) with
           | Some (g__52,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__53 := Some ((g__52, n)) in
                false
           | g__53 => false
           end)) then
        true
      else
        let g__54 := s in
        false
   end.

Definition hex_bits_20_backwards (s : string) 
: M (mword 20) :=
   
   (match (hex_bits_20_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 20)
    | _ => exit tt  : M (mword 20)
    end)
    : M (mword 20).

Definition hex_bits_21_forwards_matches (bv : mword 21)  : bool :=  true.

Definition hex_bits_21_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_21_matches_prefix s) with
           | Some (g__49,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__50 := Some ((g__49, n)) in
                false
           | g__50 => false
           end)) then
        true
      else
        let g__51 := s in
        false
   end.

Definition hex_bits_21_backwards (s : string) 
: M (mword 21) :=
   
   (match (hex_bits_21_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 21)
    | _ => exit tt  : M (mword 21)
    end)
    : M (mword 21).

Definition hex_bits_22_forwards_matches (bv : mword 22)  : bool :=  true.

Definition hex_bits_22_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_22_matches_prefix s) with
           | Some (g__46,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__47 := Some ((g__46, n)) in
                false
           | g__47 => false
           end)) then
        true
      else
        let g__48 := s in
        false
   end.

Definition hex_bits_22_backwards (s : string) 
: M (mword 22) :=
   
   (match (hex_bits_22_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 22)
    | _ => exit tt  : M (mword 22)
    end)
    : M (mword 22).

Definition hex_bits_23_forwards_matches (bv : mword 23)  : bool :=  true.

Definition hex_bits_23_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_23_matches_prefix s) with
           | Some (g__43,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__44 := Some ((g__43, n)) in
                false
           | g__44 => false
           end)) then
        true
      else
        let g__45 := s in
        false
   end.

Definition hex_bits_23_backwards (s : string) 
: M (mword 23) :=
   
   (match (hex_bits_23_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 23)
    | _ => exit tt  : M (mword 23)
    end)
    : M (mword 23).

Definition hex_bits_24_forwards_matches (bv : mword 24)  : bool :=  true.

Definition hex_bits_24_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_24_matches_prefix s) with
           | Some (g__40,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__41 := Some ((g__40, n)) in
                false
           | g__41 => false
           end)) then
        true
      else
        let g__42 := s in
        false
   end.

Definition hex_bits_24_backwards (s : string) 
: M (mword 24) :=
   
   (match (hex_bits_24_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 24)
    | _ => exit tt  : M (mword 24)
    end)
    : M (mword 24).

Definition hex_bits_25_forwards_matches (bv : mword 25)  : bool :=  true.

Definition hex_bits_25_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_25_matches_prefix s) with
           | Some (g__37,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__38 := Some ((g__37, n)) in
                false
           | g__38 => false
           end)) then
        true
      else
        let g__39 := s in
        false
   end.

Definition hex_bits_25_backwards (s : string) 
: M (mword 25) :=
   
   (match (hex_bits_25_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 25)
    | _ => exit tt  : M (mword 25)
    end)
    : M (mword 25).

Definition hex_bits_26_forwards_matches (bv : mword 26)  : bool :=  true.

Definition hex_bits_26_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_26_matches_prefix s) with
           | Some (g__34,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__35 := Some ((g__34, n)) in
                false
           | g__35 => false
           end)) then
        true
      else
        let g__36 := s in
        false
   end.

Definition hex_bits_26_backwards (s : string) 
: M (mword 26) :=
   
   (match (hex_bits_26_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 26)
    | _ => exit tt  : M (mword 26)
    end)
    : M (mword 26).

Definition hex_bits_27_forwards_matches (bv : mword 27)  : bool :=  true.

Definition hex_bits_27_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_27_matches_prefix s) with
           | Some (g__31,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__32 := Some ((g__31, n)) in
                false
           | g__32 => false
           end)) then
        true
      else
        let g__33 := s in
        false
   end.

Definition hex_bits_27_backwards (s : string) 
: M (mword 27) :=
   
   (match (hex_bits_27_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 27)
    | _ => exit tt  : M (mword 27)
    end)
    : M (mword 27).

Definition hex_bits_28_forwards_matches (bv : mword 28)  : bool :=  true.

Definition hex_bits_28_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_28_matches_prefix s) with
           | Some (g__28,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__29 := Some ((g__28, n)) in
                false
           | g__29 => false
           end)) then
        true
      else
        let g__30 := s in
        false
   end.

Definition hex_bits_28_backwards (s : string) 
: M (mword 28) :=
   
   (match (hex_bits_28_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 28)
    | _ => exit tt  : M (mword 28)
    end)
    : M (mword 28).

Definition hex_bits_29_forwards_matches (bv : mword 29)  : bool :=  true.

Definition hex_bits_29_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_29_matches_prefix s) with
           | Some (g__25,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__26 := Some ((g__25, n)) in
                false
           | g__26 => false
           end)) then
        true
      else
        let g__27 := s in
        false
   end.

Definition hex_bits_29_backwards (s : string) 
: M (mword 29) :=
   
   (match (hex_bits_29_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 29)
    | _ => exit tt  : M (mword 29)
    end)
    : M (mword 29).

Definition hex_bits_30_forwards_matches (bv : mword 30)  : bool :=  true.

Definition hex_bits_30_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_30_matches_prefix s) with
           | Some (g__22,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__23 := Some ((g__22, n)) in
                false
           | g__23 => false
           end)) then
        true
      else
        let g__24 := s in
        false
   end.

Definition hex_bits_30_backwards (s : string) 
: M (mword 30) :=
   
   (match (hex_bits_30_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 30)
    | _ => exit tt  : M (mword 30)
    end)
    : M (mword 30).

Definition hex_bits_31_forwards_matches (bv : mword 31)  : bool :=  true.

Definition hex_bits_31_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_31_matches_prefix s) with
           | Some (g__19,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__20 := Some ((g__19, n)) in
                false
           | g__20 => false
           end)) then
        true
      else
        let g__21 := s in
        false
   end.

Definition hex_bits_31_backwards (s : string) 
: M (mword 31) :=
   
   (match (hex_bits_31_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 31)
    | _ => exit tt  : M (mword 31)
    end)
    : M (mword 31).

Definition hex_bits_32_forwards_matches (bv : mword 32)  : bool :=  true.

Definition hex_bits_32_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_32_matches_prefix s) with
           | Some (g__16,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__17 := Some ((g__16, n)) in
                false
           | g__17 => false
           end)) then
        true
      else
        let g__18 := s in
        false
   end.

Definition hex_bits_32_backwards (s : string) 
: M (mword 32) :=
   
   (match (hex_bits_32_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 32)
    | _ => exit tt  : M (mword 32)
    end)
    : M (mword 32).

Definition hex_bits_33_forwards_matches (bv : mword 33)  : bool :=  true.

Definition hex_bits_33_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_33_matches_prefix s) with
           | Some (g__13,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__14 := Some ((g__13, n)) in
                false
           | g__14 => false
           end)) then
        true
      else
        let g__15 := s in
        false
   end.

Definition hex_bits_33_backwards (s : string) 
: M (mword 33) :=
   
   (match (hex_bits_33_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 33)
    | _ => exit tt  : M (mword 33)
    end)
    : M (mword 33).

Definition hex_bits_48_forwards_matches (bv : mword 48)  : bool :=  true.

Definition hex_bits_48_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_48_matches_prefix s) with
           | Some (g__10,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__11 := Some ((g__10, n)) in
                false
           | g__11 => false
           end)) then
        true
      else
        let g__12 := s in
        false
   end.

Definition hex_bits_48_backwards (s : string) 
: M (mword 48) :=
   
   (match (hex_bits_48_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 48)
    | _ => exit tt  : M (mword 48)
    end)
    : M (mword 48).

Definition hex_bits_64_forwards_matches (bv : mword 64)  : bool :=  true.

Definition hex_bits_64_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_64_matches_prefix s) with
           | Some (g__7,(existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true
              else
                let g__8 := Some ((g__7, n)) in
                false
           | g__8 => false
           end)) then
        true
      else
        let g__9 := s in
        false
   end.

Definition hex_bits_64_backwards (s : string) 
: M (mword 64) :=
   
   (match (hex_bits_64_matches_prefix s) with
    | Some (bv,(existT _ n _)) => returnm (bv  : mword 64)
    | _ => exit tt  : M (mword 64)
    end)
    : M (mword 64).

Axiom vcons : forall {n : Z} {a : Type} (_ : a) (_ : vec a n) , vec a (n + 1).

Definition neq_vec {n : Z} (x : mword n) (y : mword n)  : bool :=  negb (eq_vec x y).



Axiom __raw_SetSlice_int : forall  (w : Z) (ex33522_ : Z) (ex33523_ : Z) (_ : mword w) , Z.

Definition __GetSlice_int (n : Z) (m : Z) (o : Z) `{ArithFact (n >= 0)} 
: mword n :=
   
   get_slice_int n m o.

Axiom __raw_SetSlice_bits : forall

(n : Z) (w : Z) (_ : mword n) (ex33524_ : Z) (_ : mword w)
,
mword n.

Axiom __raw_GetSlice_bits : forall

(n : Z) (w : Z) (_ : mword n) (ex33525_ : Z)
`{ArithFact (w >= 0)},
mword w.

Axiom __SignExtendSlice : forall {m : Z} (_ : mword m) (ex33526_ : Z) (ex33527_ : Z) , mword m.

Axiom __ZeroExtendSlice : forall {m : Z} (_ : mword m) (ex33528_ : Z) (ex33529_ : Z) , mword m.

Definition cast_unit_vec (b : bitU) 
: M (mword 1) :=
   
   (match b with
    | B0 => returnm ((vec_of_bits [B0]  : mword 1)  : mword 1)
    | B1 => returnm ((vec_of_bits [B1]  : mword 1)  : mword 1)
    | _ => exit tt  : M (mword 1)
    end)
    : M (mword 1).

Axiom DecStr : forall  (ex33530_ : Z) , string.

Axiom HexStr : forall  (ex33531_ : Z) , string.

Axiom Sqrt : forall  (_ : R) , R.

Axiom RoundDown : forall  (_ : R) , Z.

Axiom RoundUp : forall  (_ : R) , Z.

Axiom abs_real : forall  (_ : R) , R.

Axiom quot_round_zero : forall  (ex33532_ : Z) (ex33533_ : Z) , Z.

Axiom rem_round_zero : forall  (ex33534_ : Z) (ex33535_ : Z) , Z.

Axiom Real : forall  (ex33536_ : Z) , R.

Definition __RISCV_write (addr : mword 64) (width : Z) (data : mword (8 * width)) 
: M (bool) :=
   
   (write_ram 64 width
      (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0]
        : mword 64) addr data)
    : M (bool).

Axiom __TraceMemoryWrite : forall {m : Z} (n : Z) (_ : mword m) (_ : mword (8 * n)) , unit.

Definition __RISCV_read (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (width >= 0)} 
: M (option (mword (8 * width))) :=
   
   (match (aq, rl, res) with
    | (false, false, false) =>
       (read_ram 64 width
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0]
            : mword 64) addr) >>= fun w__0 : mword (8 * width) =>
       returnm ((Some
                   (w__0))
        : option (mword (8 * width)))
    | (true, false, false) =>
       (read_ram 64 width
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0]
            : mword 64) addr) >>= fun w__1 : mword (8 * width) =>
       returnm ((Some
                   (w__1))
        : option (mword (8 * width)))
    | (true, true, false) =>
       (read_ram 64 width
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0]
            : mword 64) addr) >>= fun w__2 : mword (8 * width) =>
       returnm ((Some
                   (w__2))
        : option (mword (8 * width)))
    | (false, false, true) =>
       (read_ram 64 width
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0]
            : mword 64) addr) >>= fun w__3 : mword (8 * width) =>
       returnm ((Some
                   (w__3))
        : option (mword (8 * width)))
    | (true, false, true) =>
       (read_ram 64 width
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0]
            : mword 64) addr) >>= fun w__4 : mword (8 * width) =>
       returnm ((Some
                   (w__4))
        : option (mword (8 * width)))
    | (true, true, true) =>
       (read_ram 64 width
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                        B0]
            : mword 64) addr) >>= fun w__5 : mword (8 * width) =>
       returnm ((Some
                   (w__5))
        : option (mword (8 * width)))
    | (false, true, false) => returnm (None  : option (mword (8 * width)))
    | (false, true, true) => returnm (None  : option (mword (8 * width)))
    end)
    : M (option (mword (8 * width))).

Axiom __TraceMemoryRead : forall {m : Z} (n : Z) (_ : mword m) (_ : mword (8 * n)) , unit.

Definition ex_nat {ex28122_ : Z} (n : Z) `{ArithFact (0 <= ex28122_)} `{ArithFact (n = ex28122_)}
: {syn_n : Z & ArithFact (syn_n >= 0)} :=
   
   build_ex(n).

Definition ex_int {ex28124_ : Z} (n : Z) `{ArithFact (n = ex28124_)}
: {syn_n : Z & ArithFact (True)} :=
   
   build_ex(n).

Definition coerce_int_nat {ex28126_ : Z} (x : Z) `{ArithFact (x = ex28126_)}
: M ({n : Z & ArithFact (n >= 0)}) :=
   
   assert_exp' (Z.geb (projT1 (__id x)) 0) "[[96mmodel/prelude.sail[0m]:977:28-29
977[96m |[0m  assert(constraint('x >= 0));
   [91m |[0m                            [91m^[0m
   [91m |[0m 
: constraint('x >= 0)" >>= fun _ =>
   returnm (build_ex
   (x
    : Z)).

Definition EXTS {n : Z} (m : Z) (v : mword n) `{ArithFact (m >= n)}  : mword m :=  sign_extend v m.

Definition EXTZ {n : Z} (m : Z) (v : mword n) `{ArithFact (m >= n)}  : mword m :=  zero_extend v m.

Definition zopz0zI_s {n : Z} (x : mword n) (y : mword n) `{ArithFact (n >= (0 + 1))} 
: bool :=
   
   Z.ltb (projT1 (sint x)) (projT1 (sint y)).

Definition zopz0zKzJ_s {n : Z} (x : mword n) (y : mword n) `{ArithFact (n >= (0 + 1))} 
: bool :=
   
   Z.geb (projT1 (sint x)) (projT1 (sint y)).

Definition zopz0zI_u {n : Z} (x : mword n) (y : mword n) 
: bool :=
   
   Z.ltb (projT1 (uint x)) (projT1 (uint y)).

Definition zopz0zKzJ_u {n : Z} (x : mword n) (y : mword n) 
: bool :=
   
   Z.geb (projT1 (uint x)) (projT1 (uint y)).

Definition zopz0zIzJ_u {n : Z} (x : mword n) (y : mword n) 
: bool :=
   
   Z.leb (projT1 (uint x)) (projT1 (uint y)).

Definition bool_to_bits (x : bool) 
: mword 1 :=
   
   if sumbool_of_bool (x) then (vec_of_bits [B1]  : mword 1)
   else (vec_of_bits [B0]  : mword 1).

Definition bit_to_bool (b : bitU) 
: M (bool) :=
   
   (match b with
    | B1 => returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
    | B0 => returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
    | _ => exit tt  : M (bool)
    end)
    : M (bool).

Definition vector64 (n : Z)  : mword 64 :=  get_slice_int 64 n 0.

Definition to_bits (l : Z) (n : Z) `{ArithFact (l >= 0)}  : mword l :=  get_slice_int l n 0.

Axiom vector_update_subrange_inc : forall
{n : Z}
(_ : mword n) (m : Z) (o : Z) (_ : mword (o - (m - 1)))
,
mword n.

Definition MAX (n : Z) `{ArithFact (n >= 0)} 
: {_retval : Z & ArithFact (_retval = (2 ^ n - 1))} :=
   
   build_ex(Z.sub (projT1 (pow2 n)) 1).

Definition zeros_implicit (n : Z) `{ArithFact (n >= 0)}  : mword n :=  zeros n.

Definition ones_n (n : Z) `{ArithFact (n >= 0)} 
: mword n :=
   
   autocast (replicate_bits (vec_of_bits [B1]  : mword 1) n).

Definition ones_implicit (n : Z) `{ArithFact (n >= 0)}  : mword n :=  ones_n n.

Definition shift_right_arith64 (v : mword 64) (shift : mword 6) 
: mword 64 :=
   
   let v128 : bits 128 := EXTS 128 v in
   subrange_vec_dec (shift_bits_right v128 shift) 63 0.

Definition shift_right_arith32 (v : mword 32) (shift : mword 5) 
: mword 32 :=
   
   let v64 : bits 64 := EXTS 64 v in
   subrange_vec_dec (shift_bits_right v64 shift) 31 0.

Fixpoint _rec_n_leading_spaces (s : string) (_reclimit : Z)  (_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M ({n : Z & ArithFact (n >= 0)}) :=
   
   assert_exp' (Z.geb _reclimit 0) "recursion limit reached" >>= fun _ =>
   let p0_ := s in
   (if ((generic_eq p0_ "")) then returnm (build_ex (0  : Z))
    else
      let p0_ := string_take s 1 in
      (if ((generic_eq p0_ " ")) then
         (_rec_n_leading_spaces (string_drop s 1) (Z.sub _reclimit 1) (_limit_reduces _acc)) >>= fun '(existT _ w__0 _ : {n : Z & ArithFact (n >=
           0)}) =>
         returnm (build_ex
         (projT1
         (build_ex
         (Z.add 1 w__0)
          : {_atom : Z & ArithFact (exists ex20309_ , _atom = (1 + ex20309_) /\ 0 <= ex20309_)})))
       else returnm (build_ex (0  : Z)))
       : M ({n : Z & ArithFact (n >= 0)}))
    : M ({n : Z & ArithFact (n >= 0)}).

Definition n_leading_spaces (s : string) 
: M ({n : Z & ArithFact (n >= 0)}) :=
   
   (_rec_n_leading_spaces s ((projT1 (string_length s))  : Z) (Zwf_guarded _))
    : M ({n : Z & ArithFact (n >= 0)}).

Definition spc_forwards '(tt : unit)  : string :=  " ".

Definition spc_backwards (s : string)  : unit :=  tt.

Definition spc_matches_prefix (s : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   (n_leading_spaces s) >>= fun '(existT _ n _) =>
   let p0_ := n in
   returnm ((if sumbool_of_bool ((Z.eqb p0_ 0)) then None
             else Some ((tt, build_ex n)))
    : option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition opt_spc_forwards '(tt : unit)  : string :=  "".

Definition opt_spc_backwards (s : string)  : unit :=  tt.

Definition opt_spc_matches_prefix (s : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   (n_leading_spaces s) >>= fun '(existT _ w__0 _ : {n : Z & ArithFact (n >= 0)}) =>
   returnm ((Some
               ((tt, build_ex
               w__0)))
    : option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition def_spc_forwards '(tt : unit)  : string :=  " ".

Definition def_spc_backwards (s : string)  : unit :=  tt.

Definition def_spc_matches_prefix (s : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   (opt_spc_matches_prefix s)
    : M (option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition CPtrCmpOp_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 7)} 
: CPtrCmpOp :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then CEQ
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then CNE
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then CLT
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then CLE
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then CLTU
   else if sumbool_of_bool ((Z.eqb p0_ 5)) then CLEU
   else if sumbool_of_bool ((Z.eqb p0_ 6)) then CEXEQ
   else CNEXEQ.

Definition num_of_CPtrCmpOp (arg_ : CPtrCmpOp) 
: {e : Z & ArithFact (0 <= e /\ e <= 7)} :=
   
   build_ex(match arg_ with
            | CEQ => 0
            | CNE => 1
            | CLT => 2
            | CLE => 3
            | CLTU => 4
            | CLEU => 5
            | CEXEQ => 6
            | CNEXEQ => 7
            end).

Definition ClearRegSet_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 1)} 
: ClearRegSet :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then GPRegs
   else FPRegs.

Definition num_of_ClearRegSet (arg_ : ClearRegSet) 
: {e : Z & ArithFact (0 <= e /\ e <= 1)} :=
   
   build_ex(match arg_ with | GPRegs => 0 | FPRegs => 1 end).

Definition MAX_U64 := projT1 (MAX 64).
Hint Unfold MAX_U64 : sail.
Definition CapEx_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 23)} 
: CapEx :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then CapEx_None
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then CapEx_LengthViolation
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then CapEx_TagViolation
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then CapEx_SealViolation
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then CapEx_TypeViolation
   else if sumbool_of_bool ((Z.eqb p0_ 5)) then CapEx_CallTrap
   else if sumbool_of_bool ((Z.eqb p0_ 6)) then CapEx_ReturnTrap
   else if sumbool_of_bool ((Z.eqb p0_ 7)) then CapEx_TSSUnderFlow
   else if sumbool_of_bool ((Z.eqb p0_ 8)) then CapEx_UserDefViolation
   else if sumbool_of_bool ((Z.eqb p0_ 9)) then CapEx_TLBNoStoreCap
   else if sumbool_of_bool ((Z.eqb p0_ 10)) then CapEx_InexactBounds
   else if sumbool_of_bool ((Z.eqb p0_ 11)) then CapEx_GlobalViolation
   else if sumbool_of_bool ((Z.eqb p0_ 12)) then CapEx_PermitExecuteViolation
   else if sumbool_of_bool ((Z.eqb p0_ 13)) then CapEx_PermitLoadViolation
   else if sumbool_of_bool ((Z.eqb p0_ 14)) then CapEx_PermitStoreViolation
   else if sumbool_of_bool ((Z.eqb p0_ 15)) then CapEx_PermitLoadCapViolation
   else if sumbool_of_bool ((Z.eqb p0_ 16)) then CapEx_PermitStoreCapViolation
   else if sumbool_of_bool ((Z.eqb p0_ 17)) then CapEx_PermitStoreLocalCapViolation
   else if sumbool_of_bool ((Z.eqb p0_ 18)) then CapEx_PermitSealViolation
   else if sumbool_of_bool ((Z.eqb p0_ 19)) then CapEx_AccessSystemRegsViolation
   else if sumbool_of_bool ((Z.eqb p0_ 20)) then CapEx_PermitCCallViolation
   else if sumbool_of_bool ((Z.eqb p0_ 21)) then CapEx_AccessCCallIDCViolation
   else if sumbool_of_bool ((Z.eqb p0_ 22)) then CapEx_PermitUnsealViolation
   else CapEx_PermitSetCIDViolation.

Definition num_of_CapEx (arg_ : CapEx) 
: {e : Z & ArithFact (0 <= e /\ e <= 23)} :=
   
   build_ex(match arg_ with
            | CapEx_None => 0
            | CapEx_LengthViolation => 1
            | CapEx_TagViolation => 2
            | CapEx_SealViolation => 3
            | CapEx_TypeViolation => 4
            | CapEx_CallTrap => 5
            | CapEx_ReturnTrap => 6
            | CapEx_TSSUnderFlow => 7
            | CapEx_UserDefViolation => 8
            | CapEx_TLBNoStoreCap => 9
            | CapEx_InexactBounds => 10
            | CapEx_GlobalViolation => 11
            | CapEx_PermitExecuteViolation => 12
            | CapEx_PermitLoadViolation => 13
            | CapEx_PermitStoreViolation => 14
            | CapEx_PermitLoadCapViolation => 15
            | CapEx_PermitStoreCapViolation => 16
            | CapEx_PermitStoreLocalCapViolation => 17
            | CapEx_PermitSealViolation => 18
            | CapEx_AccessSystemRegsViolation => 19
            | CapEx_PermitCCallViolation => 20
            | CapEx_AccessCCallIDCViolation => 21
            | CapEx_PermitUnsealViolation => 22
            | CapEx_PermitSetCIDViolation => 23
            end).

Definition CapExCode (ex : CapEx) 
: mword 5 :=
   
   match ex with
   | CapEx_None => (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
   | CapEx_LengthViolation => (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)
   | CapEx_TagViolation => (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
   | CapEx_SealViolation => (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5)
   | CapEx_TypeViolation => (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5)
   | CapEx_CallTrap => (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5)
   | CapEx_ReturnTrap => (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5)
   | CapEx_TSSUnderFlow => (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5)
   | CapEx_UserDefViolation => (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5)
   | CapEx_TLBNoStoreCap => (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5)
   | CapEx_InexactBounds => (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5)
   | CapEx_GlobalViolation => (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5)
   | CapEx_PermitExecuteViolation => (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5)
   | CapEx_PermitLoadViolation => (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5)
   | CapEx_PermitStoreViolation => (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5)
   | CapEx_PermitLoadCapViolation => (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5)
   | CapEx_PermitStoreCapViolation => (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5)
   | CapEx_PermitStoreLocalCapViolation => (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5)
   | CapEx_PermitSealViolation => (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5)
   | CapEx_AccessSystemRegsViolation => (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5)
   | CapEx_PermitCCallViolation => (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5)
   | CapEx_AccessCCallIDCViolation => (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5)
   | CapEx_PermitUnsealViolation => (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5)
   | CapEx_PermitSetCIDViolation => (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5)
   end.

Definition string_of_capex (ex : CapEx) 
: string :=
   
   match ex with
   | CapEx_None => "None"
   | CapEx_LengthViolation => "LengthViolation"
   | CapEx_TagViolation => "TagViolation"
   | CapEx_SealViolation => "SealViolation"
   | CapEx_TypeViolation => "TypeViolation"
   | CapEx_CallTrap => "CallTrap"
   | CapEx_ReturnTrap => "ReturnTrap"
   | CapEx_TSSUnderFlow => "TSSUnderFlow"
   | CapEx_UserDefViolation => "UserDefViolation"
   | CapEx_TLBNoStoreCap => "TLBNoStoreCap"
   | CapEx_InexactBounds => "InexactBounds"
   | CapEx_GlobalViolation => "GlobalViolation"
   | CapEx_PermitExecuteViolation => "PermitExecuteViolation"
   | CapEx_PermitLoadViolation => "PermitLoadViolation"
   | CapEx_PermitStoreViolation => "PermitStoreViolation"
   | CapEx_PermitLoadCapViolation => "PermitLoadCapViolation"
   | CapEx_PermitStoreCapViolation => "PermitStoreCapViolation"
   | CapEx_PermitStoreLocalCapViolation => "PermitStoreLocalCapViolation"
   | CapEx_PermitSealViolation => "PermitSealViolation"
   | CapEx_AccessSystemRegsViolation => "AccessSystemRegsViolation"
   | CapEx_PermitCCallViolation => "PermitCCallViolation"
   | CapEx_AccessCCallIDCViolation => "AccessCCallIDCViolation"
   | CapEx_PermitUnsealViolation => "PermitUnsealViolation"
   | CapEx_PermitSetCIDViolation => "PermitSetCIDViolation"
   end.

Definition checkCP2usable '(tt : unit)  : unit :=  tt.

Definition max_otype := projT1 (MAX 24).
Hint Unfold max_otype : sail.
Definition null_cap : Capability :=
{| Capability_tag := false; 
   Capability_padding := (zeros_implicit 8); 
   Capability_otype := (ones_implicit 24); 
   Capability_uperms := (zeros_implicit 16); 
   Capability_perm_reserved12_14 := (zeros_implicit 3); 
   Capability_permit_set_CID := false; 
   Capability_access_system_regs := false; 
   Capability_permit_unseal := false; 
   Capability_permit_ccall := false; 
   Capability_permit_seal := false; 
   Capability_permit_store_local_cap := false; 
   Capability_permit_store_cap := false; 
   Capability_permit_load_cap := false; 
   Capability_permit_store := false; 
   Capability_permit_load := false; 
   Capability_permit_execute := false; 
   Capability_global := false; 
   Capability_sealed := false; 
   Capability_address := (zeros_implicit 64); 
   Capability_base := (zeros_implicit 64); 
   Capability_length :=
     (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                   B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                   B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                   B1]
       : mword 64) |}.
Hint Unfold null_cap : sail.
Definition default_cap : Capability :=
{| Capability_tag := true; 
   Capability_padding := (zeros_implicit 8); 
   Capability_otype := (ones_implicit 24); 
   Capability_uperms := (ones_implicit 16); 
   Capability_perm_reserved12_14 := (zeros_implicit 3); 
   Capability_permit_set_CID := true; 
   Capability_access_system_regs := true; 
   Capability_permit_unseal := true; 
   Capability_permit_ccall := true; 
   Capability_permit_seal := true; 
   Capability_permit_store_local_cap := true; 
   Capability_permit_store_cap := true; 
   Capability_permit_load_cap := true; 
   Capability_permit_store := true; 
   Capability_permit_load := true; 
   Capability_permit_execute := true; 
   Capability_global := true; 
   Capability_sealed := false; 
   Capability_address := (zeros_implicit 64); 
   Capability_base := (zeros_implicit 64); 
   Capability_length :=
     (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                   B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                   B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                   B1]
       : mword 64) |}.
Hint Unfold default_cap : sail.
Definition capBitsToCapability (tag : bool) (capBits : mword 256) 
: M (Capability) :=
   
   (bit_to_bool (access_vec_dec capBits 204)) >>= fun w__0 : bool =>
   (bit_to_bool (access_vec_dec capBits 203)) >>= fun w__1 : bool =>
   (bit_to_bool (access_vec_dec capBits 202)) >>= fun w__2 : bool =>
   (bit_to_bool (access_vec_dec capBits 201)) >>= fun w__3 : bool =>
   (bit_to_bool (access_vec_dec capBits 200)) >>= fun w__4 : bool =>
   (bit_to_bool (access_vec_dec capBits 199)) >>= fun w__5 : bool =>
   (bit_to_bool (access_vec_dec capBits 198)) >>= fun w__6 : bool =>
   (bit_to_bool (access_vec_dec capBits 197)) >>= fun w__7 : bool =>
   (bit_to_bool (access_vec_dec capBits 196)) >>= fun w__8 : bool =>
   (bit_to_bool (access_vec_dec capBits 195)) >>= fun w__9 : bool =>
   (bit_to_bool (access_vec_dec capBits 194)) >>= fun w__10 : bool =>
   (bit_to_bool (access_vec_dec capBits 193)) >>= fun w__11 : bool =>
   (bit_to_bool (access_vec_dec capBits 192)) >>= fun w__12 : bool =>
   returnm (({| Capability_tag := tag; 
                Capability_padding := (subrange_vec_dec capBits 255 248); 
                Capability_otype := (subrange_vec_dec capBits 247 224); 
                Capability_uperms := (subrange_vec_dec capBits 223 208); 
                Capability_perm_reserved12_14 := (subrange_vec_dec capBits 207 205); 
                Capability_permit_set_CID := (w__0  : bool); 
                Capability_access_system_regs := (w__1  : bool); 
                Capability_permit_unseal := (w__2  : bool); 
                Capability_permit_ccall := (w__3  : bool); 
                Capability_permit_seal := (w__4  : bool); 
                Capability_permit_store_local_cap := (w__5  : bool); 
                Capability_permit_store_cap := (w__6  : bool); 
                Capability_permit_load_cap := (w__7  : bool); 
                Capability_permit_store := (w__8  : bool); 
                Capability_permit_load := (w__9  : bool); 
                Capability_permit_execute := (w__10  : bool); 
                Capability_global := (w__11  : bool); 
                Capability_sealed := (w__12  : bool); 
                Capability_address := (subrange_vec_dec capBits 191 128); 
                Capability_base := (subrange_vec_dec capBits 127 64); 
                Capability_length := (subrange_vec_dec capBits 63 0) |})
    : Capability).

Definition getCapHardPerms (cap : Capability) 
: mword 12 :=
   
   concat_vec (bool_to_bits cap.(Capability_permit_set_CID))
     (concat_vec (bool_to_bits cap.(Capability_access_system_regs))
        (concat_vec (bool_to_bits cap.(Capability_permit_unseal))
           (concat_vec (bool_to_bits cap.(Capability_permit_ccall))
              (concat_vec (bool_to_bits cap.(Capability_permit_seal))
                 (concat_vec (bool_to_bits cap.(Capability_permit_store_local_cap))
                    (concat_vec (bool_to_bits cap.(Capability_permit_store_cap))
                       (concat_vec (bool_to_bits cap.(Capability_permit_load_cap))
                          (concat_vec (bool_to_bits cap.(Capability_permit_store))
                             (concat_vec (bool_to_bits cap.(Capability_permit_load))
                                (concat_vec (bool_to_bits cap.(Capability_permit_execute))
                                   (bool_to_bits cap.(Capability_global)))))))))))).

Definition getCapPerms (cap : Capability) 
: mword 31 :=
   
   concat_vec cap.(Capability_uperms)
     (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3) (getCapHardPerms cap)).

Definition capToBits (cap : Capability) 
: mword 256 :=
   
   concat_vec cap.(Capability_padding)
     (concat_vec cap.(Capability_otype)
        (concat_vec cap.(Capability_uperms)
           (concat_vec cap.(Capability_perm_reserved12_14)
              (concat_vec (getCapHardPerms cap)
                 (concat_vec (bool_to_bits cap.(Capability_sealed))
                    (concat_vec cap.(Capability_address)
                       (concat_vec cap.(Capability_base) cap.(Capability_length)))))))).

Definition null_cap_bits : CapBits := capToBits null_cap.
Hint Unfold null_cap_bits : sail.
Definition capToMemBits (cap : Capability)  : mword 256 :=  xor_vec (capToBits cap) null_cap_bits.

Definition memBitsToCapability (tag : bool) (b : mword 256) 
: M (Capability) :=
   
   (capBitsToCapability tag (xor_vec b null_cap_bits))
    : M (Capability).

Definition setCapPerms (cap : Capability) (perms : mword 31) 
: M (Capability) :=
   
   (bit_to_bool (access_vec_dec perms 11)) >>= fun w__0 : bool =>
   (bit_to_bool (access_vec_dec perms 10)) >>= fun w__1 : bool =>
   (bit_to_bool (access_vec_dec perms 9)) >>= fun w__2 : bool =>
   (bit_to_bool (access_vec_dec perms 8)) >>= fun w__3 : bool =>
   (bit_to_bool (access_vec_dec perms 7)) >>= fun w__4 : bool =>
   (bit_to_bool (access_vec_dec perms 6)) >>= fun w__5 : bool =>
   (bit_to_bool (access_vec_dec perms 5)) >>= fun w__6 : bool =>
   (bit_to_bool (access_vec_dec perms 4)) >>= fun w__7 : bool =>
   (bit_to_bool (access_vec_dec perms 3)) >>= fun w__8 : bool =>
   (bit_to_bool (access_vec_dec perms 2)) >>= fun w__9 : bool =>
   (bit_to_bool (access_vec_dec perms 1)) >>= fun w__10 : bool =>
   (bit_to_bool (access_vec_dec perms 0)) >>= fun w__11 : bool =>
   returnm ({| Capability_tag := cap.(Capability_tag); 
               Capability_padding := cap.(Capability_padding); 
               Capability_otype := cap.(Capability_otype); 
               Capability_uperms := (subrange_vec_dec perms 30 15); 
               Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
               Capability_permit_set_CID := (w__0  : bool); 
               Capability_access_system_regs := (w__1  : bool); 
               Capability_permit_unseal := (w__2  : bool); 
               Capability_permit_ccall := (w__3  : bool); 
               Capability_permit_seal := (w__4  : bool); 
               Capability_permit_store_local_cap := (w__5  : bool); 
               Capability_permit_store_cap := (w__6  : bool); 
               Capability_permit_load_cap := (w__7  : bool); 
               Capability_permit_store := (w__8  : bool); 
               Capability_permit_load := (w__9  : bool); 
               Capability_permit_execute := (w__10  : bool); 
               Capability_global := (w__11  : bool); 
               Capability_sealed := cap.(Capability_sealed); 
               Capability_address := cap.(Capability_address); 
               Capability_base := cap.(Capability_base); 
               Capability_length := cap.(Capability_length) |}
    : Capability).

Definition sealCap (cap : Capability) (otype : mword 24) 
: (bool * Capability) :=
   
   (true, {| Capability_tag := cap.(Capability_tag); 
             Capability_padding := cap.(Capability_padding); 
             Capability_otype := otype; 
             Capability_uperms := cap.(Capability_uperms); 
             Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
             Capability_permit_set_CID := cap.(Capability_permit_set_CID); 
             Capability_access_system_regs := cap.(Capability_access_system_regs); 
             Capability_permit_unseal := cap.(Capability_permit_unseal); 
             Capability_permit_ccall := cap.(Capability_permit_ccall); 
             Capability_permit_seal := cap.(Capability_permit_seal); 
             Capability_permit_store_local_cap := cap.(Capability_permit_store_local_cap); 
             Capability_permit_store_cap := cap.(Capability_permit_store_cap); 
             Capability_permit_load_cap := cap.(Capability_permit_load_cap); 
             Capability_permit_store := cap.(Capability_permit_store); 
             Capability_permit_load := cap.(Capability_permit_load); 
             Capability_permit_execute := cap.(Capability_permit_execute); 
             Capability_global := cap.(Capability_global); 
             Capability_sealed := true; 
             Capability_address := cap.(Capability_address); 
             Capability_base := cap.(Capability_base); 
             Capability_length := cap.(Capability_length) |}).

Definition unsealCap (cap : Capability) 
: Capability :=
   
   {| Capability_tag := cap.(Capability_tag); 
      Capability_padding := cap.(Capability_padding); 
      Capability_otype := (ones_implicit 24); 
      Capability_uperms := cap.(Capability_uperms); 
      Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
      Capability_permit_set_CID := cap.(Capability_permit_set_CID); 
      Capability_access_system_regs := cap.(Capability_access_system_regs); 
      Capability_permit_unseal := cap.(Capability_permit_unseal); 
      Capability_permit_ccall := cap.(Capability_permit_ccall); 
      Capability_permit_seal := cap.(Capability_permit_seal); 
      Capability_permit_store_local_cap := cap.(Capability_permit_store_local_cap); 
      Capability_permit_store_cap := cap.(Capability_permit_store_cap); 
      Capability_permit_load_cap := cap.(Capability_permit_load_cap); 
      Capability_permit_store := cap.(Capability_permit_store); 
      Capability_permit_load := cap.(Capability_permit_load); 
      Capability_permit_execute := cap.(Capability_permit_execute); 
      Capability_global := cap.(Capability_global); 
      Capability_sealed := false; 
      Capability_address := cap.(Capability_address); 
      Capability_base := cap.(Capability_base); 
      Capability_length := cap.(Capability_length) |}.

Definition getCapBase (c : Capability) 
: {rangevar : Z & ArithFact (0 <= rangevar /\ rangevar <= (2 ^ 64 - 1))} :=
   
   build_ex(projT1
   (uint c.(Capability_base))).

Definition getCapBaseBits (c : Capability)  : mword 64 :=  c.(Capability_base).

Definition getCapTop (c : Capability) 
: {rangevar : Z & ArithFact (0 <= rangevar /\ rangevar <= (2 ^ 65))} :=
   
   build_ex(Z.add (projT1 (uint c.(Capability_base))) (projT1 (uint c.(Capability_length)))).

Definition getCapBounds (c : Capability) 
:
({rangevar : Z & ArithFact (0 <= rangevar /\ rangevar <= (2 ^ 64 - 1))} * {rangevar : Z & ArithFact (0 <=
  rangevar /\
  rangevar <= (2 ^ 65))}) :=
   
   (build_ex
   (projT1
    (getCapBase c)), build_ex
   (projT1
    (getCapTop c))).

Definition inCapBounds (cap : Capability) (addr : mword 64) (size : Z)
`{ArithFact (0 <= size /\ size <= (2 ^ 64 - 1))} 
: bool :=
   
   let '(existT _ base _, existT _ top _) := getCapBounds cap in
   let 'a := projT1 (uint addr) in
   andb (Z.geb a base) (Z.leb (Z.add a size) top).

Definition getCapOffset (c : Capability) 
: {rangevar : Z & ArithFact (0 <= rangevar /\ rangevar <= (2 ^ 64 - 1))} :=
   
   build_ex(projT1
   (emod_with_eq (Z.sub (projT1 (uint c.(Capability_address))) (projT1 (uint c.(Capability_base))))
      (projT1
       (pow2 64)))).

Definition getCapLength (c : Capability) 
: {rangevar : Z & ArithFact (0 <= rangevar /\ rangevar <= (2 ^ 65))} :=
   
   build_ex(projT1
   (uint c.(Capability_length))).

Definition getCapCursor (c : Capability) 
: {rangevar : Z & ArithFact (0 <= rangevar /\ rangevar <= (2 ^ 64 - 1))} :=
   
   build_ex(projT1
   (uint c.(Capability_address))).

Definition setCapAddr (c : Capability) (addr : mword 64) 
: (bool * Capability) :=
   
   (true, {[ c with Capability_address := addr ]}).

Definition setCapAddrOrNull (cap : Capability) (addr : mword 64) 
: Capability :=
   
   let '(_, newCap) := setCapAddr cap addr in
   newCap.

Definition setCapOffset (c : Capability) (offset : mword 64) 
: (bool * Capability) :=
   
   (true, {[ c with Capability_address := (add_vec c.(Capability_base) offset) ]}).

Definition incCapOffset (c : Capability) (delta : mword 64) 
: (bool * Capability) :=
   
   let newAddr : bits 64 := add_vec c.(Capability_address) delta in
   (true, {[ c with Capability_address := newAddr ]}).

Definition setCapBounds (cap : Capability) (base : mword 64) (top : mword 65) 
: (bool * Capability) :=
   
   let length : bits 65 := sub_vec top (concat_vec (vec_of_bits [B0]  : mword 1) base) in
   (true, {| Capability_tag := cap.(Capability_tag); 
             Capability_padding := cap.(Capability_padding); 
             Capability_otype := cap.(Capability_otype); 
             Capability_uperms := cap.(Capability_uperms); 
             Capability_perm_reserved12_14 := cap.(Capability_perm_reserved12_14); 
             Capability_permit_set_CID := cap.(Capability_permit_set_CID); 
             Capability_access_system_regs := cap.(Capability_access_system_regs); 
             Capability_permit_unseal := cap.(Capability_permit_unseal); 
             Capability_permit_ccall := cap.(Capability_permit_ccall); 
             Capability_permit_seal := cap.(Capability_permit_seal); 
             Capability_permit_store_local_cap := cap.(Capability_permit_store_local_cap); 
             Capability_permit_store_cap := cap.(Capability_permit_store_cap); 
             Capability_permit_load_cap := cap.(Capability_permit_load_cap); 
             Capability_permit_store := cap.(Capability_permit_store); 
             Capability_permit_load := cap.(Capability_permit_load); 
             Capability_permit_execute := cap.(Capability_permit_execute); 
             Capability_global := cap.(Capability_global); 
             Capability_sealed := cap.(Capability_sealed); 
             Capability_address := base; 
             Capability_base := base; 
             Capability_length := (subrange_vec_dec length 63 0) |}).

Definition int_to_cap (address : mword 64) 
: Capability :=
   
   {[ null_cap with Capability_address := address ]}.

Definition xlen := 64.
Hint Unfold xlen : sail.
Definition xlen_max_unsigned := Z.sub (projT1 (pow2 xlen)) 1.
Hint Unfold xlen_max_unsigned : sail.
Definition xlen_max_signed := Z.sub (projT1 (pow2 (Z.sub xlen 1))) 1.
Hint Unfold xlen_max_signed : sail.
Definition xlen_min_signed := Z.sub 0 (projT1 (pow2 (Z.sub xlen 1))).
Hint Unfold xlen_min_signed : sail.
Definition min_inst_bytes := 2.
Hint Unfold min_inst_bytes : sail.
Definition regbits_to_regno (b : mword 5) 
: {n : Z & ArithFact (0 <= n /\ (n + 1) <= 32)} :=
   
   build_ex(let 'r := projT1 (uint b) in
   r).

Definition creg2reg_bits (creg : mword 3) 
: mword 5 :=
   
   concat_vec (vec_of_bits [B0;B1]  : mword 2) creg.

Definition zreg : regbits := (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5).
Hint Unfold zreg : sail.
Definition ra : regbits := (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5).
Hint Unfold ra : sail.
Definition sp : regbits := (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5).
Hint Unfold sp : sail.
Definition CapRegs : vec (register_ref regstate register_value Capability) 32 :=
vec_of_list_len [x31_ref;x30_ref;x29_ref;x28_ref;x27_ref;x26_ref;x25_ref;x24_ref;x23_ref;x22_ref;x21_ref;x20_ref;x19_ref;x18_ref;x17_ref;x16_ref;x15_ref;x14_ref;x13_ref;x12_ref;x11_ref;
                 x10_ref;x9_ref;x8_ref;x7_ref;x6_ref;x5_ref;x4_ref;x3_ref;x2_ref;x1_ref;DDC_ref].
Hint Unfold CapRegs : sail.
Definition readCapReg (n : Z) `{ArithFact (0 <= n /\ (n + 1) <= 32)} 
: M (Capability) :=
   
   (if sumbool_of_bool ((Z.eqb n 0)) then returnm (null_cap  : Capability)
    else (reg_deref (vec_access_dec CapRegs n))  : M (Capability))
    : M (Capability).

Definition rvfi_wX (r : Z) (v : mword 64) `{ArithFact (0 <= r /\ (r + 1) <= 32)}  : unit :=  tt.

Definition writeCapReg (n : Z) (cap : Capability) `{ArithFact (0 <= n /\ (n + 1) <= 32)} 
: M (unit) :=
   
   (if sumbool_of_bool ((projT1 (neq_int n 0))) then
      let '_ := (rvfi_wX n cap.(Capability_address))  : unit in
      write_reg (vec_access_dec CapRegs n) cap
       : M (unit)
    else returnm (tt  : unit))
    : M (unit).

Definition init_regs '(tt : unit) 
: M (unit) :=
   
   write_reg PCC_ref default_cap >>
   write_reg nextPCC_ref default_cap >>
   (let 'loop_i_lower := 1 in
   let 'loop_i_upper := 31 in
   (foreach_ZM_up loop_i_lower loop_i_upper 1 tt
     (fun i _ unit_var => write_reg (vec_access_dec CapRegs i) default_cap  : M (unit))))
    : M (unit).

Definition rX (r : Z) `{ArithFact (0 <= r /\ (r + 1) <= 32)} 
: M (mword 64) :=
   
   (readCapReg r) >>= fun cap_val => returnm (cap_val.(Capability_address)  : mword 64).

Definition wX (r : Z) (v : mword 64) `{ArithFact (0 <= r /\ (r + 1) <= 32)} 
: M (unit) :=
   
   (writeCapReg r {[ null_cap with Capability_address := v ]}) >>
   returnm ((if sumbool_of_bool ((projT1 (neq_int r 0))) then
               print_endline
                 (String.append "x"
                    (String.append (string_of_int r) (String.append " <- " (string_of_bits v))))
             else tt)
    : unit).

Definition reg_name_abi (r : mword 5) 
: string :=
   
   let b__0 := r in
   if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                          (projT1
                           (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))))) then
     "zero"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))))) then
     "ra"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5))))) then
     "sp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5))))) then
     "gp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))))) then
     "tp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5))))) then
     "t0"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5))))) then
     "t1"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5))))) then
     "t2"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))))) then
     "fp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5))))) then
     "s1"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5))))) then
     "a0"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5))))) then
     "a1"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))))) then
     "a2"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5))))) then
     "a3"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5))))) then
     "a4"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5))))) then
     "a5"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))))) then
     "a6"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5))))) then
     "a7"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5))))) then
     "s2"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5))))) then
     "s3"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))))) then
     "s4"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5))))) then
     "s5"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5))))) then
     "s6"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5))))) then
     "s7"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))))) then
     "s8"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5))))) then
     "s9"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5))))) then
     "s10"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5))))) then
     "s11"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))))) then
     "t3"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5))))) then
     "t4"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5))))) then
     "t5"
   else "t6".

Definition Architecture_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: Architecture :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RV32
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RV64
   else RV128.

Definition num_of_Architecture (arg_ : Architecture) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | RV32 => 0 | RV64 => 1 | RV128 => 2 end).

Definition architecture (a : mword 2) 
: option Architecture :=
   
   let b__0 := a in
   if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then Some (RV32)
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then Some (RV64)
   else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then Some (RV128)
   else None.

Definition arch_to_bits (a : Architecture) 
: mword 2 :=
   
   match a with
   | RV32 => (vec_of_bits [B0;B1]  : mword 2)
   | RV64 => (vec_of_bits [B1;B0]  : mword 2)
   | RV128 => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition Privilege_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: Privilege :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then User
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then Supervisor
   else Machine.

Definition num_of_Privilege (arg_ : Privilege) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | User => 0 | Supervisor => 1 | Machine => 2 end).

Definition privLevel_to_bits (p : Privilege) 
: mword 2 :=
   
   match p with
   | User => (vec_of_bits [B0;B0]  : mword 2)
   | Supervisor => (vec_of_bits [B0;B1]  : mword 2)
   | Machine => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition privLevel_of_bits (p : mword 2) 
: Privilege :=
   
   let b__0 := p in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then User
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then Supervisor
   else Machine.

Definition privLevel_to_str (p : Privilege) 
: string :=
   
   match p with | User => "U" | Supervisor => "S" | Machine => "M" end.

Definition AccessType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: AccessType :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then Read
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then Write
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then ReadWrite
   else Execute.

Definition num_of_AccessType (arg_ : AccessType) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | Read => 0 | Write => 1 | ReadWrite => 2 | Execute => 3 end).

Definition accessType_to_str (a : AccessType) 
: string :=
   
   match a with | Read => "R" | Write => "W" | ReadWrite => "RW" | Execute => "X" end.

Definition ReadType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 1)} 
: ReadType :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then Instruction
   else Data.

Definition num_of_ReadType (arg_ : ReadType) 
: {e : Z & ArithFact (0 <= e /\ e <= 1)} :=
   
   build_ex(match arg_ with | Instruction => 0 | Data => 1 end).

Definition readType_to_str (r : ReadType) 
: string :=
   
   match r with | Instruction => "I" | Data => "D" end.

Definition word_width_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: word_width :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then BYTE
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then HALF
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then WORD
   else DOUBLE.

Definition num_of_word_width (arg_ : word_width) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | BYTE => 0 | HALF => 1 | WORD => 2 | DOUBLE => 3 end).

Definition InterruptType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 8)} 
: InterruptType :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then I_U_Software
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then I_S_Software
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then I_M_Software
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then I_U_Timer
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then I_S_Timer
   else if sumbool_of_bool ((Z.eqb p0_ 5)) then I_M_Timer
   else if sumbool_of_bool ((Z.eqb p0_ 6)) then I_U_External
   else if sumbool_of_bool ((Z.eqb p0_ 7)) then I_S_External
   else I_M_External.

Definition num_of_InterruptType (arg_ : InterruptType) 
: {e : Z & ArithFact (0 <= e /\ e <= 8)} :=
   
   build_ex(match arg_ with
            | I_U_Software => 0
            | I_S_Software => 1
            | I_M_Software => 2
            | I_U_Timer => 3
            | I_S_Timer => 4
            | I_M_Timer => 5
            | I_U_External => 6
            | I_S_External => 7
            | I_M_External => 8
            end).

Definition interruptType_to_bits (i : InterruptType) 
: mword 8 :=
   
   match i with
   | I_U_Software => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8)
   | I_S_Software => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1]  : mword 8)
   | I_M_Software => (vec_of_bits [B0;B0;B0;B0;B0;B0;B1;B1]  : mword 8)
   | I_U_Timer => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0]  : mword 8)
   | I_S_Timer => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B1]  : mword 8)
   | I_M_Timer => (vec_of_bits [B0;B0;B0;B0;B0;B1;B1;B1]  : mword 8)
   | I_U_External => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B0]  : mword 8)
   | I_S_External => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B1]  : mword 8)
   | I_M_External => (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B1]  : mword 8)
   end.

Definition ExceptionType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 16)} 
: ExceptionType :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then E_Fetch_Addr_Align
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then E_Fetch_Access_Fault
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then E_Illegal_Instr
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then E_Breakpoint
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then E_Load_Addr_Align
   else if sumbool_of_bool ((Z.eqb p0_ 5)) then E_Load_Access_Fault
   else if sumbool_of_bool ((Z.eqb p0_ 6)) then E_SAMO_Addr_Align
   else if sumbool_of_bool ((Z.eqb p0_ 7)) then E_SAMO_Access_Fault
   else if sumbool_of_bool ((Z.eqb p0_ 8)) then E_U_EnvCall
   else if sumbool_of_bool ((Z.eqb p0_ 9)) then E_S_EnvCall
   else if sumbool_of_bool ((Z.eqb p0_ 10)) then E_Reserved_10
   else if sumbool_of_bool ((Z.eqb p0_ 11)) then E_M_EnvCall
   else if sumbool_of_bool ((Z.eqb p0_ 12)) then E_Fetch_Page_Fault
   else if sumbool_of_bool ((Z.eqb p0_ 13)) then E_Load_Page_Fault
   else if sumbool_of_bool ((Z.eqb p0_ 14)) then E_Reserved_14
   else if sumbool_of_bool ((Z.eqb p0_ 15)) then E_SAMO_Page_Fault
   else E_CHERI.

Definition num_of_ExceptionType (arg_ : ExceptionType) 
: {e : Z & ArithFact (0 <= e /\ e <= 16)} :=
   
   build_ex(match arg_ with
            | E_Fetch_Addr_Align => 0
            | E_Fetch_Access_Fault => 1
            | E_Illegal_Instr => 2
            | E_Breakpoint => 3
            | E_Load_Addr_Align => 4
            | E_Load_Access_Fault => 5
            | E_SAMO_Addr_Align => 6
            | E_SAMO_Access_Fault => 7
            | E_U_EnvCall => 8
            | E_S_EnvCall => 9
            | E_Reserved_10 => 10
            | E_M_EnvCall => 11
            | E_Fetch_Page_Fault => 12
            | E_Load_Page_Fault => 13
            | E_Reserved_14 => 14
            | E_SAMO_Page_Fault => 15
            | E_CHERI => 16
            end).

Definition exceptionType_to_bits (e : ExceptionType) 
: mword 8 :=
   
   match e with
   | E_Fetch_Addr_Align => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8)
   | E_Fetch_Access_Fault => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1]  : mword 8)
   | E_Illegal_Instr => (vec_of_bits [B0;B0;B0;B0;B0;B0;B1;B0]  : mword 8)
   | E_Breakpoint => (vec_of_bits [B0;B0;B0;B0;B0;B0;B1;B1]  : mword 8)
   | E_Load_Addr_Align => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0]  : mword 8)
   | E_Load_Access_Fault => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B1]  : mword 8)
   | E_SAMO_Addr_Align => (vec_of_bits [B0;B0;B0;B0;B0;B1;B1;B0]  : mword 8)
   | E_SAMO_Access_Fault => (vec_of_bits [B0;B0;B0;B0;B0;B1;B1;B1]  : mword 8)
   | E_U_EnvCall => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B0]  : mword 8)
   | E_S_EnvCall => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B1]  : mword 8)
   | E_Reserved_10 => (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B0]  : mword 8)
   | E_M_EnvCall => (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B1]  : mword 8)
   | E_Fetch_Page_Fault => (vec_of_bits [B0;B0;B0;B0;B1;B1;B0;B0]  : mword 8)
   | E_Load_Page_Fault => (vec_of_bits [B0;B0;B0;B0;B1;B1;B0;B1]  : mword 8)
   | E_Reserved_14 => (vec_of_bits [B0;B0;B0;B0;B1;B1;B1;B0]  : mword 8)
   | E_SAMO_Page_Fault => (vec_of_bits [B0;B0;B0;B0;B1;B1;B1;B1]  : mword 8)
   | E_CHERI => (vec_of_bits [B0;B0;B1;B0;B0;B0;B0;B0]  : mword 8)
   end.

Definition exceptionType_to_str (e : ExceptionType) 
: string :=
   
   match e with
   | E_Fetch_Addr_Align => "misaligned-fetch"
   | E_Fetch_Access_Fault => "fetch-access-fault"
   | E_Illegal_Instr => "illegal-instruction"
   | E_Breakpoint => "breakpoint"
   | E_Load_Addr_Align => "misaligned-load"
   | E_Load_Access_Fault => "load-access-fault"
   | E_SAMO_Addr_Align => "misaliged-store/amo"
   | E_SAMO_Access_Fault => "store/amo-access-fault"
   | E_U_EnvCall => "u-call"
   | E_S_EnvCall => "s-call"
   | E_Reserved_10 => "reserved-0"
   | E_M_EnvCall => "m-call"
   | E_Fetch_Page_Fault => "fetch-page-fault"
   | E_Load_Page_Fault => "load-page-fault"
   | E_Reserved_14 => "reserved-1"
   | E_SAMO_Page_Fault => "store/amo-page-fault"
   | E_CHERI => "CHERI"
   end.

Definition not_implemented {a : Type} (message : string) 
: M (a) :=
   
   throw (Error_not_implemented
            (message)).

Definition internal_error {a : Type} (s : string) 
: M (a) :=
   
   assert_exp' false s >>= fun _ => exit tt.

Definition TrapVectorMode_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: TrapVectorMode :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then TV_Direct
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then TV_Vector
   else TV_Reserved.

Definition num_of_TrapVectorMode (arg_ : TrapVectorMode) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | TV_Direct => 0 | TV_Vector => 1 | TV_Reserved => 2 end).

Definition trapVectorMode_of_bits (m : mword 2) 
: TrapVectorMode :=
   
   let b__0 := m in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then TV_Direct
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then TV_Vector
   else TV_Reserved.

Definition ExtStatus_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: ExtStatus :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then Off
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then Initial
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then Clean
   else Dirty.

Definition num_of_ExtStatus (arg_ : ExtStatus) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | Off => 0 | Initial => 1 | Clean => 2 | Dirty => 3 end).

Definition extStatus_to_bits (e : ExtStatus) 
: mword 2 :=
   
   match e with
   | Off => (vec_of_bits [B0;B0]  : mword 2)
   | Initial => (vec_of_bits [B0;B1]  : mword 2)
   | Clean => (vec_of_bits [B1;B0]  : mword 2)
   | Dirty => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition extStatus_of_bits (e : mword 2) 
: ExtStatus :=
   
   let b__0 := e in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then Off
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then Initial
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then Clean
   else Dirty.

Definition SATPMode_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: SATPMode :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then Sbare
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then Sv32
   else Sv39.

Definition num_of_SATPMode (arg_ : SATPMode) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | Sbare => 0 | Sv32 => 1 | Sv39 => 2 end).

Definition satpMode_of_bits (a : Architecture) (m : mword 4) 
: option SATPMode :=
   
   match (a, m) with
   | (g__4, b__0) =>
      if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0]  : mword 4))) then Some (Sbare)
      else
        match (g__4, b__0) with
        | (RV32, b__0) =>
           if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1]  : mword 4))) then Some (Sv32)
           else match (RV32, b__0) with | (g__5, g__6) => None end
        | (RV64, b__0) =>
           if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0]  : mword 4))) then Some (Sv39)
           else match (RV64, b__0) with | (g__5, g__6) => None end
        | (g__5, g__6) => None
        end
   end.

Definition uop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 1)} 
: uop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_LUI
   else RISCV_AUIPC.

Definition num_of_uop (arg_ : uop) 
: {e : Z & ArithFact (0 <= e /\ e <= 1)} :=
   
   build_ex(match arg_ with | RISCV_LUI => 0 | RISCV_AUIPC => 1 end).

Definition bop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 5)} 
: bop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_BEQ
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RISCV_BNE
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then RISCV_BLT
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then RISCV_BGE
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then RISCV_BLTU
   else RISCV_BGEU.

Definition num_of_bop (arg_ : bop) 
: {e : Z & ArithFact (0 <= e /\ e <= 5)} :=
   
   build_ex(match arg_ with
            | RISCV_BEQ => 0
            | RISCV_BNE => 1
            | RISCV_BLT => 2
            | RISCV_BGE => 3
            | RISCV_BLTU => 4
            | RISCV_BGEU => 5
            end).

Definition iop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 5)} 
: iop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_ADDI
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RISCV_SLTI
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then RISCV_SLTIU
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then RISCV_XORI
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then RISCV_ORI
   else RISCV_ANDI.

Definition num_of_iop (arg_ : iop) 
: {e : Z & ArithFact (0 <= e /\ e <= 5)} :=
   
   build_ex(match arg_ with
            | RISCV_ADDI => 0
            | RISCV_SLTI => 1
            | RISCV_SLTIU => 2
            | RISCV_XORI => 3
            | RISCV_ORI => 4
            | RISCV_ANDI => 5
            end).

Definition sop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: sop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_SLLI
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RISCV_SRLI
   else RISCV_SRAI.

Definition num_of_sop (arg_ : sop) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | RISCV_SLLI => 0 | RISCV_SRLI => 1 | RISCV_SRAI => 2 end).

Definition rop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 9)} 
: rop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_ADD
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RISCV_SUB
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then RISCV_SLL
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then RISCV_SLT
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then RISCV_SLTU
   else if sumbool_of_bool ((Z.eqb p0_ 5)) then RISCV_XOR
   else if sumbool_of_bool ((Z.eqb p0_ 6)) then RISCV_SRL
   else if sumbool_of_bool ((Z.eqb p0_ 7)) then RISCV_SRA
   else if sumbool_of_bool ((Z.eqb p0_ 8)) then RISCV_OR
   else RISCV_AND.

Definition num_of_rop (arg_ : rop) 
: {e : Z & ArithFact (0 <= e /\ e <= 9)} :=
   
   build_ex(match arg_ with
            | RISCV_ADD => 0
            | RISCV_SUB => 1
            | RISCV_SLL => 2
            | RISCV_SLT => 3
            | RISCV_SLTU => 4
            | RISCV_XOR => 5
            | RISCV_SRL => 6
            | RISCV_SRA => 7
            | RISCV_OR => 8
            | RISCV_AND => 9
            end).

Definition ropw_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 4)} 
: ropw :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_ADDW
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RISCV_SUBW
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then RISCV_SLLW
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then RISCV_SRLW
   else RISCV_SRAW.

Definition num_of_ropw (arg_ : ropw) 
: {e : Z & ArithFact (0 <= e /\ e <= 4)} :=
   
   build_ex(match arg_ with
            | RISCV_ADDW => 0
            | RISCV_SUBW => 1
            | RISCV_SLLW => 2
            | RISCV_SRLW => 3
            | RISCV_SRAW => 4
            end).

Definition sopw_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: sopw :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then RISCV_SLLIW
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then RISCV_SRLIW
   else RISCV_SRAIW.

Definition num_of_sopw (arg_ : sopw) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | RISCV_SLLIW => 0 | RISCV_SRLIW => 1 | RISCV_SRAIW => 2 end).

Definition amoop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 8)} 
: amoop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then AMOSWAP
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then AMOADD
   else if sumbool_of_bool ((Z.eqb p0_ 2)) then AMOXOR
   else if sumbool_of_bool ((Z.eqb p0_ 3)) then AMOAND
   else if sumbool_of_bool ((Z.eqb p0_ 4)) then AMOOR
   else if sumbool_of_bool ((Z.eqb p0_ 5)) then AMOMIN
   else if sumbool_of_bool ((Z.eqb p0_ 6)) then AMOMAX
   else if sumbool_of_bool ((Z.eqb p0_ 7)) then AMOMINU
   else AMOMAXU.

Definition num_of_amoop (arg_ : amoop) 
: {e : Z & ArithFact (0 <= e /\ e <= 8)} :=
   
   build_ex(match arg_ with
            | AMOSWAP => 0
            | AMOADD => 1
            | AMOXOR => 2
            | AMOAND => 3
            | AMOOR => 4
            | AMOMIN => 5
            | AMOMAX => 6
            | AMOMINU => 7
            | AMOMAXU => 8
            end).

Definition csrop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: csrop :=
   
   let p0_ := arg_ in
   if sumbool_of_bool ((Z.eqb p0_ 0)) then CSRRW
   else if sumbool_of_bool ((Z.eqb p0_ 1)) then CSRRS
   else CSRRC.

Definition num_of_csrop (arg_ : csrop) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | CSRRW => 0 | CSRRS => 1 | CSRRC => 2 end).

Definition reg_name_forwards (arg_ : mword 5) 
: string :=
   
   let b__0 := arg_ in
   if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                          (projT1
                           (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))))) then
     "zero"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))))) then
     "ra"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5))))) then
     "sp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5))))) then
     "gp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))))) then
     "tp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5))))) then
     "t0"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5))))) then
     "t1"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5))))) then
     "t2"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))))) then
     "fp"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5))))) then
     "s1"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5))))) then
     "a0"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5))))) then
     "a1"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))))) then
     "a2"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5))))) then
     "a3"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5))))) then
     "a4"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5))))) then
     "a5"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))))) then
     "a6"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5))))) then
     "a7"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5))))) then
     "s2"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5))))) then
     "s3"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))))) then
     "s4"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5))))) then
     "s5"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5))))) then
     "s6"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5))))) then
     "s7"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))))) then
     "s8"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5))))) then
     "s9"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5))))) then
     "s10"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5))))) then
     "s11"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))))) then
     "t3"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5))))) then
     "t4"
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5))))) then
     "t5"
   else "t6".

Definition reg_name_backwards (arg_ : string) 
: mword 5 :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "zero")) then (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "ra")) then (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "sp")) then (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "gp")) then (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "tp")) then (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "t0")) then (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "t1")) then (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "t2")) then (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "fp")) then (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "s1")) then (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "a0")) then (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "a1")) then (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "a2")) then (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "a3")) then (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "a4")) then (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "a5")) then (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "a6")) then (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "a7")) then (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "s2")) then (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "s3")) then (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "s4")) then (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "s5")) then (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "s6")) then (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "s7")) then (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "s8")) then (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "s9")) then (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "s10")) then (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5)
   else if ((generic_eq p0_ "s11")) then (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5)
   else if ((generic_eq p0_ "t3")) then (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5)
   else if ((generic_eq p0_ "t4")) then (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5)
   else if ((generic_eq p0_ "t5")) then (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5)
   else (vec_of_bits [B1;B1;B1;B1;B1]  : mword 5).

Definition reg_name_forwards_matches (arg_ : mword 5) 
: bool :=
   
   let b__0 := arg_ in
   if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                          (projT1
                           (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5))))) then
     true
   else if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                               (projT1
                                (regbits_to_regno (vec_of_bits [B1;B1;B1;B1;B1]  : mword 5))))) then
     true
   else false.

Definition reg_name_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "zero")) then true
   else if ((generic_eq p0_ "ra")) then true
   else if ((generic_eq p0_ "sp")) then true
   else if ((generic_eq p0_ "gp")) then true
   else if ((generic_eq p0_ "tp")) then true
   else if ((generic_eq p0_ "t0")) then true
   else if ((generic_eq p0_ "t1")) then true
   else if ((generic_eq p0_ "t2")) then true
   else if ((generic_eq p0_ "fp")) then true
   else if ((generic_eq p0_ "s1")) then true
   else if ((generic_eq p0_ "a0")) then true
   else if ((generic_eq p0_ "a1")) then true
   else if ((generic_eq p0_ "a2")) then true
   else if ((generic_eq p0_ "a3")) then true
   else if ((generic_eq p0_ "a4")) then true
   else if ((generic_eq p0_ "a5")) then true
   else if ((generic_eq p0_ "a6")) then true
   else if ((generic_eq p0_ "a7")) then true
   else if ((generic_eq p0_ "s2")) then true
   else if ((generic_eq p0_ "s3")) then true
   else if ((generic_eq p0_ "s4")) then true
   else if ((generic_eq p0_ "s5")) then true
   else if ((generic_eq p0_ "s6")) then true
   else if ((generic_eq p0_ "s7")) then true
   else if ((generic_eq p0_ "s8")) then true
   else if ((generic_eq p0_ "s9")) then true
   else if ((generic_eq p0_ "s10")) then true
   else if ((generic_eq p0_ "s11")) then true
   else if ((generic_eq p0_ "t3")) then true
   else if ((generic_eq p0_ "t4")) then true
   else if ((generic_eq p0_ "t5")) then true
   else if ((generic_eq p0_ "t6")) then true
   else false.

Definition _s124_ (_s125_ : string) 
: option string :=
   
   let _s126_ := _s125_ in
   if ((string_startswith _s126_ "t6")) then
     match (string_drop _s126_ (projT1 (string_length "t6"))) with | s_ => Some (s_) end
   else None.

Definition _s120_ (_s121_ : string) 
: option string :=
   
   let _s122_ := _s121_ in
   if ((string_startswith _s122_ "t5")) then
     match (string_drop _s122_ (projT1 (string_length "t5"))) with | s_ => Some (s_) end
   else None.

Definition _s116_ (_s117_ : string) 
: option string :=
   
   let _s118_ := _s117_ in
   if ((string_startswith _s118_ "t4")) then
     match (string_drop _s118_ (projT1 (string_length "t4"))) with | s_ => Some (s_) end
   else None.

Definition _s112_ (_s113_ : string) 
: option string :=
   
   let _s114_ := _s113_ in
   if ((string_startswith _s114_ "t3")) then
     match (string_drop _s114_ (projT1 (string_length "t3"))) with | s_ => Some (s_) end
   else None.

Definition _s108_ (_s109_ : string) 
: option string :=
   
   let _s110_ := _s109_ in
   if ((string_startswith _s110_ "s11")) then
     match (string_drop _s110_ (projT1 (string_length "s11"))) with | s_ => Some (s_) end
   else None.

Definition _s104_ (_s105_ : string) 
: option string :=
   
   let _s106_ := _s105_ in
   if ((string_startswith _s106_ "s10")) then
     match (string_drop _s106_ (projT1 (string_length "s10"))) with | s_ => Some (s_) end
   else None.

Definition _s100_ (_s101_ : string) 
: option string :=
   
   let _s102_ := _s101_ in
   if ((string_startswith _s102_ "s9")) then
     match (string_drop _s102_ (projT1 (string_length "s9"))) with | s_ => Some (s_) end
   else None.

Definition _s96_ (_s97_ : string) 
: option string :=
   
   let _s98_ := _s97_ in
   if ((string_startswith _s98_ "s8")) then
     match (string_drop _s98_ (projT1 (string_length "s8"))) with | s_ => Some (s_) end
   else None.

Definition _s92_ (_s93_ : string) 
: option string :=
   
   let _s94_ := _s93_ in
   if ((string_startswith _s94_ "s7")) then
     match (string_drop _s94_ (projT1 (string_length "s7"))) with | s_ => Some (s_) end
   else None.

Definition _s88_ (_s89_ : string) 
: option string :=
   
   let _s90_ := _s89_ in
   if ((string_startswith _s90_ "s6")) then
     match (string_drop _s90_ (projT1 (string_length "s6"))) with | s_ => Some (s_) end
   else None.

Definition _s84_ (_s85_ : string) 
: option string :=
   
   let _s86_ := _s85_ in
   if ((string_startswith _s86_ "s5")) then
     match (string_drop _s86_ (projT1 (string_length "s5"))) with | s_ => Some (s_) end
   else None.

Definition _s80_ (_s81_ : string) 
: option string :=
   
   let _s82_ := _s81_ in
   if ((string_startswith _s82_ "s4")) then
     match (string_drop _s82_ (projT1 (string_length "s4"))) with | s_ => Some (s_) end
   else None.

Definition _s76_ (_s77_ : string) 
: option string :=
   
   let _s78_ := _s77_ in
   if ((string_startswith _s78_ "s3")) then
     match (string_drop _s78_ (projT1 (string_length "s3"))) with | s_ => Some (s_) end
   else None.

Definition _s72_ (_s73_ : string) 
: option string :=
   
   let _s74_ := _s73_ in
   if ((string_startswith _s74_ "s2")) then
     match (string_drop _s74_ (projT1 (string_length "s2"))) with | s_ => Some (s_) end
   else None.

Definition _s68_ (_s69_ : string) 
: option string :=
   
   let _s70_ := _s69_ in
   if ((string_startswith _s70_ "a7")) then
     match (string_drop _s70_ (projT1 (string_length "a7"))) with | s_ => Some (s_) end
   else None.

Definition _s64_ (_s65_ : string) 
: option string :=
   
   let _s66_ := _s65_ in
   if ((string_startswith _s66_ "a6")) then
     match (string_drop _s66_ (projT1 (string_length "a6"))) with | s_ => Some (s_) end
   else None.

Definition _s60_ (_s61_ : string) 
: option string :=
   
   let _s62_ := _s61_ in
   if ((string_startswith _s62_ "a5")) then
     match (string_drop _s62_ (projT1 (string_length "a5"))) with | s_ => Some (s_) end
   else None.

Definition _s56_ (_s57_ : string) 
: option string :=
   
   let _s58_ := _s57_ in
   if ((string_startswith _s58_ "a4")) then
     match (string_drop _s58_ (projT1 (string_length "a4"))) with | s_ => Some (s_) end
   else None.

Definition _s52_ (_s53_ : string) 
: option string :=
   
   let _s54_ := _s53_ in
   if ((string_startswith _s54_ "a3")) then
     match (string_drop _s54_ (projT1 (string_length "a3"))) with | s_ => Some (s_) end
   else None.

Definition _s48_ (_s49_ : string) 
: option string :=
   
   let _s50_ := _s49_ in
   if ((string_startswith _s50_ "a2")) then
     match (string_drop _s50_ (projT1 (string_length "a2"))) with | s_ => Some (s_) end
   else None.

Definition _s44_ (_s45_ : string) 
: option string :=
   
   let _s46_ := _s45_ in
   if ((string_startswith _s46_ "a1")) then
     match (string_drop _s46_ (projT1 (string_length "a1"))) with | s_ => Some (s_) end
   else None.

Definition _s40_ (_s41_ : string) 
: option string :=
   
   let _s42_ := _s41_ in
   if ((string_startswith _s42_ "a0")) then
     match (string_drop _s42_ (projT1 (string_length "a0"))) with | s_ => Some (s_) end
   else None.

Definition _s36_ (_s37_ : string) 
: option string :=
   
   let _s38_ := _s37_ in
   if ((string_startswith _s38_ "s1")) then
     match (string_drop _s38_ (projT1 (string_length "s1"))) with | s_ => Some (s_) end
   else None.

Definition _s32_ (_s33_ : string) 
: option string :=
   
   let _s34_ := _s33_ in
   if ((string_startswith _s34_ "fp")) then
     match (string_drop _s34_ (projT1 (string_length "fp"))) with | s_ => Some (s_) end
   else None.

Definition _s28_ (_s29_ : string) 
: option string :=
   
   let _s30_ := _s29_ in
   if ((string_startswith _s30_ "t2")) then
     match (string_drop _s30_ (projT1 (string_length "t2"))) with | s_ => Some (s_) end
   else None.

Definition _s24_ (_s25_ : string) 
: option string :=
   
   let _s26_ := _s25_ in
   if ((string_startswith _s26_ "t1")) then
     match (string_drop _s26_ (projT1 (string_length "t1"))) with | s_ => Some (s_) end
   else None.

Definition _s20_ (_s21_ : string) 
: option string :=
   
   let _s22_ := _s21_ in
   if ((string_startswith _s22_ "t0")) then
     match (string_drop _s22_ (projT1 (string_length "t0"))) with | s_ => Some (s_) end
   else None.

Definition _s16_ (_s17_ : string) 
: option string :=
   
   let _s18_ := _s17_ in
   if ((string_startswith _s18_ "tp")) then
     match (string_drop _s18_ (projT1 (string_length "tp"))) with | s_ => Some (s_) end
   else None.

Definition _s12_ (_s13_ : string) 
: option string :=
   
   let _s14_ := _s13_ in
   if ((string_startswith _s14_ "gp")) then
     match (string_drop _s14_ (projT1 (string_length "gp"))) with | s_ => Some (s_) end
   else None.

Definition _s8_ (_s9_ : string) 
: option string :=
   
   let _s10_ := _s9_ in
   if ((string_startswith _s10_ "sp")) then
     match (string_drop _s10_ (projT1 (string_length "sp"))) with | s_ => Some (s_) end
   else None.

Definition _s4_ (_s5_ : string) 
: option string :=
   
   let _s6_ := _s5_ in
   if ((string_startswith _s6_ "ra")) then
     match (string_drop _s6_ (projT1 (string_length "ra"))) with | s_ => Some (s_) end
   else None.

Definition _s0_ (_s1_ : string) 
: option string :=
   
   let _s2_ := _s1_ in
   if ((string_startswith _s2_ "zero")) then
     match (string_drop _s2_ (projT1 (string_length "zero"))) with | s_ => Some (s_) end
   else None.

Definition reg_name_matches_prefix (arg_ : string) 
: M (option ((mword 5 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s3_ := arg_ in
   (if ((match (_s0_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s0_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s4_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s4_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s8_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s8_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s12_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s12_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s16_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s16_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s20_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s20_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s24_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s24_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s28_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s28_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s32_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s32_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s36_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s36_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s40_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s40_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s44_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s44_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s48_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s48_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s52_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s52_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s56_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s56_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s60_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s60_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s64_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s64_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s68_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s68_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s72_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s72_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s76_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s76_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s80_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s80_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s84_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s84_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s88_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s88_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s92_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s92_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s96_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s96_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s100_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s100_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s104_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s104_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s108_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s108_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s112_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s112_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s116_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s116_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s120_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s120_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s124_ _s3_) with | Some (s_) => true | _ => false end)) then
      (match (_s124_ _s3_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 5 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)}))).

Definition creg_name_forwards (arg_ : mword 3) 
: string :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then "s0"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then "s1"
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then "a0"
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then "a1"
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then "a2"
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then "a3"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then "a4"
   else "a5".

Definition creg_name_backwards (arg_ : string) 
: mword 3 :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "s0")) then (vec_of_bits [B0;B0;B0]  : mword 3)
   else if ((generic_eq p0_ "s1")) then (vec_of_bits [B0;B0;B1]  : mword 3)
   else if ((generic_eq p0_ "a0")) then (vec_of_bits [B0;B1;B0]  : mword 3)
   else if ((generic_eq p0_ "a1")) then (vec_of_bits [B0;B1;B1]  : mword 3)
   else if ((generic_eq p0_ "a2")) then (vec_of_bits [B1;B0;B0]  : mword 3)
   else if ((generic_eq p0_ "a3")) then (vec_of_bits [B1;B0;B1]  : mword 3)
   else if ((generic_eq p0_ "a4")) then (vec_of_bits [B1;B1;B0]  : mword 3)
   else (vec_of_bits [B1;B1;B1]  : mword 3).

Definition creg_name_forwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then true
   else false.

Definition creg_name_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "s0")) then true
   else if ((generic_eq p0_ "s1")) then true
   else if ((generic_eq p0_ "a0")) then true
   else if ((generic_eq p0_ "a1")) then true
   else if ((generic_eq p0_ "a2")) then true
   else if ((generic_eq p0_ "a3")) then true
   else if ((generic_eq p0_ "a4")) then true
   else if ((generic_eq p0_ "a5")) then true
   else false.

Definition _s156_ (_s157_ : string) 
: option string :=
   
   let _s158_ := _s157_ in
   if ((string_startswith _s158_ "a5")) then
     match (string_drop _s158_ (projT1 (string_length "a5"))) with | s_ => Some (s_) end
   else None.

Definition _s152_ (_s153_ : string) 
: option string :=
   
   let _s154_ := _s153_ in
   if ((string_startswith _s154_ "a4")) then
     match (string_drop _s154_ (projT1 (string_length "a4"))) with | s_ => Some (s_) end
   else None.

Definition _s148_ (_s149_ : string) 
: option string :=
   
   let _s150_ := _s149_ in
   if ((string_startswith _s150_ "a3")) then
     match (string_drop _s150_ (projT1 (string_length "a3"))) with | s_ => Some (s_) end
   else None.

Definition _s144_ (_s145_ : string) 
: option string :=
   
   let _s146_ := _s145_ in
   if ((string_startswith _s146_ "a2")) then
     match (string_drop _s146_ (projT1 (string_length "a2"))) with | s_ => Some (s_) end
   else None.

Definition _s140_ (_s141_ : string) 
: option string :=
   
   let _s142_ := _s141_ in
   if ((string_startswith _s142_ "a1")) then
     match (string_drop _s142_ (projT1 (string_length "a1"))) with | s_ => Some (s_) end
   else None.

Definition _s136_ (_s137_ : string) 
: option string :=
   
   let _s138_ := _s137_ in
   if ((string_startswith _s138_ "a0")) then
     match (string_drop _s138_ (projT1 (string_length "a0"))) with | s_ => Some (s_) end
   else None.

Definition _s132_ (_s133_ : string) 
: option string :=
   
   let _s134_ := _s133_ in
   if ((string_startswith _s134_ "s1")) then
     match (string_drop _s134_ (projT1 (string_length "s1"))) with | s_ => Some (s_) end
   else None.

Definition _s128_ (_s129_ : string) 
: option string :=
   
   let _s130_ := _s129_ in
   if ((string_startswith _s130_ "s0")) then
     match (string_drop _s130_ (projT1 (string_length "s0"))) with | s_ => Some (s_) end
   else None.

Definition creg_name_matches_prefix (arg_ : string) 
: M (option ((mword 3 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s131_ := arg_ in
   (if ((match (_s128_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s128_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s132_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s132_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s136_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s136_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s140_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s140_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s144_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s144_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s148_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s148_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s152_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s152_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s156_ _s131_) with | Some (s_) => true | _ => false end)) then
      (match (_s156_ _s131_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 3 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)}))).

Definition sep_forwards (arg_ : unit) 
: string :=
   
   match arg_ with
   | tt =>
      string_append (opt_spc_forwards tt)
        (string_append "," (string_append (def_spc_forwards tt) ""))
   end.

Definition _s160_ (_s161_ : string) 
: M (option unit) :=
   
   (match _s161_ with
    | _s162_ =>
       (opt_spc_matches_prefix _s162_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
       (match w__0 with
        | Some (tt,(existT _ _s163_ _)) =>
           let _s164_ := string_drop _s162_ _s163_ in
           (if ((string_startswith _s164_ ",")) then
              (match (string_drop _s164_ (projT1 (string_length ","))) with
               | _s165_ =>
                  (def_spc_matches_prefix _s165_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some (tt,(existT _ _s166_ _)) =>
                               let p0_ := string_drop _s165_ _s166_ in
                               if ((generic_eq p0_ "")) then Some (tt)
                               else None
                            | _ => None
                            end)
                   : option unit)
               end)
               : M (option unit)
            else returnm (None  : option unit))
            : M (option unit)
        | _ => returnm (None  : option unit)
        end)
        : M (option unit)
    end)
    : M (option unit).

Definition sep_backwards (arg_ : string) 
: M (unit) :=
   
   let _s167_ := arg_ in
   (_s160_ _s167_) >>= fun w__0 : option unit =>
   (match w__0 with | Some (tt) => returnm (tt  : unit) | _ => exit tt  : M (unit) end)
    : M (unit).

Definition sep_forwards_matches (arg_ : unit)  : bool :=  match arg_ with | tt => true end.

Definition _s168_ (_s169_ : string) 
: M (option unit) :=
   
   (match _s169_ with
    | _s170_ =>
       (opt_spc_matches_prefix _s170_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
       (match w__0 with
        | Some (tt,(existT _ _s171_ _)) =>
           let _s172_ := string_drop _s170_ _s171_ in
           (if ((string_startswith _s172_ ",")) then
              (match (string_drop _s172_ (projT1 (string_length ","))) with
               | _s173_ =>
                  (def_spc_matches_prefix _s173_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some (tt,(existT _ _s174_ _)) =>
                               let p0_ := string_drop _s173_ _s174_ in
                               if ((generic_eq p0_ "")) then Some (tt)
                               else None
                            | _ => None
                            end)
                   : option unit)
               end)
               : M (option unit)
            else returnm (None  : option unit))
            : M (option unit)
        | _ => returnm (None  : option unit)
        end)
        : M (option unit)
    end)
    : M (option unit).

Definition sep_backwards_matches (arg_ : string) 
: M (bool) :=
   
   let _s175_ := arg_ in
   (_s168_ _s175_) >>= fun w__0 : option unit =>
   (if ((match w__0 with | Some (tt) => true | _ => false end)) then
      (_s168_ _s175_) >>= fun w__1 : option unit =>
      (match w__1 with
       | Some (tt) => returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
       | _ => exit tt  : M (bool)
       end)
       : M (bool)
    else returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))})))
    : M (bool).

Definition _s176_ (_s177_ : string) 
: M (option string) :=
   
   (match _s177_ with
    | _s178_ =>
       (opt_spc_matches_prefix _s178_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
       (match w__0 with
        | Some (tt,(existT _ _s179_ _)) =>
           let _s180_ := string_drop _s178_ _s179_ in
           (if ((string_startswith _s180_ ",")) then
              (match (string_drop _s180_ (projT1 (string_length ","))) with
               | _s181_ =>
                  (def_spc_matches_prefix _s181_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some (tt,(existT _ _s182_ _)) =>
                               match (string_drop _s181_ _s182_) with | s_ => Some (s_) end
                            | _ => None
                            end)
                   : option string)
               end)
               : M (option string)
            else returnm (None  : option string))
            : M (option string)
        | _ => returnm (None  : option string)
        end)
        : M (option string)
    end)
    : M (option string).

Definition sep_matches_prefix (arg_ : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s183_ := arg_ in
   (_s176_ _s183_) >>= fun w__0 : option string =>
   (if ((match w__0 with | Some (s_) => true | _ => false end)) then
      (_s176_ _s183_) >>= fun w__1 : option string =>
      (match w__1 with
       | Some (s_) =>
          returnm ((Some
                      ((tt, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((unit * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((unit * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((unit * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((unit * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition bool_bits_forwards (arg_ : bool) 
: mword 1 :=
   
   match arg_ with
   | true => (vec_of_bits [B1]  : mword 1)
   | false => (vec_of_bits [B0]  : mword 1)
   end.

Definition bool_bits_backwards (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else false.

Definition bool_bits_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition bool_bits_backwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bool_not_bits_forwards (arg_ : bool) 
: mword 1 :=
   
   match arg_ with
   | true => (vec_of_bits [B0]  : mword 1)
   | false => (vec_of_bits [B1]  : mword 1)
   end.

Definition bool_not_bits_backwards (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bool_not_bits_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition bool_not_bits_backwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else false.

Definition size_bits_forwards (arg_ : word_width) 
: mword 2 :=
   
   match arg_ with
   | BYTE => (vec_of_bits [B0;B0]  : mword 2)
   | HALF => (vec_of_bits [B0;B1]  : mword 2)
   | WORD => (vec_of_bits [B1;B0]  : mword 2)
   | DOUBLE => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition size_bits_backwards (arg_ : mword 2) 
: word_width :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then BYTE
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then HALF
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then WORD
   else DOUBLE.

Definition size_bits_forwards_matches (arg_ : word_width) 
: bool :=
   
   match arg_ with | BYTE => true | HALF => true | WORD => true | DOUBLE => true end.

Definition size_bits_backwards_matches (arg_ : mword 2) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then true
   else false.

Definition word_width_bytes (width : word_width) 
: {s : Z & ArithFact (s = 1 \/ s = 2 \/ s = 4 \/ s = 8)} :=
   
   build_ex(match width with | BYTE => 1 | HALF => 2 | WORD => 4 | DOUBLE => 8 end).

Definition size_mnemonic_forwards (arg_ : word_width) 
: string :=
   
   match arg_ with | BYTE => "b" | HALF => "h" | WORD => "w" | DOUBLE => "d" end.

Definition size_mnemonic_backwards (arg_ : string) 
: word_width :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "b")) then BYTE
   else if ((generic_eq p0_ "h")) then HALF
   else if ((generic_eq p0_ "w")) then WORD
   else DOUBLE.

Definition size_mnemonic_forwards_matches (arg_ : word_width) 
: bool :=
   
   match arg_ with | BYTE => true | HALF => true | WORD => true | DOUBLE => true end.

Definition size_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "b")) then true
   else if ((generic_eq p0_ "h")) then true
   else if ((generic_eq p0_ "w")) then true
   else if ((generic_eq p0_ "d")) then true
   else false.

Definition _s196_ (_s197_ : string) 
: option string :=
   
   let _s198_ := _s197_ in
   if ((string_startswith _s198_ "d")) then
     match (string_drop _s198_ (projT1 (string_length "d"))) with | s_ => Some (s_) end
   else None.

Definition _s192_ (_s193_ : string) 
: option string :=
   
   let _s194_ := _s193_ in
   if ((string_startswith _s194_ "w")) then
     match (string_drop _s194_ (projT1 (string_length "w"))) with | s_ => Some (s_) end
   else None.

Definition _s188_ (_s189_ : string) 
: option string :=
   
   let _s190_ := _s189_ in
   if ((string_startswith _s190_ "h")) then
     match (string_drop _s190_ (projT1 (string_length "h"))) with | s_ => Some (s_) end
   else None.

Definition _s184_ (_s185_ : string) 
: option string :=
   
   let _s186_ := _s185_ in
   if ((string_startswith _s186_ "b")) then
     match (string_drop _s186_ (projT1 (string_length "b"))) with | s_ => Some (s_) end
   else None.

Definition size_mnemonic_matches_prefix (arg_ : string) 
: M (option ((word_width * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s187_ := arg_ in
   (if ((match (_s184_ _s187_) with | Some (s_) => true | _ => false end)) then
      (match (_s184_ _s187_) with
       | Some (s_) =>
          returnm ((Some
                      ((BYTE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s188_ _s187_) with | Some (s_) => true | _ => false end)) then
      (match (_s188_ _s187_) with
       | Some (s_) =>
          returnm ((Some
                      ((HALF, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s192_ _s187_) with | Some (s_) => true | _ => false end)) then
      (match (_s192_ _s187_) with
       | Some (s_) =>
          returnm ((Some
                      ((WORD, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s196_ _s187_) with | Some (s_) => true | _ => false end)) then
      (match (_s196_ _s187_) with
       | Some (s_) =>
          returnm ((Some
                      ((DOUBLE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((word_width * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((word_width * {n : Z & ArithFact (n >= 0)}))).

Definition haveRVC '(tt : unit)  : bool :=  false.

Definition handle_mem_exception (addr : mword 64) (e : ExceptionType) 
: M (unit) :=
   
   assert_exp' false "[[96mmodel/riscv_types.sail[0m]:588:88-89
588[96m |[0mfunction handle_mem_exception(addr : xlenbits, e : ExceptionType) -> unit = assert(false)
   [91m |[0m                                                                                        [91m^[0m
   [91m |[0m 
: false" >>= fun _ =>
   exit tt.

Axiom plat_ram_base : forall  (_ : unit) , mword 64.

Axiom plat_ram_size : forall  (_ : unit) , mword 64.

Axiom plat_enable_dirty_update : forall  (_ : unit) , bool.

Axiom plat_enable_misaligned_access : forall  (_ : unit) , bool.

Axiom plat_mtval_has_illegal_inst_bits : forall  (_ : unit) , bool.

Axiom plat_rom_base : forall  (_ : unit) , mword 64.

Axiom plat_rom_size : forall  (_ : unit) , mword 64.

Axiom plat_clint_base : forall  (_ : unit) , mword 64.

Axiom plat_clint_size : forall  (_ : unit) , mword 64.

Axiom plat_htif_tohost : forall  (_ : unit) , mword 64.

Definition phys_mem_segments '(tt : unit) 
: list ((mword 64 * mword 64)) :=
   
   (plat_rom_base tt, plat_rom_size tt) :: (plat_ram_base tt, plat_ram_size tt) :: [].

Definition handle_illegal '(tt : unit) 
: M (unit) :=
   
   assert_exp' false "[[96mmodel/riscv_platform.sail[0m]:52:14-15
52[96m |[0m  assert(false);
  [91m |[0m              [91m^[0m
  [91m |[0m 
: false" >>= fun _ =>
   exit tt.

Definition is_aligned_addr (addr : mword 64) (width : Z) 
: bool :=
   
   Z.eqb (projT1 (emod_with_eq (projT1 (uint addr)) width)) 0.

Definition phys_mem_read
(t : ReadType) (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (width >= 0)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (__RISCV_read addr width aq rl res) >>= fun w__0 : option (mword (8 * width)) =>
   returnm ((match (t, w__0) with
             | (Instruction, None) => MemException (E_Fetch_Access_Fault)
             | (Data, None) => MemException (E_Load_Access_Fault)
             | (_, Some (v)) =>
                let '_ :=
                  (print_endline
                     (String.append "mem["
                        (String.append ((readType_to_str t)  : string)
                           (String.append ","
                              (String.append (string_of_bits addr)
                                 (String.append "] -> " (string_of_bits v)))))))
                   : unit in
                MemValue
                  (v)
             end)
    : MemoryOpResult (mword (8 * width))).

Definition checked_mem_read
(t : ReadType) (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (phys_mem_read t addr width aq rl res)
    : M (MemoryOpResult (mword (8 * width))).

Definition MEMr (addr : mword 64) (width : Z) `{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (checked_mem_read Data addr width false false false)
    : M (MemoryOpResult (mword (8 * width))).

Definition MEMr_acquire (addr : mword 64) (width : Z) `{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (checked_mem_read Data addr width true false false)
    : M (MemoryOpResult (mword (8 * width))).

Definition MEMr_strong_acquire (addr : mword 64) (width : Z) `{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (checked_mem_read Data addr width true true false)
    : M (MemoryOpResult (mword (8 * width))).

Definition MEMr_reserved (addr : mword 64) (width : Z) `{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (checked_mem_read Data addr width false false true)
    : M (MemoryOpResult (mword (8 * width))).

Definition MEMr_reserved_acquire (addr : mword 64) (width : Z) `{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (checked_mem_read Data addr width true false true)
    : M (MemoryOpResult (mword (8 * width))).

Definition MEMr_reserved_strong_acquire (addr : mword 64) (width : Z)
`{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (checked_mem_read Data addr width true true true)
    : M (MemoryOpResult (mword (8 * width))).

Definition rvfi_read (addr : mword 64) (width : Z) (value : MemoryOpResult (mword (8 * width)))
`{ArithFact (width >= (0 + 1))} 
: unit :=
   
   tt.

Definition mem_read (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (width >= (0 + 1))} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (if sumbool_of_bool ((andb (orb aq res) (negb (is_aligned_addr addr width)))) then
      returnm ((MemException
                  (E_Load_Addr_Align))
       : MemoryOpResult (mword (8 * width)))
    else
      (match (aq, rl, res) with
       | (false, false, false) =>
          (checked_mem_read Data addr width false false false)
           : M (MemoryOpResult (mword (8 * width)))
       | (true, false, false) => (MEMr_acquire addr width)  : M (MemoryOpResult (mword (8 * width)))
       | (false, false, true) =>
          (MEMr_reserved addr width)  : M (MemoryOpResult (mword (8 * width)))
       | (true, false, true) =>
          (MEMr_reserved_acquire addr width)  : M (MemoryOpResult (mword (8 * width)))
       | (false, true, false) => throw (Error_not_implemented ("load.rl"))
       | (true, true, false) =>
          (MEMr_strong_acquire addr width)  : M (MemoryOpResult (mword (8 * width)))
       | (false, true, true) => throw (Error_not_implemented ("lr.rl"))
       | (true, true, true) =>
          (MEMr_reserved_strong_acquire addr width)  : M (MemoryOpResult (mword (8 * width)))
       end)
       : M (MemoryOpResult (mword (8 * width)))) >>= fun result : MemoryOpResult (bits (8 * width)) =>
   let '_ := (rvfi_read addr width result)  : unit in
   returnm (result
    : MemoryOpResult (mword (8 * width))).

Definition mem_read_cap (addr : mword 64) (aq : bool) (rl : bool) (res : bool) 
: M (MemoryOpResult Capability) :=
   
   (if ((negb (is_aligned_addr addr cap_size))) then
      returnm ((MemException
                  (E_Load_Addr_Align))
       : MemoryOpResult (mword (8 * cap_size)))
    else
      (match (aq, rl, res) with
       | (false, false, false) =>
          (checked_mem_read Data addr _ false false false)
           : M (MemoryOpResult (mword (8 * cap_size)))
       | (true, false, false) => (MEMr_acquire addr _)  : M (MemoryOpResult (mword (8 * cap_size)))
       | (false, false, true) => (MEMr_reserved addr _)  : M (MemoryOpResult (mword (8 * cap_size)))
       | (true, false, true) =>
          (MEMr_reserved_acquire addr _)  : M (MemoryOpResult (mword (8 * cap_size)))
       | (false, true, false) => throw (Error_not_implemented ("load.rl"))
       | (true, true, false) =>
          (MEMr_strong_acquire addr _)  : M (MemoryOpResult (mword (8 * cap_size)))
       | (false, true, true) => throw (Error_not_implemented ("lr.rl"))
       | (true, true, true) =>
          (MEMr_reserved_strong_acquire addr _)  : M (MemoryOpResult (mword (8 * cap_size)))
       end)
       : M (MemoryOpResult (mword (8 * cap_size)))) >>= fun result : MemoryOpResult (bits (8 * cap_size)) =>
   (read_tag_bool addr) >>= fun tag =>
   (match result with
    | MemValue (v) =>
       (memBitsToCapability tag (autocast v)) >>= fun w__9 : Capability =>
       returnm ((MemValue
                   (w__9))
        : MemoryOpResult Capability)
    | MemException (e) => returnm ((MemException (e))  : MemoryOpResult Capability)
    end)
    : M (MemoryOpResult Capability).

Definition mem_write_ea (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (con : bool) 
: M (MemoryOpResult unit) :=
   
   (if sumbool_of_bool ((andb (orb rl con) (negb (is_aligned_addr addr width)))) then
      returnm ((MemException
                  (E_SAMO_Addr_Align))
       : MemoryOpResult unit)
    else
      (match (aq, rl, con) with
       | (false, false, false) =>
          (MEMea addr width) >> returnm ((MemValue (tt))  : MemoryOpResult unit)
       | (false, true, false) =>
          (MEMea_release addr width) >> returnm ((MemValue (tt))  : MemoryOpResult unit)
       | (false, false, true) =>
          (MEMea_conditional addr width) >> returnm ((MemValue (tt))  : MemoryOpResult unit)
       | (false, true, true) =>
          (MEMea_conditional_release addr width) >> returnm ((MemValue (tt))  : MemoryOpResult unit)
       | (true, false, false) => throw (Error_not_implemented ("store.aq"))
       | (true, true, false) =>
          (MEMea_strong_release addr width) >> returnm ((MemValue (tt))  : MemoryOpResult unit)
       | (true, false, true) => throw (Error_not_implemented ("sc.aq"))
       | (true, true, true) =>
          (MEMea_conditional_strong_release addr width) >>
          returnm ((MemValue
                      (tt))
           : MemoryOpResult unit)
       end)
       : M (MemoryOpResult unit))
    : M (MemoryOpResult unit).

Definition mem_write_ea_cap (addr : mword 64) (aq : bool) (rl : bool) (con : bool) 
: M (MemoryOpResult unit) :=
   
   (if ((negb (is_aligned_addr addr cap_size))) then
      returnm ((MemException
                  (E_SAMO_Addr_Align))
       : MemoryOpResult unit)
    else (MEMea addr cap_size) >> returnm ((MemValue (tt))  : MemoryOpResult unit))
    : M (MemoryOpResult unit).

Definition tag_align_addr (addr : mword 64) 
: mword 64 :=
   
   update_subrange_vec_dec addr 3 0 (vec_of_bits [B0;B0;B0;B0]  : mword (3 - (0 - 1))).

Definition phys_mem_write (addr : mword 64) (width : Z) (tag : bool) (data : mword (8 * width))
`{ArithFact (width <= cap_size)} 
: M (MemoryOpResult bool) :=
   
   let '_ :=
     (print_endline
        (String.append "mem["
           (String.append (string_of_bits addr) (String.append "] <- " (string_of_bits data)))))
      : unit in
   let tag_addr := tag_align_addr addr in
   let '_ :=
     (print_endline
        (String.append "tag["
           (String.append (string_of_bits tag_addr)
              (String.append "] <- " (if sumbool_of_bool (tag) then "1" else "0")))))
      : unit in
   (write_tag_bool tag_addr tag) >>
   let tag_addr2 := tag_align_addr (sub_vec_int (add_vec_int addr width) 1) in
   (if ((neq_vec tag_addr tag_addr2)) then
      let '_ :=
        (print_endline
           (String.append "tag["
              (String.append (string_of_bits tag_addr2)
                 (String.append "] <- " (if sumbool_of_bool (tag) then "1" else "0")))))
         : unit in
      (write_tag_bool tag_addr2 tag)
       : M (unit)
    else returnm (tt  : unit)) >>
   (__RISCV_write addr width data) >>= fun w__0 : bool =>
   returnm ((MemValue
               (w__0))
    : MemoryOpResult bool).

Definition checked_mem_write (addr : mword 64) (width : Z) (tag : bool) (data : mword (8 * width))
`{ArithFact (width >= (0 + 1) /\ width <= cap_size)} 
: M (MemoryOpResult bool) :=
   
   (phys_mem_write addr width tag data)
    : M (MemoryOpResult bool).

Definition rvfi_write (addr : mword 64) (width : Z) (value : mword (8 * width))
`{ArithFact (width >= (0 + 1))} 
: unit :=
   
   tt.

Definition mem_write_value
(addr : mword 64) (width : Z) (value : mword (8 * width)) (aq : bool) (rl : bool) (con : bool)
`{ArithFact (width >= (0 + 1) /\ width <= cap_size)} 
: M (MemoryOpResult bool) :=
   
   let '_ := (rvfi_write addr width value)  : unit in
   (if sumbool_of_bool ((andb (orb rl con) (negb (is_aligned_addr addr width)))) then
      returnm ((MemException
                  (E_SAMO_Addr_Align))
       : MemoryOpResult bool)
    else
      (match (aq, rl, con) with
       | (false, false, false) =>
          (checked_mem_write addr width false value)  : M (MemoryOpResult bool)
       | (false, true, false) =>
          (checked_mem_write addr width false value)  : M (MemoryOpResult bool)
       | (false, false, true) =>
          (checked_mem_write addr width false value)  : M (MemoryOpResult bool)
       | (false, true, true) =>
          (checked_mem_write addr width false value)  : M (MemoryOpResult bool)
       | (true, false, false) => throw (Error_not_implemented ("store.aq"))
       | (true, true, false) =>
          (checked_mem_write addr width false value)  : M (MemoryOpResult bool)
       | (true, false, true) => throw (Error_not_implemented ("sc.aq"))
       | (true, true, true) => (checked_mem_write addr width false value)  : M (MemoryOpResult bool)
       end)
       : M (MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition mem_write_cap (addr : mword 64) (cap : Capability) (aq : bool) (rl : bool) (con : bool) 
: M (MemoryOpResult bool) :=
   
   let cap_bits := capToMemBits cap in
   let '_ := (rvfi_write addr cap_size cap_bits)  : unit in
   (if ((negb (is_aligned_addr addr cap_size))) then
      returnm ((MemException
                  (E_SAMO_Addr_Align))
       : MemoryOpResult bool)
    else (checked_mem_write addr cap_size cap.(Capability_tag) cap_bits)  : M (MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition encdec_uop_forwards (arg_ : uop) 
: mword 7 :=
   
   match arg_ with
   | RISCV_LUI => (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  : mword 7)
   | RISCV_AUIPC => (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  : mword 7)
   end.

Definition encdec_uop_backwards (arg_ : mword 7) 
: uop :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  : mword 7))) then RISCV_LUI
   else RISCV_AUIPC.

Definition encdec_uop_forwards_matches (arg_ : uop) 
: bool :=
   
   match arg_ with | RISCV_LUI => true | RISCV_AUIPC => true end.

Definition encdec_uop_backwards_matches (arg_ : mword 7) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  : mword 7))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  : mword 7))) then true
   else false.

Definition utype_mnemonic_forwards (arg_ : uop) 
: string :=
   
   match arg_ with | RISCV_LUI => "lui" | RISCV_AUIPC => "auipc" end.

Definition utype_mnemonic_backwards (arg_ : string) 
: uop :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "lui")) then RISCV_LUI
   else RISCV_AUIPC.

Definition utype_mnemonic_forwards_matches (arg_ : uop) 
: bool :=
   
   match arg_ with | RISCV_LUI => true | RISCV_AUIPC => true end.

Definition utype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "lui")) then true
   else if ((generic_eq p0_ "auipc")) then true
   else false.

Definition _s204_ (_s205_ : string) 
: option string :=
   
   let _s206_ := _s205_ in
   if ((string_startswith _s206_ "auipc")) then
     match (string_drop _s206_ (projT1 (string_length "auipc"))) with | s_ => Some (s_) end
   else None.

Definition _s200_ (_s201_ : string) 
: option string :=
   
   let _s202_ := _s201_ in
   if ((string_startswith _s202_ "lui")) then
     match (string_drop _s202_ (projT1 (string_length "lui"))) with | s_ => Some (s_) end
   else None.

Definition utype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((uop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s203_ := arg_ in
   (if ((match (_s200_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s200_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_LUI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((uop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s204_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s204_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_AUIPC, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((uop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((uop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((uop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_bop_forwards (arg_ : bop) 
: mword 3 :=
   
   match arg_ with
   | RISCV_BEQ => (vec_of_bits [B0;B0;B0]  : mword 3)
   | RISCV_BNE => (vec_of_bits [B0;B0;B1]  : mword 3)
   | RISCV_BLT => (vec_of_bits [B1;B0;B0]  : mword 3)
   | RISCV_BGE => (vec_of_bits [B1;B0;B1]  : mword 3)
   | RISCV_BLTU => (vec_of_bits [B1;B1;B0]  : mword 3)
   | RISCV_BGEU => (vec_of_bits [B1;B1;B1]  : mword 3)
   end.

Definition encdec_bop_backwards (arg_ : mword 3) 
: bop :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then RISCV_BEQ
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then RISCV_BNE
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then RISCV_BLT
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then RISCV_BGE
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then RISCV_BLTU
   else RISCV_BGEU.

Definition encdec_bop_forwards_matches (arg_ : bop) 
: bool :=
   
   match arg_ with
   | RISCV_BEQ => true
   | RISCV_BNE => true
   | RISCV_BLT => true
   | RISCV_BGE => true
   | RISCV_BLTU => true
   | RISCV_BGEU => true
   end.

Definition encdec_bop_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then true
   else false.

Definition btype_mnemonic_forwards (arg_ : bop) 
: string :=
   
   match arg_ with
   | RISCV_BEQ => "beq"
   | RISCV_BNE => "bne"
   | RISCV_BLT => "blt"
   | RISCV_BGE => "bge"
   | RISCV_BLTU => "bltu"
   | RISCV_BGEU => "bgeu"
   end.

Definition btype_mnemonic_backwards (arg_ : string) 
: bop :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "beq")) then RISCV_BEQ
   else if ((generic_eq p0_ "bne")) then RISCV_BNE
   else if ((generic_eq p0_ "blt")) then RISCV_BLT
   else if ((generic_eq p0_ "bge")) then RISCV_BGE
   else if ((generic_eq p0_ "bltu")) then RISCV_BLTU
   else RISCV_BGEU.

Definition btype_mnemonic_forwards_matches (arg_ : bop) 
: bool :=
   
   match arg_ with
   | RISCV_BEQ => true
   | RISCV_BNE => true
   | RISCV_BLT => true
   | RISCV_BGE => true
   | RISCV_BLTU => true
   | RISCV_BGEU => true
   end.

Definition btype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "beq")) then true
   else if ((generic_eq p0_ "bne")) then true
   else if ((generic_eq p0_ "blt")) then true
   else if ((generic_eq p0_ "bge")) then true
   else if ((generic_eq p0_ "bltu")) then true
   else if ((generic_eq p0_ "bgeu")) then true
   else false.

Definition _s228_ (_s229_ : string) 
: option string :=
   
   let _s230_ := _s229_ in
   if ((string_startswith _s230_ "bgeu")) then
     match (string_drop _s230_ (projT1 (string_length "bgeu"))) with | s_ => Some (s_) end
   else None.

Definition _s224_ (_s225_ : string) 
: option string :=
   
   let _s226_ := _s225_ in
   if ((string_startswith _s226_ "bltu")) then
     match (string_drop _s226_ (projT1 (string_length "bltu"))) with | s_ => Some (s_) end
   else None.

Definition _s220_ (_s221_ : string) 
: option string :=
   
   let _s222_ := _s221_ in
   if ((string_startswith _s222_ "bge")) then
     match (string_drop _s222_ (projT1 (string_length "bge"))) with | s_ => Some (s_) end
   else None.

Definition _s216_ (_s217_ : string) 
: option string :=
   
   let _s218_ := _s217_ in
   if ((string_startswith _s218_ "blt")) then
     match (string_drop _s218_ (projT1 (string_length "blt"))) with | s_ => Some (s_) end
   else None.

Definition _s212_ (_s213_ : string) 
: option string :=
   
   let _s214_ := _s213_ in
   if ((string_startswith _s214_ "bne")) then
     match (string_drop _s214_ (projT1 (string_length "bne"))) with | s_ => Some (s_) end
   else None.

Definition _s208_ (_s209_ : string) 
: option string :=
   
   let _s210_ := _s209_ in
   if ((string_startswith _s210_ "beq")) then
     match (string_drop _s210_ (projT1 (string_length "beq"))) with | s_ => Some (s_) end
   else None.

Definition btype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((bop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s211_ := arg_ in
   (if ((match (_s208_ _s211_) with | Some (s_) => true | _ => false end)) then
      (match (_s208_ _s211_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BEQ, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s212_ _s211_) with | Some (s_) => true | _ => false end)) then
      (match (_s212_ _s211_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BNE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s216_ _s211_) with | Some (s_) => true | _ => false end)) then
      (match (_s216_ _s211_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BLT, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s220_ _s211_) with | Some (s_) => true | _ => false end)) then
      (match (_s220_ _s211_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BGE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s224_ _s211_) with | Some (s_) => true | _ => false end)) then
      (match (_s224_ _s211_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BLTU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s228_ _s211_) with | Some (s_) => true | _ => false end)) then
      (match (_s228_ _s211_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BGEU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_iop_forwards (arg_ : iop) 
: mword 3 :=
   
   match arg_ with
   | RISCV_ADDI => (vec_of_bits [B0;B0;B0]  : mword 3)
   | RISCV_SLTI => (vec_of_bits [B0;B1;B0]  : mword 3)
   | RISCV_SLTIU => (vec_of_bits [B0;B1;B1]  : mword 3)
   | RISCV_ANDI => (vec_of_bits [B1;B1;B1]  : mword 3)
   | RISCV_ORI => (vec_of_bits [B1;B1;B0]  : mword 3)
   | RISCV_XORI => (vec_of_bits [B1;B0;B0]  : mword 3)
   end.

Definition encdec_iop_backwards (arg_ : mword 3) 
: iop :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then RISCV_ADDI
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then RISCV_SLTI
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then RISCV_SLTIU
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then RISCV_ANDI
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then RISCV_ORI
   else RISCV_XORI.

Definition encdec_iop_forwards_matches (arg_ : iop) 
: bool :=
   
   match arg_ with
   | RISCV_ADDI => true
   | RISCV_SLTI => true
   | RISCV_SLTIU => true
   | RISCV_ANDI => true
   | RISCV_ORI => true
   | RISCV_XORI => true
   end.

Definition encdec_iop_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then true
   else false.

Definition itype_mnemonic_forwards (arg_ : iop) 
: string :=
   
   match arg_ with
   | RISCV_ADDI => "addi"
   | RISCV_SLTI => "slti"
   | RISCV_SLTIU => "sltiu"
   | RISCV_XORI => "xori"
   | RISCV_ORI => "ori"
   | RISCV_ANDI => "andi"
   end.

Definition itype_mnemonic_backwards (arg_ : string) 
: iop :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "addi")) then RISCV_ADDI
   else if ((generic_eq p0_ "slti")) then RISCV_SLTI
   else if ((generic_eq p0_ "sltiu")) then RISCV_SLTIU
   else if ((generic_eq p0_ "xori")) then RISCV_XORI
   else if ((generic_eq p0_ "ori")) then RISCV_ORI
   else RISCV_ANDI.

Definition itype_mnemonic_forwards_matches (arg_ : iop) 
: bool :=
   
   match arg_ with
   | RISCV_ADDI => true
   | RISCV_SLTI => true
   | RISCV_SLTIU => true
   | RISCV_XORI => true
   | RISCV_ORI => true
   | RISCV_ANDI => true
   end.

Definition itype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "addi")) then true
   else if ((generic_eq p0_ "slti")) then true
   else if ((generic_eq p0_ "sltiu")) then true
   else if ((generic_eq p0_ "xori")) then true
   else if ((generic_eq p0_ "ori")) then true
   else if ((generic_eq p0_ "andi")) then true
   else false.

Definition _s252_ (_s253_ : string) 
: option string :=
   
   let _s254_ := _s253_ in
   if ((string_startswith _s254_ "andi")) then
     match (string_drop _s254_ (projT1 (string_length "andi"))) with | s_ => Some (s_) end
   else None.

Definition _s248_ (_s249_ : string) 
: option string :=
   
   let _s250_ := _s249_ in
   if ((string_startswith _s250_ "ori")) then
     match (string_drop _s250_ (projT1 (string_length "ori"))) with | s_ => Some (s_) end
   else None.

Definition _s244_ (_s245_ : string) 
: option string :=
   
   let _s246_ := _s245_ in
   if ((string_startswith _s246_ "xori")) then
     match (string_drop _s246_ (projT1 (string_length "xori"))) with | s_ => Some (s_) end
   else None.

Definition _s240_ (_s241_ : string) 
: option string :=
   
   let _s242_ := _s241_ in
   if ((string_startswith _s242_ "sltiu")) then
     match (string_drop _s242_ (projT1 (string_length "sltiu"))) with | s_ => Some (s_) end
   else None.

Definition _s236_ (_s237_ : string) 
: option string :=
   
   let _s238_ := _s237_ in
   if ((string_startswith _s238_ "slti")) then
     match (string_drop _s238_ (projT1 (string_length "slti"))) with | s_ => Some (s_) end
   else None.

Definition _s232_ (_s233_ : string) 
: option string :=
   
   let _s234_ := _s233_ in
   if ((string_startswith _s234_ "addi")) then
     match (string_drop _s234_ (projT1 (string_length "addi"))) with | s_ => Some (s_) end
   else None.

Definition itype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((iop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s235_ := arg_ in
   (if ((match (_s232_ _s235_) with | Some (s_) => true | _ => false end)) then
      (match (_s232_ _s235_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ADDI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s236_ _s235_) with | Some (s_) => true | _ => false end)) then
      (match (_s236_ _s235_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLTI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s240_ _s235_) with | Some (s_) => true | _ => false end)) then
      (match (_s240_ _s235_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLTIU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s244_ _s235_) with | Some (s_) => true | _ => false end)) then
      (match (_s244_ _s235_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_XORI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s248_ _s235_) with | Some (s_) => true | _ => false end)) then
      (match (_s248_ _s235_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ORI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s252_ _s235_) with | Some (s_) => true | _ => false end)) then
      (match (_s252_ _s235_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ANDI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((iop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((iop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_sop_forwards (arg_ : sop) 
: mword 3 :=
   
   match arg_ with
   | RISCV_SLLI => (vec_of_bits [B0;B0;B1]  : mword 3)
   | RISCV_SRLI => (vec_of_bits [B1;B0;B1]  : mword 3)
   | RISCV_SRAI => (vec_of_bits [B1;B0;B1]  : mword 3)
   end.

Definition encdec_sop_backwards (arg_ : mword 3) 
: sop :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then RISCV_SLLI
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then RISCV_SRLI
   else RISCV_SRAI.

Definition encdec_sop_forwards_matches (arg_ : sop) 
: bool :=
   
   match arg_ with | RISCV_SLLI => true | RISCV_SRLI => true | RISCV_SRAI => true end.

Definition encdec_sop_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else false.

Definition shiftiop_mnemonic_forwards (arg_ : sop) 
: string :=
   
   match arg_ with | RISCV_SLLI => "slli" | RISCV_SRLI => "srli" | RISCV_SRAI => "srai" end.

Definition shiftiop_mnemonic_backwards (arg_ : string) 
: sop :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slli")) then RISCV_SLLI
   else if ((generic_eq p0_ "srli")) then RISCV_SRLI
   else RISCV_SRAI.

Definition shiftiop_mnemonic_forwards_matches (arg_ : sop) 
: bool :=
   
   match arg_ with | RISCV_SLLI => true | RISCV_SRLI => true | RISCV_SRAI => true end.

Definition shiftiop_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slli")) then true
   else if ((generic_eq p0_ "srli")) then true
   else if ((generic_eq p0_ "srai")) then true
   else false.

Definition _s264_ (_s265_ : string) 
: option string :=
   
   let _s266_ := _s265_ in
   if ((string_startswith _s266_ "srai")) then
     match (string_drop _s266_ (projT1 (string_length "srai"))) with | s_ => Some (s_) end
   else None.

Definition _s260_ (_s261_ : string) 
: option string :=
   
   let _s262_ := _s261_ in
   if ((string_startswith _s262_ "srli")) then
     match (string_drop _s262_ (projT1 (string_length "srli"))) with | s_ => Some (s_) end
   else None.

Definition _s256_ (_s257_ : string) 
: option string :=
   
   let _s258_ := _s257_ in
   if ((string_startswith _s258_ "slli")) then
     match (string_drop _s258_ (projT1 (string_length "slli"))) with | s_ => Some (s_) end
   else None.

Definition shiftiop_mnemonic_matches_prefix (arg_ : string) 
: M (option ((sop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s259_ := arg_ in
   (if ((match (_s256_ _s259_) with | Some (s_) => true | _ => false end)) then
      (match (_s256_ _s259_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s260_ _s259_) with | Some (s_) => true | _ => false end)) then
      (match (_s260_ _s259_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s264_ _s259_) with | Some (s_) => true | _ => false end)) then
      (match (_s264_ _s259_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((sop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((sop * {n : Z & ArithFact (n >= 0)}))).

Definition rtype_mnemonic_forwards (arg_ : rop) 
: string :=
   
   match arg_ with
   | RISCV_ADD => "add"
   | RISCV_SLT => "slt"
   | RISCV_SLTU => "sltu"
   | RISCV_AND => "and"
   | RISCV_OR => "or"
   | RISCV_XOR => "xor"
   | RISCV_SLL => "sll"
   | RISCV_SRL => "srl"
   | RISCV_SUB => "sub"
   | RISCV_SRA => "sra"
   end.

Definition rtype_mnemonic_backwards (arg_ : string) 
: rop :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "add")) then RISCV_ADD
   else if ((generic_eq p0_ "slt")) then RISCV_SLT
   else if ((generic_eq p0_ "sltu")) then RISCV_SLTU
   else if ((generic_eq p0_ "and")) then RISCV_AND
   else if ((generic_eq p0_ "or")) then RISCV_OR
   else if ((generic_eq p0_ "xor")) then RISCV_XOR
   else if ((generic_eq p0_ "sll")) then RISCV_SLL
   else if ((generic_eq p0_ "srl")) then RISCV_SRL
   else if ((generic_eq p0_ "sub")) then RISCV_SUB
   else RISCV_SRA.

Definition rtype_mnemonic_forwards_matches (arg_ : rop) 
: bool :=
   
   match arg_ with
   | RISCV_ADD => true
   | RISCV_SLT => true
   | RISCV_SLTU => true
   | RISCV_AND => true
   | RISCV_OR => true
   | RISCV_XOR => true
   | RISCV_SLL => true
   | RISCV_SRL => true
   | RISCV_SUB => true
   | RISCV_SRA => true
   end.

Definition rtype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "add")) then true
   else if ((generic_eq p0_ "slt")) then true
   else if ((generic_eq p0_ "sltu")) then true
   else if ((generic_eq p0_ "and")) then true
   else if ((generic_eq p0_ "or")) then true
   else if ((generic_eq p0_ "xor")) then true
   else if ((generic_eq p0_ "sll")) then true
   else if ((generic_eq p0_ "srl")) then true
   else if ((generic_eq p0_ "sub")) then true
   else if ((generic_eq p0_ "sra")) then true
   else false.

Definition _s304_ (_s305_ : string) 
: option string :=
   
   let _s306_ := _s305_ in
   if ((string_startswith _s306_ "sra")) then
     match (string_drop _s306_ (projT1 (string_length "sra"))) with | s_ => Some (s_) end
   else None.

Definition _s300_ (_s301_ : string) 
: option string :=
   
   let _s302_ := _s301_ in
   if ((string_startswith _s302_ "sub")) then
     match (string_drop _s302_ (projT1 (string_length "sub"))) with | s_ => Some (s_) end
   else None.

Definition _s296_ (_s297_ : string) 
: option string :=
   
   let _s298_ := _s297_ in
   if ((string_startswith _s298_ "srl")) then
     match (string_drop _s298_ (projT1 (string_length "srl"))) with | s_ => Some (s_) end
   else None.

Definition _s292_ (_s293_ : string) 
: option string :=
   
   let _s294_ := _s293_ in
   if ((string_startswith _s294_ "sll")) then
     match (string_drop _s294_ (projT1 (string_length "sll"))) with | s_ => Some (s_) end
   else None.

Definition _s288_ (_s289_ : string) 
: option string :=
   
   let _s290_ := _s289_ in
   if ((string_startswith _s290_ "xor")) then
     match (string_drop _s290_ (projT1 (string_length "xor"))) with | s_ => Some (s_) end
   else None.

Definition _s284_ (_s285_ : string) 
: option string :=
   
   let _s286_ := _s285_ in
   if ((string_startswith _s286_ "or")) then
     match (string_drop _s286_ (projT1 (string_length "or"))) with | s_ => Some (s_) end
   else None.

Definition _s280_ (_s281_ : string) 
: option string :=
   
   let _s282_ := _s281_ in
   if ((string_startswith _s282_ "and")) then
     match (string_drop _s282_ (projT1 (string_length "and"))) with | s_ => Some (s_) end
   else None.

Definition _s276_ (_s277_ : string) 
: option string :=
   
   let _s278_ := _s277_ in
   if ((string_startswith _s278_ "sltu")) then
     match (string_drop _s278_ (projT1 (string_length "sltu"))) with | s_ => Some (s_) end
   else None.

Definition _s272_ (_s273_ : string) 
: option string :=
   
   let _s274_ := _s273_ in
   if ((string_startswith _s274_ "slt")) then
     match (string_drop _s274_ (projT1 (string_length "slt"))) with | s_ => Some (s_) end
   else None.

Definition _s268_ (_s269_ : string) 
: option string :=
   
   let _s270_ := _s269_ in
   if ((string_startswith _s270_ "add")) then
     match (string_drop _s270_ (projT1 (string_length "add"))) with | s_ => Some (s_) end
   else None.

Definition rtype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((rop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s271_ := arg_ in
   (if ((match (_s268_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s268_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ADD, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s272_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s272_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLT, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s276_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s276_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLTU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s280_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s280_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_AND, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s284_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s284_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_OR, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s288_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s288_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_XOR, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s292_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s292_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLL, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s296_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s296_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRL, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s300_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s300_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SUB, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s304_ _s271_) with | Some (s_) => true | _ => false end)) then
      (match (_s304_ _s271_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRA, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((rop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((rop * {n : Z & ArithFact (n >= 0)}))).

Definition extend_value {n : Z} (is_unsigned : bool) (value : MemoryOpResult (mword (8 * n)))
`{ArithFact ((0 + 1) <= n /\ n <= 8)} 
: MemoryOpResult (mword 64) :=
   
   match value with
   | MemValue (v) =>
      MemValue (if sumbool_of_bool (is_unsigned) then EXTZ 64 v else (EXTS 64 v)  : xlenbits)
   | MemException (e) => MemException (e)
   end.

Definition process_load {n : Z}
(rd : mword 5) (addr : mword 64) (value : MemoryOpResult (mword (8 * n))) (is_unsigned : bool)
`{ArithFact ((0 + 1) <= n /\ n <= 8)} 
: M (bool) :=
   
   (match (extend_value is_unsigned value) with
    | MemValue (result) =>
       (wX (projT1 (regbits_to_regno rd)) result) >>
       returnm (projT1
       (build_ex
       true
        : {_bool : bool & ArithFact (_bool = true)}))
    | MemException (e) =>
       (handle_mem_exception addr e) >>
       returnm (projT1
       (build_ex
       false
        : {_bool : bool & ArithFact (not (_bool = true))}))
    end)
    : M (bool).

Definition check_misaligned (vaddr : mword 64) (width : word_width) 
: M (bool) :=
   
   (if ((plat_enable_misaligned_access tt)) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else
      (match width with
       | BYTE =>
          returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
       | HALF =>
          (bit_to_bool (access_vec_dec vaddr 0)) >>= fun w__0 : bool =>
          returnm ((Bool.eqb w__0 true)
           : bool)
       | WORD =>
          (or_boolM
             ((bit_to_bool (access_vec_dec vaddr 0)) >>= fun w__1 : bool =>
              returnm ((Bool.eqb w__1 true)
               : bool))
             ((bit_to_bool (access_vec_dec vaddr 1)) >>= fun w__2 : bool =>
              returnm ((Bool.eqb w__2 true)
               : bool)))
           : M (bool)
       | DOUBLE =>
          (or_boolM
             ((bit_to_bool (access_vec_dec vaddr 0)) >>= fun w__4 : bool =>
              returnm ((Bool.eqb w__4 true)
               : bool))
             ((or_boolM
                 ((bit_to_bool (access_vec_dec vaddr 1)) >>= fun w__5 : bool =>
                  returnm ((Bool.eqb w__5 true)
                   : bool))
                 ((bit_to_bool (access_vec_dec vaddr 2)) >>= fun w__6 : bool =>
                  returnm ((Bool.eqb w__6 true)
                   : bool)))
              : M (bool)))
           : M (bool)
       end)
       : M (bool))
    : M (bool).

Definition maybe_u_forwards (arg_ : bool) 
: string :=
   
   match arg_ with | true => "u" | false => "" end.

Definition maybe_u_backwards (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "u")) then true
   else false.

Definition maybe_u_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition maybe_u_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "u")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s312_ (_s313_ : string) 
: option string :=
   
   let _s314_ := _s313_ in
   if ((string_startswith _s314_ "")) then
     match (string_drop _s314_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s308_ (_s309_ : string) 
: option string :=
   
   let _s310_ := _s309_ in
   if ((string_startswith _s310_ "u")) then
     match (string_drop _s310_ (projT1 (string_length "u"))) with | s_ => Some (s_) end
   else None.

Definition maybe_u_matches_prefix (arg_ : string) 
: M (option ((bool * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s311_ := arg_ in
   (if ((match (_s308_ _s311_) with | Some (s_) => true | _ => false end)) then
      (match (_s308_ _s311_) with
       | Some (s_) =>
          returnm ((Some
                      ((true, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s312_ _s311_) with | Some (s_) => true | _ => false end)) then
      (match (_s312_ _s311_) with
       | Some (s_) =>
          returnm ((Some
                      ((false, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bool * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bool * {n : Z & ArithFact (n >= 0)}))).

Definition shiftw_mnemonic_forwards (arg_ : sop) 
: string :=
   
   match arg_ with | RISCV_SLLI => "slli" | RISCV_SRLI => "srli" | RISCV_SRAI => "srai" end.

Definition shiftw_mnemonic_backwards (arg_ : string) 
: sop :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slli")) then RISCV_SLLI
   else if ((generic_eq p0_ "srli")) then RISCV_SRLI
   else RISCV_SRAI.

Definition shiftw_mnemonic_forwards_matches (arg_ : sop) 
: bool :=
   
   match arg_ with | RISCV_SLLI => true | RISCV_SRLI => true | RISCV_SRAI => true end.

Definition shiftw_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slli")) then true
   else if ((generic_eq p0_ "srli")) then true
   else if ((generic_eq p0_ "srai")) then true
   else false.

Definition _s324_ (_s325_ : string) 
: option string :=
   
   let _s326_ := _s325_ in
   if ((string_startswith _s326_ "srai")) then
     match (string_drop _s326_ (projT1 (string_length "srai"))) with | s_ => Some (s_) end
   else None.

Definition _s320_ (_s321_ : string) 
: option string :=
   
   let _s322_ := _s321_ in
   if ((string_startswith _s322_ "srli")) then
     match (string_drop _s322_ (projT1 (string_length "srli"))) with | s_ => Some (s_) end
   else None.

Definition _s316_ (_s317_ : string) 
: option string :=
   
   let _s318_ := _s317_ in
   if ((string_startswith _s318_ "slli")) then
     match (string_drop _s318_ (projT1 (string_length "slli"))) with | s_ => Some (s_) end
   else None.

Definition shiftw_mnemonic_matches_prefix (arg_ : string) 
: M (option ((sop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s319_ := arg_ in
   (if ((match (_s316_ _s319_) with | Some (s_) => true | _ => false end)) then
      (match (_s316_ _s319_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s320_ _s319_) with | Some (s_) => true | _ => false end)) then
      (match (_s320_ _s319_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s324_ _s319_) with | Some (s_) => true | _ => false end)) then
      (match (_s324_ _s319_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((sop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((sop * {n : Z & ArithFact (n >= 0)}))).

Definition rtypew_mnemonic_forwards (arg_ : ropw) 
: string :=
   
   match arg_ with
   | RISCV_ADDW => "addw"
   | RISCV_SUBW => "subw"
   | RISCV_SLLW => "sllw"
   | RISCV_SRLW => "srlw"
   | RISCV_SRAW => "sraw"
   end.

Definition rtypew_mnemonic_backwards (arg_ : string) 
: ropw :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "addw")) then RISCV_ADDW
   else if ((generic_eq p0_ "subw")) then RISCV_SUBW
   else if ((generic_eq p0_ "sllw")) then RISCV_SLLW
   else if ((generic_eq p0_ "srlw")) then RISCV_SRLW
   else RISCV_SRAW.

Definition rtypew_mnemonic_forwards_matches (arg_ : ropw) 
: bool :=
   
   match arg_ with
   | RISCV_ADDW => true
   | RISCV_SUBW => true
   | RISCV_SLLW => true
   | RISCV_SRLW => true
   | RISCV_SRAW => true
   end.

Definition rtypew_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "addw")) then true
   else if ((generic_eq p0_ "subw")) then true
   else if ((generic_eq p0_ "sllw")) then true
   else if ((generic_eq p0_ "srlw")) then true
   else if ((generic_eq p0_ "sraw")) then true
   else false.

Definition _s344_ (_s345_ : string) 
: option string :=
   
   let _s346_ := _s345_ in
   if ((string_startswith _s346_ "sraw")) then
     match (string_drop _s346_ (projT1 (string_length "sraw"))) with | s_ => Some (s_) end
   else None.

Definition _s340_ (_s341_ : string) 
: option string :=
   
   let _s342_ := _s341_ in
   if ((string_startswith _s342_ "srlw")) then
     match (string_drop _s342_ (projT1 (string_length "srlw"))) with | s_ => Some (s_) end
   else None.

Definition _s336_ (_s337_ : string) 
: option string :=
   
   let _s338_ := _s337_ in
   if ((string_startswith _s338_ "sllw")) then
     match (string_drop _s338_ (projT1 (string_length "sllw"))) with | s_ => Some (s_) end
   else None.

Definition _s332_ (_s333_ : string) 
: option string :=
   
   let _s334_ := _s333_ in
   if ((string_startswith _s334_ "subw")) then
     match (string_drop _s334_ (projT1 (string_length "subw"))) with | s_ => Some (s_) end
   else None.

Definition _s328_ (_s329_ : string) 
: option string :=
   
   let _s330_ := _s329_ in
   if ((string_startswith _s330_ "addw")) then
     match (string_drop _s330_ (projT1 (string_length "addw"))) with | s_ => Some (s_) end
   else None.

Definition rtypew_mnemonic_matches_prefix (arg_ : string) 
: M (option ((ropw * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s331_ := arg_ in
   (if ((match (_s328_ _s331_) with | Some (s_) => true | _ => false end)) then
      (match (_s328_ _s331_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ADDW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s332_ _s331_) with | Some (s_) => true | _ => false end)) then
      (match (_s332_ _s331_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SUBW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s336_ _s331_) with | Some (s_) => true | _ => false end)) then
      (match (_s336_ _s331_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s340_ _s331_) with | Some (s_) => true | _ => false end)) then
      (match (_s340_ _s331_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s344_ _s331_) with | Some (s_) => true | _ => false end)) then
      (match (_s344_ _s331_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((ropw * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((ropw * {n : Z & ArithFact (n >= 0)}))).

Definition shiftiwop_mnemonic_forwards (arg_ : sopw) 
: string :=
   
   match arg_ with | RISCV_SLLIW => "slliw" | RISCV_SRLIW => "srliw" | RISCV_SRAIW => "sraiw" end.

Definition shiftiwop_mnemonic_backwards (arg_ : string) 
: sopw :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slliw")) then RISCV_SLLIW
   else if ((generic_eq p0_ "srliw")) then RISCV_SRLIW
   else RISCV_SRAIW.

Definition shiftiwop_mnemonic_forwards_matches (arg_ : sopw) 
: bool :=
   
   match arg_ with | RISCV_SLLIW => true | RISCV_SRLIW => true | RISCV_SRAIW => true end.

Definition shiftiwop_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slliw")) then true
   else if ((generic_eq p0_ "srliw")) then true
   else if ((generic_eq p0_ "sraiw")) then true
   else false.

Definition _s356_ (_s357_ : string) 
: option string :=
   
   let _s358_ := _s357_ in
   if ((string_startswith _s358_ "sraiw")) then
     match (string_drop _s358_ (projT1 (string_length "sraiw"))) with | s_ => Some (s_) end
   else None.

Definition _s352_ (_s353_ : string) 
: option string :=
   
   let _s354_ := _s353_ in
   if ((string_startswith _s354_ "srliw")) then
     match (string_drop _s354_ (projT1 (string_length "srliw"))) with | s_ => Some (s_) end
   else None.

Definition _s348_ (_s349_ : string) 
: option string :=
   
   let _s350_ := _s349_ in
   if ((string_startswith _s350_ "slliw")) then
     match (string_drop _s350_ (projT1 (string_length "slliw"))) with | s_ => Some (s_) end
   else None.

Definition shiftiwop_mnemonic_matches_prefix (arg_ : string) 
: M (option ((sopw * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s351_ := arg_ in
   (if ((match (_s348_ _s351_) with | Some (s_) => true | _ => false end)) then
      (match (_s348_ _s351_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLIW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sopw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s352_ _s351_) with | Some (s_) => true | _ => false end)) then
      (match (_s352_ _s351_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLIW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sopw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s356_ _s351_) with | Some (s_) => true | _ => false end)) then
      (match (_s356_ _s351_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAIW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sopw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((sopw * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((sopw * {n : Z & ArithFact (n >= 0)}))).

Definition raise_c2_exception6 (capEx : CapEx) (regnum : mword 6) 
: M (bool) :=
   
   let '_ :=
     (print_endline
        (String.append "CHERI "
           (String.append (string_of_capex capEx) (String.append " Reg=" (string_of_bits regnum)))))
      : unit in
   assert_exp' false "[[96mmodel/cheri_insts.sail[0m]:50:16-17
50[96m |[0m    assert(false);
  [91m |[0m                [91m^[0m
  [91m |[0m 
: false" >>= fun _ =>
   exit tt.

Definition raise_c2_exception (capEx : CapEx) (regnum : mword 5) 
: M (bool) :=
   
   let reg6 := concat_vec (vec_of_bits [B0]  : mword 1) regnum in
   (raise_c2_exception6 capEx reg6)
    : M (bool).

Definition raise_c2_exception_pcc (capEx : CapEx) 
: M (bool) :=
   
   (raise_c2_exception6 capEx (vec_of_bits [B1;B0;B0;B0;B0;B0]  : mword 6))
    : M (bool).

Definition pcc_access_system_regs '(tt : unit) 
: M (bool) :=
   
   read_reg PCC_ref >>= fun w__0 : Capability =>
   returnm (w__0.(Capability_access_system_regs)
    : bool).

Definition execute_branch_pcc (newPCC : Capability) 
: M (unit) :=
   
   write_reg nextPC_ref newPCC.(Capability_address) >> write_reg nextPCC_ref newPCC  : M (unit).

Definition handle_load_data_via_cap
(rd : mword 5) (cs : mword 6) (cap_val : Capability) (vaddr : Z) (is_unsigned : bool)
(width : word_width) `{ArithFact (0 <= vaddr /\ vaddr <= (2 ^ 64 - 1))} 
: M (bool) :=
   
   let '(existT _ base _, existT _ top _) := getCapBounds cap_val in
   let vaddrBits := to_bits xlen vaddr in
   let 'size := projT1 (word_width_bytes width) in
   let aq : bool := false in
   let rl : bool := false in
   (if ((negb cap_val.(Capability_tag))) then
      (raise_c2_exception6 CapEx_TagViolation cs)
       : M (bool)
    else if (cap_val.(Capability_sealed)) then
      (raise_c2_exception6 CapEx_SealViolation cs)
       : M (bool)
    else if ((negb cap_val.(Capability_permit_load))) then
      (raise_c2_exception6 CapEx_PermitLoadViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb (Z.add vaddr size) top)) then
      (raise_c2_exception6 CapEx_LengthViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb vaddr base)) then
      (raise_c2_exception6 CapEx_LengthViolation cs)
       : M (bool)
    else
      (check_misaligned vaddrBits width) >>= fun w__5 : bool =>
      (if sumbool_of_bool (w__5) then
         (handle_mem_exception vaddrBits E_Load_Addr_Align) >>
         returnm (projT1
         (build_ex
         false
          : {_bool : bool & ArithFact (not (_bool = true))}))
       else
         (mem_read vaddrBits size aq rl false) >>= fun w__6 : MemoryOpResult (mword (8 * size)) =>
         (process_load rd vaddrBits w__6 is_unsigned)
          : M (bool))
       : M (bool))
    : M (bool).

Definition handle_load_cap_via_cap (rd : mword 5) (cs : mword 6) (cap_val : Capability) (vaddr : Z)
`{ArithFact (0 <= vaddr /\ vaddr <= (2 ^ 64 - 1))} 
: M (bool) :=
   
   let '(existT _ base _, existT _ top _) := getCapBounds cap_val in
   let vaddrBits := to_bits xlen vaddr in
   let aq : bool := false in
   let rl : bool := false in
   (if ((negb cap_val.(Capability_tag))) then
      (raise_c2_exception6 CapEx_TagViolation cs)
       : M (bool)
    else if (cap_val.(Capability_sealed)) then
      (raise_c2_exception6 CapEx_SealViolation cs)
       : M (bool)
    else if ((negb cap_val.(Capability_permit_load))) then
      (raise_c2_exception6 CapEx_PermitLoadViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb (Z.add vaddr cap_size) top)) then
      (raise_c2_exception6 CapEx_LengthViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb vaddr base)) then
      (raise_c2_exception6 CapEx_LengthViolation cs)
       : M (bool)
    else if ((negb (is_aligned_addr vaddrBits cap_size))) then
      (handle_mem_exception vaddrBits E_Load_Addr_Align) >>
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else
      (mem_read_cap vaddrBits aq rl false) >>= fun c =>
      (match c with
       | MemValue (v) =>
          (writeCapReg (projT1 (regbits_to_regno rd)) v) >>
          returnm (projT1
          (build_ex
          true
           : {_bool : bool & ArithFact (_bool = true)}))
       | MemException (e) =>
          (handle_mem_exception vaddrBits e) >>
          returnm (projT1
          (build_ex
          false
           : {_bool : bool & ArithFact (not (_bool = true))}))
       end)
       : M (bool))
    : M (bool).

Definition handle_store_data_via_cap
(rs : mword 5) (cs : mword 5) (cap_val : Capability) (vaddr : Z) (width : word_width)
`{ArithFact (0 <= vaddr /\ vaddr <= (2 ^ 64 - 1))} 
: M (bool) :=
   
   let '(existT _ base _, existT _ top _) := getCapBounds cap_val in
   let vaddrBits := to_bits xlen vaddr in
   let 'size := projT1 (word_width_bytes width) in
   let aq : bool := false in
   let rl : bool := false in
   (if ((negb cap_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cs)  : M (bool)
    else if (cap_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (bool)
    else if ((negb cap_val.(Capability_permit_store))) then
      (raise_c2_exception CapEx_PermitStoreViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb (Z.add vaddr size) top)) then
      (raise_c2_exception CapEx_LengthViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb vaddr base)) then
      (raise_c2_exception CapEx_LengthViolation cs)
       : M (bool)
    else
      (check_misaligned vaddrBits width) >>= fun w__5 : bool =>
      (if sumbool_of_bool (w__5) then
         (handle_mem_exception vaddrBits E_SAMO_Addr_Align) >>
         returnm (projT1
         (build_ex
         false
          : {_bool : bool & ArithFact (not (_bool = true))}))
       else
         (mem_write_ea vaddrBits size aq rl false) >>= fun eares : MemoryOpResult unit =>
         (match eares with
          | MemException (e) =>
             (handle_mem_exception vaddrBits e) >>
             returnm (projT1
             (build_ex
             false
              : {_bool : bool & ArithFact (not (_bool = true))}))
          | MemValue (_) =>
             (rX (projT1 (regbits_to_regno rs))) >>= fun rs_val =>
             (match width with
              | BYTE =>
                 (mem_write_value vaddrBits 1 (subrange_vec_dec rs_val 7 0) aq rl false)
                  : M (MemoryOpResult bool)
              | HALF =>
                 (mem_write_value vaddrBits 2 (subrange_vec_dec rs_val 15 0) aq rl false)
                  : M (MemoryOpResult bool)
              | WORD =>
                 (mem_write_value vaddrBits 4 (subrange_vec_dec rs_val 31 0) aq rl false)
                  : M (MemoryOpResult bool)
              | DOUBLE =>
                 (mem_write_value vaddrBits 8 rs_val aq rl false)  : M (MemoryOpResult bool)
              end) >>= fun res : MemoryOpResult bool =>
             (match res with
              | MemValue (true) =>
                 returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
              | MemValue (false) =>
                 (internal_error "store got false from mem_write_value")  : M (bool)
              | MemException (e) =>
                 (handle_mem_exception vaddrBits e) >>
                 returnm (projT1
                 (build_ex
                 false
                  : {_bool : bool & ArithFact (not (_bool = true))}))
              end)
              : M (bool)
          end)
          : M (bool))
       : M (bool))
    : M (bool).

Definition handle_store_cap_via_cap (rs : mword 5) (cs : mword 5) (cap_val : Capability) (vaddr : Z)
`{ArithFact (0 <= vaddr /\ vaddr <= (2 ^ 64 - 1))} 
: M (bool) :=
   
   let '(existT _ base _, existT _ top _) := getCapBounds cap_val in
   let vaddrBits := to_bits xlen vaddr in
   let aq : bool := false in
   let rl : bool := false in
   (if ((negb cap_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cs)  : M (bool)
    else if (cap_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (bool)
    else if ((negb cap_val.(Capability_permit_store))) then
      (raise_c2_exception CapEx_PermitStoreViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb (Z.add vaddr cap_size) top)) then
      (raise_c2_exception CapEx_LengthViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb vaddr base)) then
      (raise_c2_exception CapEx_LengthViolation cs)
       : M (bool)
    else if ((negb (is_aligned_addr vaddrBits cap_size))) then
      (handle_mem_exception vaddrBits E_SAMO_Addr_Align) >>
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else
      (mem_write_ea_cap vaddrBits aq rl false) >>= fun eares : MemoryOpResult unit =>
      (match eares with
       | MemException (e) =>
          (handle_mem_exception vaddrBits e) >>
          returnm (projT1
          (build_ex
          false
           : {_bool : bool & ArithFact (not (_bool = true))}))
       | MemValue (_) =>
          (readCapReg (projT1 (regbits_to_regno rs))) >>= fun rs_val =>
          (mem_write_cap vaddrBits rs_val aq rl false) >>= fun res : MemoryOpResult bool =>
          (match res with
           | MemValue (true) =>
              returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
           | MemValue (false) => (internal_error "store got false from mem_write_value")  : M (bool)
           | MemException (e) =>
              (handle_mem_exception vaddrBits e) >>
              returnm (projT1
              (build_ex
              false
               : {_bool : bool & ArithFact (not (_bool = true))}))
           end)
           : M (bool)
       end)
       : M (bool))
    : M (bool).

Definition encdec_forwards (arg_ : ast) 
: M (mword 32) :=
   
   (match arg_ with
    | UTYPE (imm,rd,op) =>
       returnm ((concat_vec (imm  : mword 20) (concat_vec (rd  : mword 5) (encdec_uop_forwards op)))
        : mword (20 + (5 + 7)))
    | RISCV_JAL (v__0,rd) =>
       let imm_19 : bits 1 := subrange_vec_dec v__0 20 20 in
       let imm_8 : bits 1 := subrange_vec_dec v__0 11 11 in
       let imm_7_0 : bits 8 := subrange_vec_dec v__0 19 12 in
       let imm_19 : bits 1 := subrange_vec_dec v__0 20 20 in
       let imm_18_13 : bits 6 := subrange_vec_dec v__0 10 5 in
       let imm_12_9 : bits 4 := subrange_vec_dec v__0 4 1 in
       returnm ((concat_vec (imm_19  : bits 1)
                   (concat_vec (imm_18_13  : bits 6)
                      (concat_vec (imm_12_9  : bits 4)
                         (concat_vec (imm_8  : bits 1)
                            (concat_vec (imm_7_0  : bits 8)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  : mword 7)))))))
        : mword 32)
    | RISCV_JALR (imm,rs1,rd) =>
       returnm ((concat_vec (imm  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                         (concat_vec (rd  : mword 5) (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | BTYPE (v__2,rs2,rs1,op) =>
       let imm7_6 : bits 1 := subrange_vec_dec v__2 12 12 in
       let imm7_6 : bits 1 := subrange_vec_dec v__2 12 12 in
       let imm7_5_0 : bits 6 := subrange_vec_dec v__2 10 5 in
       let imm5_4_1 : bits 4 := subrange_vec_dec v__2 4 1 in
       let imm5_0 : bits 1 := subrange_vec_dec v__2 11 11 in
       returnm ((concat_vec (imm7_6  : bits 1)
                   (concat_vec (imm7_5_0  : bits 6)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (encdec_bop_forwards op)
                               (concat_vec (imm5_4_1  : bits 4)
                                  (concat_vec (imm5_0  : bits 1)
                                     (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  : mword 7))))))))
        : mword 32)
    | ITYPE (imm,rs1,rd,op) =>
       returnm ((concat_vec (imm  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (encdec_iop_forwards op)
                         (concat_vec (rd  : mword 5) (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | SHIFTIOP (shamt,rs1,rd,RISCV_SLLI) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6)
                   (concat_vec (shamt  : mword 6)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (6 + (6 + (5 + (3 + (5 + 7))))))
    | SHIFTIOP (shamt,rs1,rd,RISCV_SRLI) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6)
                   (concat_vec (shamt  : mword 6)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (6 + (6 + (5 + (3 + (5 + 7))))))
    | SHIFTIOP (shamt,rs1,rd,RISCV_SRAI) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0]  : mword 6)
                   (concat_vec (shamt  : mword 6)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (6 + (6 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_ADD) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_SLT) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B1;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_SLTU) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B1;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_AND) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B1;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_OR) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B1;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_XOR) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_SLL) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_SRL) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_SUB) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE (rs2,rs1,rd,RISCV_SRA) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | LOAD (imm,rs1,rd,is_unsigned,size,false,false) =>
       returnm ((concat_vec (imm  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (bool_bits_forwards is_unsigned)
                         (concat_vec (size_bits_forwards size)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  : mword 7))))))
        : mword (12 + (5 + (1 + (2 + (5 + 7))))))
    | ADDIW (imm,rs1,rd) =>
       returnm ((concat_vec (imm  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                         (concat_vec (rd  : mword 5) (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | SHIFTW (shamt,rs1,rd,RISCV_SLLI) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (shamt  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | SHIFTW (shamt,rs1,rd,RISCV_SRLI) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (shamt  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | SHIFTW (shamt,rs1,rd,RISCV_SRAI) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (shamt  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPEW (rs2,rs1,rd,RISCV_ADDW) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPEW (rs2,rs1,rd,RISCV_SUBW) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPEW (rs2,rs1,rd,RISCV_SLLW) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPEW (rs2,rs1,rd,RISCV_SRLW) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPEW (rs2,rs1,rd,RISCV_SRAW) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | SHIFTIWOP (shamt,rs1,rd,RISCV_SLLIW) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (shamt  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | SHIFTIWOP (shamt,rs1,rd,RISCV_SRLIW) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (shamt  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | SHIFTIWOP (shamt,rs1,rd,RISCV_SRAIW) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (shamt  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetPerm (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetType (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetBase (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetLen (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetTag (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetSealed (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetOffset (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CGetAddr (rd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CMove (cd,cs) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CClearTag (cd,cs) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CJALR (cd,cb) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CSeal (cd,cs,ct) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0;B1;B1]  : mword 7)
                   (concat_vec (ct  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CUnseal (cd,cs,ct) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  : mword 7)
                   (concat_vec (ct  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CAndPerm (cd,cs,rt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B1;B0;B1]  : mword 7)
                   (concat_vec (rt  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CSetOffset (cd,cs,rt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B1;B1;B1]  : mword 7)
                   (concat_vec (rt  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CIncOffset (cd,cs,rt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B1;B0;B0;B0;B1]  : mword 7)
                   (concat_vec (rt  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CSetBounds (cd,cs,rt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  : mword 7)
                   (concat_vec (rt  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CSetBoundsExact (cd,cs,rt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  : mword 7)
                   (concat_vec (rt  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CToPtr (rd,cb,cs) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B1;B0;B0;B1;B0]  : mword 7)
                   (concat_vec (cs  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CFromPtr (cd,cb,rs) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7)
                   (concat_vec (rs  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CCall (cs,cb,b__0) =>
       returnm ((concat_vec (vec_of_bits [B1;B1;B1;B1;B1;B1;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)
                      (concat_vec (cb  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (cs  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CIncOffsetImmediate (cd,cb,imm12) =>
       returnm ((concat_vec (imm12  : bits 12)
                   (concat_vec (cb  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                         (concat_vec (cd  : mword 5) (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | CSetBoundsImmediate (cd,cb,imm12) =>
       returnm ((concat_vec (imm12  : bits 12)
                   (concat_vec (cb  : mword 5)
                      (concat_vec (vec_of_bits [B0;B1;B0]  : mword 3)
                         (concat_vec (cd  : mword 5) (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | CLoadCap (rd,cs,false,BYTE) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,false,HALF) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,false,WORD) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,false,DOUBLE) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,true,BYTE) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,true,HALF) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,true,WORD) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCap (rd,cs,true,DOUBLE) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CStoreCap (rd,cs,BYTE) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CStoreCap (rd,cs,HALF) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CStoreCap (rd,cs,WORD) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CStoreCap (rd,cs,DOUBLE) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CStoreCapCap (rd,cs) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | CLoadCapCap (rd,cs) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5)
                      (concat_vec (cs  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | ILLEGAL (s) => returnm (s  : mword 32)
    | _ => exit tt  : M (mword 32)
    end)
    : M (mword 32).

Definition encdec_backwards (arg_ : mword 32) 
: ast :=
   
   let v__4 := arg_ in
   if ((let _mappingpatterns_5_ : mword 7 := subrange_vec_dec v__4 6 0 in
     andb (encdec_uop_backwards_matches _mappingpatterns_5_)
       (if ((encdec_uop_backwards_matches _mappingpatterns_5_)) then
          let op := encdec_uop_backwards _mappingpatterns_5_ in
          true
           : bool
        else false))) then
     let imm : mword 20 := subrange_vec_dec v__4 31 12 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let imm : mword 20 := subrange_vec_dec v__4 31 12 in
     let _mappingpatterns_5_ : mword 7 := subrange_vec_dec v__4 6 0 in
     let op := encdec_uop_backwards _mappingpatterns_5_ in
     UTYPE
       ((imm, rd, op))
   else if ((eq_vec (subrange_vec_dec v__4 6 0)
               (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  : mword (6 - 0 + 1)))) then
     let imm_19 : bits 1 := subrange_vec_dec v__4 31 31 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let imm_8 : bits 1 := subrange_vec_dec v__4 20 20 in
     let imm_7_0 : bits 8 := subrange_vec_dec v__4 19 12 in
     let imm_19 : bits 1 := subrange_vec_dec v__4 31 31 in
     let imm_18_13 : bits 6 := subrange_vec_dec v__4 30 25 in
     let imm_12_9 : bits 4 := subrange_vec_dec v__4 24 21 in
     RISCV_JAL
       ((concat_vec (imm_19  : bits 1)
           (concat_vec (imm_7_0  : bits 8)
              (concat_vec (imm_8  : bits 1)
                 (concat_vec (imm_18_13  : bits 6)
                    (concat_vec (imm_12_9  : bits 4) (vec_of_bits [B0]  : mword 1))))), rd))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 14 12) (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     RISCV_JALR
       ((imm, rs1, rd))
   else if ((andb
               (let _mappingpatterns_6_ : mword 3 := subrange_vec_dec v__4 14 12 in
               andb (encdec_bop_backwards_matches _mappingpatterns_6_)
                 (if ((encdec_bop_backwards_matches _mappingpatterns_6_)) then
                    let op := encdec_bop_backwards _mappingpatterns_6_ in
                    true
                     : bool
                  else false))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm7_6 : bits 1 := subrange_vec_dec v__4 31 31 in
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let imm7_6 : bits 1 := subrange_vec_dec v__4 31 31 in
     let imm7_5_0 : bits 6 := subrange_vec_dec v__4 30 25 in
     let imm5_4_1 : bits 4 := subrange_vec_dec v__4 11 8 in
     let imm5_0 : bits 1 := subrange_vec_dec v__4 7 7 in
     let _mappingpatterns_6_ : mword 3 := subrange_vec_dec v__4 14 12 in
     let op := encdec_bop_backwards _mappingpatterns_6_ in
     BTYPE
       ((concat_vec (imm7_6  : bits 1)
           (concat_vec (imm5_0  : bits 1)
              (concat_vec (imm7_5_0  : bits 6)
                 (concat_vec (imm5_4_1  : bits 4) (vec_of_bits [B0]  : mword 1)))), rs2, rs1, op))
   else if ((andb
               (let _mappingpatterns_7_ : mword 3 := subrange_vec_dec v__4 14 12 in
               andb (encdec_iop_backwards_matches _mappingpatterns_7_)
                 (if ((encdec_iop_backwards_matches _mappingpatterns_7_)) then
                    let op := encdec_iop_backwards _mappingpatterns_7_ in
                    true
                     : bool
                  else false))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     let _mappingpatterns_7_ : mword 3 := subrange_vec_dec v__4 14 12 in
     let op := encdec_iop_backwards _mappingpatterns_7_ in
     ITYPE
       ((imm, rs1, rd, op))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 26)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 6 := subrange_vec_dec v__4 25 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTIOP
       ((shamt, rs1, rd, RISCV_SLLI))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 26)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 6 := subrange_vec_dec v__4 25 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTIOP
       ((shamt, rs1, rd, RISCV_SRLI))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 26)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 6 := subrange_vec_dec v__4 25 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTIOP
       ((shamt, rs1, rd, RISCV_SRAI))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_ADD))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B1;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_SLT))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B1;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_SLTU))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B1;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_AND))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B1;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_OR))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_XOR))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_SLL))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_SRL))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_SUB))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPE
       ((rs2, rs1, rd, RISCV_SRA))
   else if ((andb
               (let _mappingpatterns_9_ : mword 2 := subrange_vec_dec v__4 13 12 in
               let _mappingpatterns_8_ : mword 1 := subrange_vec_dec v__4 14 14 in
               andb (size_bits_backwards_matches _mappingpatterns_9_)
                 (if ((size_bits_backwards_matches _mappingpatterns_9_)) then
                    let size := size_bits_backwards _mappingpatterns_9_ in
                    (andb (bool_bits_backwards_matches _mappingpatterns_8_)
                       (if ((bool_bits_backwards_matches _mappingpatterns_8_)) then
                          let is_unsigned := bool_bits_backwards _mappingpatterns_8_ in
                          (orb (neq_vec (size_bits_forwards size) (vec_of_bits [B1;B1]  : mword 2))
                             (negb is_unsigned))
                           : bool
                        else false))
                     : bool
                  else false))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     let _mappingpatterns_9_ : mword 2 := subrange_vec_dec v__4 13 12 in
     let _mappingpatterns_8_ : mword 1 := subrange_vec_dec v__4 14 14 in
     let size := size_bits_backwards _mappingpatterns_9_ in
     let is_unsigned := bool_bits_backwards _mappingpatterns_8_ in
     LOAD
       ((imm, rs1, rd, is_unsigned, size, false, false))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 14 12) (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let imm : mword 12 := subrange_vec_dec v__4 31 20 in
     ADDIW
       ((imm, rs1, rd))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTW
       ((shamt, rs1, rd, RISCV_SLLI))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTW
       ((shamt, rs1, rd, RISCV_SRLI))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTW
       ((shamt, rs1, rd, RISCV_SRAI))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPEW
       ((rs2, rs1, rd, RISCV_ADDW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPEW
       ((rs2, rs1, rd, RISCV_SUBW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPEW
       ((rs2, rs1, rd, RISCV_SLLW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPEW
       ((rs2, rs1, rd, RISCV_SRLW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs2 : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     RTYPEW
       ((rs2, rs1, rd, RISCV_SRAW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTIWOP
       ((shamt, rs1, rd, RISCV_SLLIW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTIWOP
       ((shamt, rs1, rd, RISCV_SRLIW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let shamt : mword 5 := subrange_vec_dec v__4 24 20 in
     let rs1 : mword 5 := subrange_vec_dec v__4 19 15 in
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     SHIFTIWOP
       ((shamt, rs1, rd, RISCV_SRAIW))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetPerm
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetType
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetBase
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetLen
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetTag
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetSealed
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetOffset
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B1;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CGetAddr
       ((rd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CMove
       ((cd, cs))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CClearTag
       ((cd, cs))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CJALR
       ((cd, cb))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B0;B1;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let ct : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CSeal
       ((cd, cs, ct))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let ct : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CUnseal
       ((cd, cs, ct))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B1;B0;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rt : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CAndPerm
       ((cd, cs, rt))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B1;B1;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rt : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CSetOffset
       ((cd, cs, rt))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B1;B0;B0;B0;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rt : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CIncOffset
       ((cd, cs, rt))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rt : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CSetBounds
       ((cd, cs, rt))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rt : mword 5 := subrange_vec_dec v__4 24 20 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     CSetBoundsExact
       ((cd, cs, rt))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 24 20 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CToPtr
       ((rd, cb, cs))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 25)
                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rs : mword 5 := subrange_vec_dec v__4 24 20 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CFromPtr
       ((cd, cb, rs))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let cs : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CCall
       ((cs, cb, (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 14 12) (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm12 : bits 12 := subrange_vec_dec v__4 31 20 in
     let imm12 : bits 12 := subrange_vec_dec v__4 31 20 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CIncOffsetImmediate
       ((cd, cb, imm12))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 14 12) (vec_of_bits [B0;B1;B0]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__4 6 0)
                  (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let imm12 : bits 12 := subrange_vec_dec v__4 31 20 in
     let imm12 : bits 12 := subrange_vec_dec v__4 31 20 in
     let cd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cb : mword 5 := subrange_vec_dec v__4 19 15 in
     CSetBoundsImmediate
       ((cd, cb, imm12))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, false, BYTE))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, false, HALF))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, false, WORD))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, false, DOUBLE))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, true, BYTE))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, true, HALF))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, true, WORD))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCap
       ((rd, cs, true, DOUBLE))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CStoreCap
       ((rd, cs, BYTE))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CStoreCap
       ((rd, cs, HALF))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CStoreCap
       ((rd, cs, WORD))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CStoreCap
       ((rd, cs, DOUBLE))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CStoreCapCap
       ((rd, cs))
   else if ((andb
               (eq_vec (subrange_vec_dec v__4 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__4 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__4 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     let rd : mword 5 := subrange_vec_dec v__4 11 7 in
     let cs : mword 5 := subrange_vec_dec v__4 19 15 in
     CLoadCapCap
       ((rd, cs))
   else ILLEGAL (v__4).

Definition encdec_forwards_matches (arg_ : ast) 
: bool :=
   
   match arg_ with
   | UTYPE (imm,rd,op) => true
   | RISCV_JAL (v__287,rd) =>
      if ((eq_vec (subrange_vec_dec v__287 0 0) (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then true
      else
        let g__3 := RISCV_JAL ((v__287, rd)) in
        false
   | RISCV_JALR (imm,rs1,rd) => true
   | BTYPE (v__289,rs2,rs1,op) =>
      if ((eq_vec (subrange_vec_dec v__289 0 0) (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then true
      else
        let g__3 := BTYPE ((v__289, rs2, rs1, op)) in
        false
   | ITYPE (imm,rs1,rd,op) => true
   | SHIFTIOP (shamt,rs1,rd,RISCV_SLLI) => true
   | SHIFTIOP (shamt,rs1,rd,RISCV_SRLI) => true
   | SHIFTIOP (shamt,rs1,rd,RISCV_SRAI) => true
   | RTYPE (rs2,rs1,rd,RISCV_ADD) => true
   | RTYPE (rs2,rs1,rd,RISCV_SLT) => true
   | RTYPE (rs2,rs1,rd,RISCV_SLTU) => true
   | RTYPE (rs2,rs1,rd,RISCV_AND) => true
   | RTYPE (rs2,rs1,rd,RISCV_OR) => true
   | RTYPE (rs2,rs1,rd,RISCV_XOR) => true
   | RTYPE (rs2,rs1,rd,RISCV_SLL) => true
   | RTYPE (rs2,rs1,rd,RISCV_SRL) => true
   | RTYPE (rs2,rs1,rd,RISCV_SUB) => true
   | RTYPE (rs2,rs1,rd,RISCV_SRA) => true
   | LOAD (imm,rs1,rd,is_unsigned,size,false,false) =>
      if sumbool_of_bool ((orb (neq_vec (size_bits_forwards size) (vec_of_bits [B1;B1]  : mword 2))
                             (negb is_unsigned))) then
        true
      else
        let g__3 := LOAD ((imm, rs1, rd, is_unsigned, size, false, false)) in
        false
   | ADDIW (imm,rs1,rd) => true
   | SHIFTW (shamt,rs1,rd,RISCV_SLLI) => true
   | SHIFTW (shamt,rs1,rd,RISCV_SRLI) => true
   | SHIFTW (shamt,rs1,rd,RISCV_SRAI) => true
   | RTYPEW (rs2,rs1,rd,RISCV_ADDW) => true
   | RTYPEW (rs2,rs1,rd,RISCV_SUBW) => true
   | RTYPEW (rs2,rs1,rd,RISCV_SLLW) => true
   | RTYPEW (rs2,rs1,rd,RISCV_SRLW) => true
   | RTYPEW (rs2,rs1,rd,RISCV_SRAW) => true
   | SHIFTIWOP (shamt,rs1,rd,RISCV_SLLIW) => true
   | SHIFTIWOP (shamt,rs1,rd,RISCV_SRLIW) => true
   | SHIFTIWOP (shamt,rs1,rd,RISCV_SRAIW) => true
   | CGetPerm (rd,cb) => true
   | CGetType (rd,cb) => true
   | CGetBase (rd,cb) => true
   | CGetLen (rd,cb) => true
   | CGetTag (rd,cb) => true
   | CGetSealed (rd,cb) => true
   | CGetOffset (rd,cb) => true
   | CGetAddr (rd,cb) => true
   | CMove (cd,cs) => true
   | CClearTag (cd,cs) => true
   | CJALR (cd,cb) => true
   | CSeal (cd,cs,ct) => true
   | CUnseal (cd,cs,ct) => true
   | CAndPerm (cd,cs,rt) => true
   | CSetOffset (cd,cs,rt) => true
   | CIncOffset (cd,cs,rt) => true
   | CSetBounds (cd,cs,rt) => true
   | CSetBoundsExact (cd,cs,rt) => true
   | CToPtr (rd,cb,cs) => true
   | CFromPtr (cd,cb,rs) => true
   | CCall (cs,cb,b__0) =>
      if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                             (projT1
                              (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))))) then
        true
      else
        let g__3 := CCall ((cs, cb, b__0)) in
        false
   | CIncOffsetImmediate (cd,cb,imm12) => true
   | CSetBoundsImmediate (cd,cb,imm12) => true
   | CLoadCap (rd,cs,false,BYTE) => true
   | CLoadCap (rd,cs,false,HALF) => true
   | CLoadCap (rd,cs,false,WORD) => true
   | CLoadCap (rd,cs,false,DOUBLE) => true
   | CLoadCap (rd,cs,true,BYTE) => true
   | CLoadCap (rd,cs,true,HALF) => true
   | CLoadCap (rd,cs,true,WORD) => true
   | CLoadCap (rd,cs,true,DOUBLE) => true
   | CStoreCap (rd,cs,BYTE) => true
   | CStoreCap (rd,cs,HALF) => true
   | CStoreCap (rd,cs,WORD) => true
   | CStoreCap (rd,cs,DOUBLE) => true
   | CStoreCapCap (rd,cs) => true
   | CLoadCapCap (rd,cs) => true
   | ILLEGAL (s) => true
   | g__3 => false
   end.

Definition encdec_backwards_matches (arg_ : mword 32) 
: bool :=
   
   let v__291 := arg_ in
   if ((let _mappingpatterns_0_ : mword 7 := subrange_vec_dec v__291 6 0 in
     andb (encdec_uop_backwards_matches _mappingpatterns_0_)
       (if ((encdec_uop_backwards_matches _mappingpatterns_0_)) then
          let op := encdec_uop_backwards _mappingpatterns_0_ in
          true
           : bool
        else false))) then
     let _mappingpatterns_0_ : mword 7 := subrange_vec_dec v__291 6 0 in
     let op := encdec_uop_backwards _mappingpatterns_0_ in
     true
   else if ((eq_vec (subrange_vec_dec v__291 6 0)
               (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  : mword (6 - 0 + 1)))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 14 12)
                  (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  : mword (6 - 0 + 1))))) then
     true
   else if ((andb
               (let _mappingpatterns_1_ : mword 3 := subrange_vec_dec v__291 14 12 in
               andb (encdec_bop_backwards_matches _mappingpatterns_1_)
                 (if ((encdec_bop_backwards_matches _mappingpatterns_1_)) then
                    let op := encdec_bop_backwards _mappingpatterns_1_ in
                    true
                     : bool
                  else false))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let _mappingpatterns_1_ : mword 3 := subrange_vec_dec v__291 14 12 in
     let op := encdec_bop_backwards _mappingpatterns_1_ in
     true
   else if ((andb
               (let _mappingpatterns_2_ : mword 3 := subrange_vec_dec v__291 14 12 in
               andb (encdec_iop_backwards_matches _mappingpatterns_2_)
                 (if ((encdec_iop_backwards_matches _mappingpatterns_2_)) then
                    let op := encdec_iop_backwards _mappingpatterns_2_ in
                    true
                     : bool
                  else false))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let _mappingpatterns_2_ : mword 3 := subrange_vec_dec v__291 14 12 in
     let op := encdec_iop_backwards _mappingpatterns_2_ in
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 26)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 26)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 26)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B1;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B1;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B1;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B1;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (let _mappingpatterns_4_ : mword 2 := subrange_vec_dec v__291 13 12 in
               let _mappingpatterns_3_ : mword 1 := subrange_vec_dec v__291 14 14 in
               andb (size_bits_backwards_matches _mappingpatterns_4_)
                 (if ((size_bits_backwards_matches _mappingpatterns_4_)) then
                    let size := size_bits_backwards _mappingpatterns_4_ in
                    (andb (bool_bits_backwards_matches _mappingpatterns_3_)
                       (if ((bool_bits_backwards_matches _mappingpatterns_3_)) then
                          let is_unsigned := bool_bits_backwards _mappingpatterns_3_ in
                          (orb (neq_vec (size_bits_forwards size) (vec_of_bits [B1;B1]  : mword 2))
                             (negb is_unsigned))
                           : bool
                        else false))
                     : bool
                  else false))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     let _mappingpatterns_4_ : mword 2 := subrange_vec_dec v__291 13 12 in
     let _mappingpatterns_3_ : mword 1 := subrange_vec_dec v__291 14 14 in
     let size := size_bits_backwards _mappingpatterns_4_ in
     let is_unsigned := bool_bits_backwards _mappingpatterns_3_ in
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 14 12)
                  (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B0;B1;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B1;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B0;B1;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B0;B1;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B1;B0;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B1;B1;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B1;B0;B0;B0;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B0]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 25)
                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (31 - 25 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 14 12)
                  (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 14 12)
                  (vec_of_bits [B0;B1;B0]  : mword (14 - 12 + 1)))
               (eq_vec (subrange_vec_dec v__291 6 0)
                  (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B0;B1;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B1;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B0;B1;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__291 31 20)
                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B1]  : mword (31 - 20 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__291 14 12)
                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                  (eq_vec (subrange_vec_dec v__291 6 0)
                     (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  : mword (6 - 0 + 1)))))) then
     true
   else true.

Definition encdec_compressed_forwards (arg_ : ast) 
: M (mword 16) :=
   
   (match arg_ with | C_ILLEGAL (s) => returnm (s  : mword 16) | _ => exit tt  : M (mword 16) end)
    : M (mword 16).

Definition encdec_compressed_backwards (arg_ : mword 16) 
: ast :=
   
   match arg_ with | s => C_ILLEGAL (s) end.

Definition encdec_compressed_forwards_matches (arg_ : ast) 
: bool :=
   
   match arg_ with | C_ILLEGAL (s) => true | _ => false end.

Definition encdec_compressed_backwards_matches (arg_ : mword 16) 
: bool :=
   
   match arg_ with | s => true end.

Definition execute_UTYPE (imm : mword 20) (rd : mword 5) (op : uop) 
: M (bool) :=
   
   let off : xlenbits :=
     EXTS 64 (concat_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)) in
   (match op with
    | RISCV_LUI => (wX (projT1 (regbits_to_regno rd)) off)  : M (unit)
    | RISCV_AUIPC =>
       read_reg PCC_ref >>= fun w__0 : Capability =>
       ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
       (writeCapReg (projT1 (regbits_to_regno rd)) (setCapAddrOrNull w__0 (add_vec w__1 off)))
        : M (unit)
    end) >>
   returnm (true
    : bool).

Definition execute_SHIFTW (shamt : mword 5) (rs1 : mword 5) (rd : mword 5) (op : sop) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let rs1_val := subrange_vec_dec w__0 31 0 in
   let result : bits 32 :=
     match op with
     | RISCV_SLLI => shift_bits_left rs1_val shamt
     | RISCV_SRLI => shift_bits_right rs1_val shamt
     | RISCV_SRAI => shift_right_arith32 rs1_val shamt
     end in
   (wX (projT1 (regbits_to_regno rd)) (EXTS 64 result)) >> returnm (true  : bool).

Definition execute_SHIFTIWOP (shamt : mword 5) (rs1 : mword 5) (rd : mword 5) (op : sopw) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun rs1_val =>
   let result : xlenbits :=
     match op with
     | RISCV_SLLIW => EXTS 64 (shift_bits_left (subrange_vec_dec rs1_val 31 0) shamt)
     | RISCV_SRLIW => EXTS 64 (shift_bits_right (subrange_vec_dec rs1_val 31 0) shamt)
     | RISCV_SRAIW => EXTS 64 (shift_right_arith32 (subrange_vec_dec rs1_val 31 0) shamt)
     end in
   (wX (projT1 (regbits_to_regno rd)) result) >> returnm (true  : bool).

Definition execute_SHIFTIOP (shamt : mword 6) (rs1 : mword 5) (rd : mword 5) (op : sop) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun rs1_val =>
   let result : xlenbits :=
     match op with
     | RISCV_SLLI => shift_bits_left rs1_val shamt
     | RISCV_SRLI => shift_bits_right rs1_val shamt
     | RISCV_SRAI => shift_right_arith64 rs1_val shamt
     end in
   (wX (projT1 (regbits_to_regno rd)) result) >> returnm (true  : bool).

Definition execute_RTYPEW (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (op : ropw) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let rs1_val := subrange_vec_dec w__0 31 0 in
   (rX (projT1 (regbits_to_regno rs2))) >>= fun w__1 : mword 64 =>
   let rs2_val := subrange_vec_dec w__1 31 0 in
   let result : bits 32 :=
     match op with
     | RISCV_ADDW => add_vec rs1_val rs2_val
     | RISCV_SUBW => sub_vec rs1_val rs2_val
     | RISCV_SLLW => shift_bits_left rs1_val (subrange_vec_dec rs2_val 4 0)
     | RISCV_SRLW => shift_bits_right rs1_val (subrange_vec_dec rs2_val 4 0)
     | RISCV_SRAW => shift_right_arith32 rs1_val (subrange_vec_dec rs2_val 4 0)
     end in
   (wX (projT1 (regbits_to_regno rd)) (EXTS 64 result)) >> returnm (true  : bool).

Definition execute_RTYPE (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (op : rop) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun rs1_val =>
   (rX (projT1 (regbits_to_regno rs2))) >>= fun rs2_val =>
   let result : xlenbits :=
     match op with
     | RISCV_ADD => add_vec rs1_val rs2_val
     | RISCV_SLT => EXTZ 64 (bool_to_bits (zopz0zI_s rs1_val rs2_val))
     | RISCV_SLTU => EXTZ 64 (bool_to_bits (zopz0zI_u rs1_val rs2_val))
     | RISCV_AND => and_vec rs1_val rs2_val
     | RISCV_OR => or_vec rs1_val rs2_val
     | RISCV_XOR => xor_vec rs1_val rs2_val
     | RISCV_SLL => shift_bits_left rs1_val (subrange_vec_dec rs2_val 5 0)
     | RISCV_SRL => shift_bits_right rs1_val (subrange_vec_dec rs2_val 5 0)
     | RISCV_SUB => sub_vec rs1_val rs2_val
     | RISCV_SRA => shift_right_arith64 rs1_val (subrange_vec_dec rs2_val 5 0)
     end in
   (wX (projT1 (regbits_to_regno rd)) result) >> returnm (true  : bool).

Definition execute_RISCV_JALR (imm : mword 12) (rs1 : mword 5) (rd : mword 5) 
: M (bool) :=
   
   read_reg PCC_ref >>= fun w__0 : Capability =>
   let pcc_base := getCapBaseBits w__0 in
   (rX (projT1 (regbits_to_regno rs1))) >>= fun w__1 : mword 64 =>
   let newPC : xlenbits :=
     concat_vec (subrange_vec_dec (add_vec (add_vec pcc_base w__1) (EXTS 64 imm)) 63 1)
       (vec_of_bits [B0]  : mword 1) in
   read_reg PCC_ref >>= fun w__2 : Capability =>
   (if ((negb (inCapBounds w__2 newPC min_inst_bytes))) then
      (raise_c2_exception6 CapEx_LengthViolation (vec_of_bits [B1;B0;B0;B0;B0;B0]  : mword 6))
       : M (bool)
    else
      (and_boolM ((bit_to_bool (access_vec_dec newPC 1))  : M (bool))
         (returnm ((negb (haveRVC tt))
           : bool))) >>= fun w__5 : bool =>
      (if sumbool_of_bool (w__5) then
         (handle_mem_exception newPC E_Fetch_Addr_Align) >>
         returnm (projT1
         (build_ex
         false
          : {_bool : bool & ArithFact (not (_bool = true))}))
       else
         ((read_reg nextPC_ref)  : M (mword 64)) >>= fun w__6 : mword 64 =>
         (wX (projT1 (regbits_to_regno rd)) (sub_vec w__6 pcc_base)) >>
         write_reg nextPC_ref newPC >>
         returnm (projT1
         (build_ex
         true
          : {_bool : bool & ArithFact (_bool = true)})))
       : M (bool))
    : M (bool).

Definition execute_RISCV_JAL (imm : mword 21) (rd : mword 5) 
: M (bool) :=
   
   ((read_reg PC_ref)  : M (mword 64)) >>= fun pc : xlenbits =>
   let newPC : xlenbits := add_vec pc (EXTS 64 imm) in
   read_reg PCC_ref >>= fun w__0 : Capability =>
   (if ((negb (inCapBounds w__0 newPC min_inst_bytes))) then
      (raise_c2_exception6 CapEx_LengthViolation (vec_of_bits [B1;B0;B0;B0;B0;B0]  : mword 6))
       : M (bool)
    else
      (and_boolM ((bit_to_bool (access_vec_dec newPC 1))  : M (bool))
         (returnm ((negb (haveRVC tt))
           : bool))) >>= fun w__3 : bool =>
      (if sumbool_of_bool (w__3) then
         (handle_mem_exception newPC E_Fetch_Addr_Align) >>
         returnm (projT1
         (build_ex
         false
          : {_bool : bool & ArithFact (not (_bool = true))}))
       else
         ((read_reg nextPC_ref)  : M (mword 64)) >>= fun w__4 : mword 64 =>
         read_reg PCC_ref >>= fun w__5 : Capability =>
         (wX (projT1 (regbits_to_regno rd)) (sub_vec w__4 (getCapBaseBits w__5))) >>
         write_reg nextPC_ref newPC >>
         returnm (projT1
         (build_ex
         true
          : {_bool : bool & ArithFact (_bool = true)})))
       : M (bool))
    : M (bool).

Definition execute_ITYPE (imm : mword 12) (rs1 : mword 5) (rd : mword 5) (op : iop) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun rs1_val =>
   let immext : xlenbits := EXTS 64 imm in
   let result : xlenbits :=
     match op with
     | RISCV_ADDI => add_vec rs1_val immext
     | RISCV_SLTI => EXTZ 64 (bool_to_bits (zopz0zI_s rs1_val immext))
     | RISCV_SLTIU => EXTZ 64 (bool_to_bits (zopz0zI_u rs1_val immext))
     | RISCV_ANDI => and_vec rs1_val immext
     | RISCV_ORI => or_vec rs1_val immext
     | RISCV_XORI => xor_vec rs1_val immext
     end in
   (wX (projT1 (regbits_to_regno rd)) result) >> returnm (true  : bool).

Definition execute_ILLEGAL (s : mword 32) 
: M (bool) :=
   
   (handle_illegal tt) >>
   returnm (projT1
   (build_ex
   false
    : {_bool : bool & ArithFact (not (_bool = true))})).

Definition execute_C_ILLEGAL (s : mword 16) 
: M (bool) :=
   
   (handle_illegal tt) >>
   returnm (projT1
   (build_ex
   false
    : {_bool : bool & ArithFact (not (_bool = true))})).

Definition execute_CUnseal (cd : mword 5) (cs : mword 5) (ct : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cs_val =>
   (readCapReg (projT1 (regbits_to_regno ct))) >>= fun ct_val =>
   let 'ct_cursor := projT1 (getCapCursor ct_val) in
   (if ((negb cs_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cs)  : M (bool)
    else if ((negb ct_val.(Capability_tag))) then
      (raise_c2_exception CapEx_TagViolation ct)
       : M (bool)
    else if ((negb cs_val.(Capability_sealed))) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (bool)
    else if (ct_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation ct)
       : M (bool)
    else if sumbool_of_bool ((projT1
                              (neq_int ct_cursor (projT1 (uint cs_val.(Capability_otype)))))) then
      (raise_c2_exception CapEx_TypeViolation ct)
       : M (bool)
    else if ((negb ct_val.(Capability_permit_unseal))) then
      (raise_c2_exception CapEx_PermitUnsealViolation ct)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb ct_cursor (projT1 (getCapBase ct_val)))) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (bool)
    else if sumbool_of_bool ((Z.geb ct_cursor (projT1 (getCapTop ct_val)))) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (bool)
    else
      (writeCapReg (projT1 (regbits_to_regno cd))
         {[ (unsealCap cs_val) with
           Capability_global := (andb cs_val.(Capability_global) ct_val.(Capability_global)) ]}) >>
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)})))
    : M (bool).

Definition execute_CToPtr (rd : mword 5) (cb : mword 5) (ct : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno ct))) >>= fun ct_val =>
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (if ((negb ct_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation ct)  : M (bool)
    else if ((andb cb_val.(Capability_tag) cb_val.(Capability_sealed))) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else
      let 'ctBase := projT1 (getCapBase ct_val) in
      (wX (projT1 (regbits_to_regno rd))
         (if ((negb cb_val.(Capability_tag))) then zeros_implicit 64
          else to_bits 64 (Z.sub (projT1 (getCapCursor cb_val)) ctBase))) >>
      returnm (true
       : bool))
    : M (bool).

Definition execute_CStoreCapCap (rs : mword 5) (cs : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cap_val =>
   let 'vaddr := projT1 (getCapCursor cap_val) in
   (handle_store_cap_via_cap rs cs cap_val vaddr)
    : M (bool).

Definition execute_CStoreCap (rs : mword 5) (cs : mword 5) (width : word_width) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cap_val =>
   let 'vaddr := projT1 (getCapCursor cap_val) in
   (handle_store_data_via_cap rs cs cap_val vaddr width)
    : M (bool).

Definition execute_CSetOffset (cd : mword 5) (cb : mword 5) (rt : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (rX (projT1 (regbits_to_regno rt))) >>= fun rt_val =>
   (if ((andb cb_val.(Capability_tag) cb_val.(Capability_sealed))) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else
      let '(success, newCap) := setCapOffset cb_val rt_val in
      (if sumbool_of_bool (success) then
         (writeCapReg (projT1 (regbits_to_regno cd)) newCap)
          : M (unit)
       else
         (writeCapReg (projT1 (regbits_to_regno cd))
            (int_to_cap (add_vec (to_bits 64 (projT1 (getCapBase cb_val))) rt_val)))
          : M (unit)) >>
      returnm (true
       : bool))
    : M (bool).

Definition execute_CSetBoundsImmediate (cd : mword 5) (cb : mword 5) (imm : mword 12) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   let 'immU := projT1 (uint imm) in
   let 'cursor := projT1 (getCapCursor cb_val) in
   let 'base := projT1 (getCapBase cb_val) in
   let 'top := projT1 (getCapTop cb_val) in
   let newTop := Z.add cursor immU in
   (if ((negb cb_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cb)  : M (bool)
    else if (cb_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb cursor base)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb newTop top)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else
      let '(_, newCap) := setCapBounds cb_val (to_bits 64 cursor) (to_bits 65 newTop) in
      (writeCapReg (projT1 (regbits_to_regno cd)) newCap) >> returnm (true  : bool))
    : M (bool).

Definition execute_CSetBoundsExact (cd : mword 5) (cb : mword 5) (rt : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (rX (projT1 (regbits_to_regno rt))) >>= fun w__0 : mword 64 =>
   let 'rt_val := projT1 (uint w__0) in
   let 'cursor := projT1 (getCapCursor cb_val) in
   let 'base := projT1 (getCapBase cb_val) in
   let 'top := projT1 (getCapTop cb_val) in
   let newTop := Z.add cursor rt_val in
   (if ((negb cb_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cb)  : M (bool)
    else if (cb_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb cursor base)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb newTop top)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else
      let '(exact, newCap) := setCapBounds cb_val (to_bits 64 cursor) (to_bits 65 newTop) in
      (if ((negb exact)) then (raise_c2_exception CapEx_InexactBounds cb)  : M (bool)
       else
         (writeCapReg (projT1 (regbits_to_regno cd)) newCap) >>
         returnm (projT1
         (build_ex
         true
          : {_bool : bool & ArithFact (_bool = true)})))
       : M (bool))
    : M (bool).

Definition execute_CSetBounds (cd : mword 5) (cb : mword 5) (rt : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (rX (projT1 (regbits_to_regno rt))) >>= fun w__0 : mword 64 =>
   let 'rt_val := projT1 (uint w__0) in
   let 'cursor := projT1 (getCapCursor cb_val) in
   let 'base := projT1 (getCapBase cb_val) in
   let 'top := projT1 (getCapTop cb_val) in
   let newTop := Z.add cursor rt_val in
   (if ((negb cb_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cb)  : M (bool)
    else if (cb_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb cursor base)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb newTop top)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else
      let '(_, newCap) := setCapBounds cb_val (to_bits 64 cursor) (to_bits 65 newTop) in
      (writeCapReg (projT1 (regbits_to_regno cd)) newCap) >> returnm (true  : bool))
    : M (bool).

Definition execute_CSeal (cd : mword 5) (cs : mword 5) (ct : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cs_val =>
   (readCapReg (projT1 (regbits_to_regno ct))) >>= fun ct_val =>
   let 'ct_cursor := projT1 (getCapCursor ct_val) in
   let 'ct_top := projT1 (getCapTop ct_val) in
   let 'ct_base := projT1 (getCapBase ct_val) in
   (if ((negb cs_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cs)  : M (bool)
    else if ((negb ct_val.(Capability_tag))) then
      (raise_c2_exception CapEx_TagViolation ct)
       : M (bool)
    else if (cs_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (bool)
    else if (ct_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation ct)
       : M (bool)
    else if ((negb ct_val.(Capability_permit_seal))) then
      (raise_c2_exception CapEx_PermitSealViolation ct)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb ct_cursor ct_base)) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (bool)
    else if sumbool_of_bool ((Z.geb ct_cursor ct_top)) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb ct_cursor max_otype)) then
      (raise_c2_exception CapEx_LengthViolation ct)
       : M (bool)
    else
      let '(success, newCap) := sealCap cs_val (to_bits 24 ct_cursor) in
      (if ((negb success)) then (raise_c2_exception CapEx_InexactBounds cs)  : M (bool)
       else
         (writeCapReg (projT1 (regbits_to_regno cd)) newCap) >>
         returnm (projT1
         (build_ex
         true
          : {_bool : bool & ArithFact (_bool = true)})))
       : M (bool))
    : M (bool).

Definition execute_CMove (cd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun w__0 : Capability =>
   (writeCapReg (projT1 (regbits_to_regno cd)) w__0) >>
   returnm (projT1
   (build_ex
   true
    : {_bool : bool & ArithFact (_bool = true)})).

Definition execute_CLoadCapCap (rd : mword 5) (cs : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cap_val =>
   let 'vaddr := projT1 (getCapCursor cap_val) in
   (handle_load_cap_via_cap rd (concat_vec (vec_of_bits [B0]  : mword 1) cs) cap_val vaddr)
    : M (bool).

Definition execute_CLoadCap (rd : mword 5) (cs : mword 5) (is_unsigned : bool) (width : word_width) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cap_val =>
   let 'vaddr := projT1 (getCapCursor cap_val) in
   (handle_load_data_via_cap rd (concat_vec (vec_of_bits [B0]  : mword 1) cs) cap_val vaddr
      is_unsigned width)
    : M (bool).

Definition execute_CJALR (cd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   let 'cb_ptr := projT1 (getCapCursor cb_val) in
   let 'cb_top := projT1 (getCapTop cb_val) in
   let 'cb_base := projT1 (getCapBase cb_val) in
   (if ((negb cb_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cb)  : M (bool)
    else if (cb_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else if ((negb cb_val.(Capability_permit_execute))) then
      (raise_c2_exception CapEx_PermitExecuteViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb cb_ptr cb_base)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.gtb (Z.add cb_ptr min_inst_bytes) cb_top)) then
      (raise_c2_exception CapEx_LengthViolation cb)
       : M (bool)
    else if sumbool_of_bool ((projT1
                              (neq_int (projT1 (emod_with_eq cb_ptr min_inst_bytes)) 0))) then
      (handle_mem_exception (to_bits xlen cb_ptr) E_Fetch_Addr_Align) >>
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else
      read_reg PCC_ref >>= fun w__5 : Capability =>
      ((read_reg nextPC_ref)  : M (mword 64)) >>= fun w__6 : mword 64 =>
      let '(success, linkCap) := setCapAddr w__5 w__6 in
      assert_exp' success "Link cap should always be representable." >>= fun _ =>
      (writeCapReg (projT1 (regbits_to_regno cd)) linkCap) >>
      (execute_branch_pcc cb_val) >> returnm (true  : bool))
    : M (bool).

Definition execute_CIncOffsetImmediate (cd : mword 5) (cb : mword 5) (imm : mword 12) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   let imm64 : bits 64 := EXTS 64 imm in
   (if ((andb cb_val.(Capability_tag) cb_val.(Capability_sealed))) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else
      let '(success, newCap) := incCapOffset cb_val imm64 in
      (if sumbool_of_bool (success) then
         (writeCapReg (projT1 (regbits_to_regno cd)) newCap)
          : M (unit)
       else
         (writeCapReg (projT1 (regbits_to_regno cd))
            (int_to_cap (add_vec (to_bits 64 (projT1 (getCapBase cb_val))) imm64)))
          : M (unit)) >>
      returnm (true
       : bool))
    : M (bool).

Definition execute_CIncOffset (cd : mword 5) (cb : mword 5) (rt : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (rX (projT1 (regbits_to_regno rt))) >>= fun rt_val =>
   (if ((andb cb_val.(Capability_tag)
           (andb cb_val.(Capability_sealed)
              (neq_vec rt_val
                 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0]
                   : mword 64))))) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else
      let '(success, newCap) := incCapOffset cb_val rt_val in
      (if sumbool_of_bool (success) then
         (writeCapReg (projT1 (regbits_to_regno cd)) newCap)
          : M (unit)
       else
         (writeCapReg (projT1 (regbits_to_regno cd))
            (int_to_cap (add_vec (to_bits 64 (projT1 (getCapBase cb_val))) rt_val)))
          : M (unit)) >>
      returnm (true
       : bool))
    : M (bool).

Definition execute_CGetType (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd))
      (if (capVal.(Capability_sealed)) then EXTZ 64 capVal.(Capability_otype)
       else
         (vec_of_bits [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                       B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                       B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                       B1]
           : mword 64))) >>
   returnm (true
    : bool).

Definition execute_CGetTag (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd)) (EXTZ 64 (bool_to_bits capVal.(Capability_tag)))) >>
   returnm (true
    : bool).

Definition execute_CGetSealed (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd)) (EXTZ 64 (bool_to_bits capVal.(Capability_sealed)))) >>
   returnm (true
    : bool).

Definition execute_CGetPerm (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd)) (EXTZ 64 (getCapPerms capVal))) >> returnm (true  : bool).

Definition execute_CGetOffset (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd)) (to_bits 64 (projT1 (getCapOffset capVal)))) >>
   returnm (true
    : bool).

Definition execute_CGetLen (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   let 'len65 := projT1 (getCapLength capVal) in
   (wX (projT1 (regbits_to_regno rd))
      (to_bits 64 (if sumbool_of_bool ((Z.gtb len65 MAX_U64)) then MAX_U64 else len65))) >>
   returnm (true
    : bool).

Definition execute_CGetBase (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd)) (to_bits 64 (projT1 (getCapBase capVal)))) >>
   returnm (true
    : bool).

Definition execute_CGetAddr (rd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun capVal =>
   (wX (projT1 (regbits_to_regno rd)) (to_bits 64 (projT1 (getCapCursor capVal)))) >>
   returnm (true
    : bool).

Definition execute_CFromPtr (cd : mword 5) (cb : mword 5) (rt : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (rX (projT1 (regbits_to_regno rt))) >>= fun rt_val =>
   (if ((eq_vec rt_val
           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                         B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                         B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                         B0]
             : mword 64))) then
      (writeCapReg (projT1 (regbits_to_regno cd)) null_cap) >>
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((negb cb_val.(Capability_tag))) then
      (raise_c2_exception CapEx_TagViolation cb)
       : M (bool)
    else if (cb_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else
      let '(success, newCap) := setCapOffset cb_val rt_val in
      (if sumbool_of_bool (success) then
         (writeCapReg (projT1 (regbits_to_regno cd)) newCap)
          : M (unit)
       else
         (writeCapReg (projT1 (regbits_to_regno cd))
            (int_to_cap (add_vec (to_bits 64 (projT1 (getCapBase cb_val))) rt_val)))
          : M (unit)) >>
      returnm (true
       : bool))
    : M (bool).

Definition execute_CClearTag (cd : mword 5) (cb : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (writeCapReg (projT1 (regbits_to_regno cd)) {[ cb_val with Capability_tag := false ]}) >>
   returnm (true
    : bool).

Definition execute_CCall (cs : mword 5) (cb : mword 5) (b__0 : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cs))) >>= fun cs_val =>
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   let 'cs_cursor := projT1 (getCapCursor cs_val) in
   (if ((negb cs_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cs)  : M (bool)
    else if ((negb cb_val.(Capability_tag))) then
      (raise_c2_exception CapEx_TagViolation cb)
       : M (bool)
    else if ((negb cs_val.(Capability_sealed))) then
      (raise_c2_exception CapEx_SealViolation cs)
       : M (bool)
    else if ((negb cb_val.(Capability_sealed))) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else if ((neq_vec cs_val.(Capability_otype) cb_val.(Capability_otype))) then
      (raise_c2_exception CapEx_TypeViolation cs)
       : M (bool)
    else if ((negb cs_val.(Capability_permit_ccall))) then
      (raise_c2_exception CapEx_PermitCCallViolation cs)
       : M (bool)
    else if ((negb cb_val.(Capability_permit_ccall))) then
      (raise_c2_exception CapEx_PermitCCallViolation cb)
       : M (bool)
    else if ((negb cs_val.(Capability_permit_execute))) then
      (raise_c2_exception CapEx_PermitExecuteViolation cs)
       : M (bool)
    else if (cb_val.(Capability_permit_execute)) then
      (raise_c2_exception CapEx_PermitExecuteViolation cb)
       : M (bool)
    else if sumbool_of_bool ((Z.ltb cs_cursor (projT1 (getCapBase cs_val)))) then
      (raise_c2_exception CapEx_LengthViolation cs)
       : M (bool)
    else if sumbool_of_bool ((Z.geb cs_cursor (projT1 (getCapTop cs_val)))) then
      (raise_c2_exception CapEx_LengthViolation cs)
       : M (bool)
    else
      let C26 := unsealCap cb_val in
      write_reg nextPC_ref cs_val.(Capability_address) >>
      write_reg nextPCC_ref (unsealCap cs_val) >> returnm (true  : bool))
    : M (bool).

Definition execute_CAndPerm (cd : mword 5) (cb : mword 5) (rt : mword 5) 
: M (bool) :=
   
   let '_ := (checkCP2usable tt)  : unit in
   (readCapReg (projT1 (regbits_to_regno cb))) >>= fun cb_val =>
   (rX (projT1 (regbits_to_regno rt))) >>= fun rt_val =>
   (if ((negb cb_val.(Capability_tag))) then (raise_c2_exception CapEx_TagViolation cb)  : M (bool)
    else if (cb_val.(Capability_sealed)) then
      (raise_c2_exception CapEx_SealViolation cb)
       : M (bool)
    else
      let perms := getCapPerms cb_val in
      (setCapPerms cb_val (and_vec perms (subrange_vec_dec rt_val 30 0))) >>= fun newCap =>
      (writeCapReg (projT1 (regbits_to_regno cd)) newCap) >> returnm (true  : bool))
    : M (bool).

Definition execute_BTYPE (imm : mword 13) (rs2 : mword 5) (rs1 : mword 5) (op : bop) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun rs1_val =>
   (rX (projT1 (regbits_to_regno rs2))) >>= fun rs2_val =>
   let taken : bool :=
     match op with
     | RISCV_BEQ => eq_vec rs1_val rs2_val
     | RISCV_BNE => neq_vec rs1_val rs2_val
     | RISCV_BLT => zopz0zI_s rs1_val rs2_val
     | RISCV_BGE => zopz0zKzJ_s rs1_val rs2_val
     | RISCV_BLTU => zopz0zI_u rs1_val rs2_val
     | RISCV_BGEU => zopz0zKzJ_u rs1_val rs2_val
     end in
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   let newPC := add_vec w__0 (EXTS 64 imm) in
   (if sumbool_of_bool (taken) then
      read_reg PCC_ref >>= fun w__1 : Capability =>
      (if ((negb (inCapBounds w__1 newPC min_inst_bytes))) then
         (raise_c2_exception6 CapEx_LengthViolation (vec_of_bits [B1;B0;B0;B0;B0;B0]  : mword 6))
          : M (bool)
       else
         (and_boolM ((bit_to_bool (access_vec_dec newPC 1))  : M (bool))
            (returnm ((negb (haveRVC tt))
              : bool))) >>= fun w__4 : bool =>
         (if sumbool_of_bool (w__4) then
            (handle_mem_exception newPC E_Fetch_Addr_Align) >>
            returnm (projT1
            (build_ex
            false
             : {_bool : bool & ArithFact (not (_bool = true))}))
          else
            write_reg nextPC_ref newPC >>
            returnm (projT1
            (build_ex
            true
             : {_bool : bool & ArithFact (_bool = true)})))
          : M (bool))
       : M (bool)
    else returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)})))
    : M (bool).

Definition execute_ADDIW (imm : mword 12) (rs1 : mword 5) (rd : mword 5) 
: M (bool) :=
   
   (rX (projT1 (regbits_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let result : xlenbits := add_vec (EXTS 64 imm) w__0 in
   (wX (projT1 (regbits_to_regno rd)) (EXTS 64 (subrange_vec_dec result 31 0))) >>
   returnm (true
    : bool).

Definition execute (merge_var : ast) 
: M (bool) :=
   
   (match merge_var with
    | UTYPE (imm,rd,op) => (execute_UTYPE imm rd op)  : M (bool)
    | RISCV_JAL (imm,rd) => (execute_RISCV_JAL imm rd)  : M (bool)
    | BTYPE (imm,rs2,rs1,op) => (execute_BTYPE imm rs2 rs1 op)  : M (bool)
    | ITYPE (imm,rs1,rd,op) => (execute_ITYPE imm rs1 rd op)  : M (bool)
    | SHIFTIOP (shamt,rs1,rd,op) => (execute_SHIFTIOP shamt rs1 rd op)  : M (bool)
    | RTYPE (rs2,rs1,rd,op) => (execute_RTYPE rs2 rs1 rd op)  : M (bool)
    | ADDIW (imm,rs1,rd) => (execute_ADDIW imm rs1 rd)  : M (bool)
    | SHIFTW (shamt,rs1,rd,op) => (execute_SHIFTW shamt rs1 rd op)  : M (bool)
    | RTYPEW (rs2,rs1,rd,op) => (execute_RTYPEW rs2 rs1 rd op)  : M (bool)
    | SHIFTIWOP (shamt,rs1,rd,op) => (execute_SHIFTIWOP shamt rs1 rd op)  : M (bool)
    | CGetPerm (rd,cb) => (execute_CGetPerm rd cb)  : M (bool)
    | CGetType (rd,cb) => (execute_CGetType rd cb)  : M (bool)
    | CGetBase (rd,cb) => (execute_CGetBase rd cb)  : M (bool)
    | CGetOffset (rd,cb) => (execute_CGetOffset rd cb)  : M (bool)
    | CGetLen (rd,cb) => (execute_CGetLen rd cb)  : M (bool)
    | CGetTag (rd,cb) => (execute_CGetTag rd cb)  : M (bool)
    | CGetSealed (rd,cb) => (execute_CGetSealed rd cb)  : M (bool)
    | CGetAddr (rd,cb) => (execute_CGetAddr rd cb)  : M (bool)
    | CAndPerm (cd,cb,rt) => (execute_CAndPerm cd cb rt)  : M (bool)
    | CToPtr (rd,cb,ct) => (execute_CToPtr rd cb ct)  : M (bool)
    | CIncOffset (cd,cb,rt) => (execute_CIncOffset cd cb rt)  : M (bool)
    | CIncOffsetImmediate (cd,cb,imm) => (execute_CIncOffsetImmediate cd cb imm)  : M (bool)
    | CSetOffset (cd,cb,rt) => (execute_CSetOffset cd cb rt)  : M (bool)
    | CSetBounds (cd,cb,rt) => (execute_CSetBounds cd cb rt)  : M (bool)
    | CSetBoundsImmediate (cd,cb,imm) => (execute_CSetBoundsImmediate cd cb imm)  : M (bool)
    | CSetBoundsExact (cd,cb,rt) => (execute_CSetBoundsExact cd cb rt)  : M (bool)
    | CClearTag (cd,cb) => (execute_CClearTag cd cb)  : M (bool)
    | CMove (cd,cb) => (execute_CMove cd cb)  : M (bool)
    | CFromPtr (cd,cb,rt) => (execute_CFromPtr cd cb rt)  : M (bool)
    | CSeal (cd,cs,ct) => (execute_CSeal cd cs ct)  : M (bool)
    | CUnseal (cd,cs,ct) => (execute_CUnseal cd cs ct)  : M (bool)
    | CCall (cs,cb,b__0) => (execute_CCall cs cb b__0)  : M (bool)
    | CJALR (cd,cb) => (execute_CJALR cd cb)  : M (bool)
    | CLoadCap (rd,cs,is_unsigned,width) => (execute_CLoadCap rd cs is_unsigned width)  : M (bool)
    | CLoadCapCap (rd,cs) => (execute_CLoadCapCap rd cs)  : M (bool)
    | CStoreCap (rs,cs,width) => (execute_CStoreCap rs cs width)  : M (bool)
    | CStoreCapCap (rs,cs) => (execute_CStoreCapCap rs cs)  : M (bool)
    | RISCV_JALR (imm,rs1,rd) => (execute_RISCV_JALR imm rs1 rd)  : M (bool)
    | ILLEGAL (s) => (execute_ILLEGAL s)  : M (bool)
    | C_ILLEGAL (s) => (execute_C_ILLEGAL s)  : M (bool)
    | _ => exit tt  : M (bool)
    end)
    : M (bool).

Definition assembly_forwards (arg_ : ast) 
: M (string) :=
   
   (match arg_ with
    | UTYPE (imm,rd,op) =>
       returnm ((string_append (utype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | RISCV_JAL (imm,rd) =>
       returnm ((string_append "jal"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | RISCV_JALR (imm,rs1,rd) =>
       returnm ((string_append "jalr"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | BTYPE (imm,rs2,rs1,op) =>
       returnm ((string_append (btype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rs1)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs2)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | ITYPE (imm,rs1,rd,op) =>
       returnm ((string_append (itype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | SHIFTIOP (shamt,rs1,rd,op) =>
       returnm ((string_append (shiftiop_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (decimal_string_of_bits shamt) ""))))))
        : string)
    | RTYPE (rs2,rs1,rd,op) =>
       returnm ((string_append (rtype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rs2) "")))))))
        : string)
    | ADDIW (imm,rs1,rd) =>
       returnm ((string_append "addiw"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | SHIFTW (shamt,rs1,rd,op) =>
       returnm ((string_append (shiftw_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits shamt) "")))))))
        : string)
    | RTYPEW (rs2,rs1,rd,op) =>
       returnm ((string_append (rtypew_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rs2) "")))))))
        : string)
    | SHIFTIWOP (shamt,rs1,rd,op) =>
       returnm ((string_append (shiftiwop_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards rs1)
                               (string_append (decimal_string_of_bits shamt) ""))))))
        : string)
    | CGetPerm (rd,cb) =>
       returnm ((string_append "CGetPerm"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetType (rd,cb) =>
       returnm ((string_append "CGetType"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetBase (rd,cb) =>
       returnm ((string_append "CGetBase"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetLen (rd,cb) =>
       returnm ((string_append "CGetLen"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetTag (rd,cb) =>
       returnm ((string_append "CGetTag"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetSealed (rd,cb) =>
       returnm ((string_append "CGetSealed"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetOffset (rd,cb) =>
       returnm ((string_append "CGetOffset"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CGetAddr (rd,cb) =>
       returnm ((string_append "CGetAddr"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CMove (cd,cs) =>
       returnm ((string_append "CMove"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cs) "")))))
        : string)
    | CClearTag (cd,cs) =>
       returnm ((string_append "CClearTag"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cs) "")))))
        : string)
    | CJALR (b__0,cb) =>
       returnm ((if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                                        (projT1
                                         (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)))))
                 then
                   string_append "CJR"
                     (string_append (spc_forwards tt) (string_append (reg_name_forwards cb) ""))
                 else
                   string_append "CJALR"
                     (string_append (spc_forwards tt)
                        (string_append (reg_name_forwards b__0)
                           (string_append (sep_forwards tt)
                              (string_append (reg_name_forwards cb) "")))))
        : string)
    | CSeal (cd,cs,ct) =>
       returnm ((string_append "CSeal"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards ct) "")))))))
        : string)
    | CUnseal (cd,cs,ct) =>
       returnm ((string_append "CUnseal"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards ct) "")))))))
        : string)
    | CAndPerm (cd,cs,rt) =>
       returnm ((string_append "CAndPerm"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rt) "")))))))
        : string)
    | CSetOffset (cd,cs,rt) =>
       returnm ((string_append "CSetOffset"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rt) "")))))))
        : string)
    | CIncOffset (cd,cs,rt) =>
       returnm ((string_append "CIncOffset"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rt) "")))))))
        : string)
    | CSetBounds (cd,cs,rt) =>
       returnm ((string_append "CSetBounds"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rt) "")))))))
        : string)
    | CSetBoundsExact (cd,cs,rt) =>
       returnm ((string_append "CSetBoundsExact"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cs)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rt) "")))))))
        : string)
    | CToPtr (rd,cb,cs) =>
       returnm ((string_append "CToPtr"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cb)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards cs) "")))))))
        : string)
    | CFromPtr (cd,cb,rs) =>
       returnm ((string_append "CFromPtr"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cb)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rs) "")))))))
        : string)
    | CCall (cs,cb,b__1) =>
       returnm ((string_append "CCallFast"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cs)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards cb) "")))))
        : string)
    | CIncOffsetImmediate (cd,cb,imm12) =>
       returnm ((string_append "CIncOffsetImmediate"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cb)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm12) "")))))))
        : string)
    | CSetBoundsImmediate (cd,cb,imm12) =>
       returnm ((string_append "CSetBoundsImmediate"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards cd)
                         (string_append (sep_forwards tt)
                            (string_append (reg_name_forwards cb)
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm12) "")))))))
        : string)
    | CLoadCap (rd,cs,u,w) =>
       returnm ((string_append "l"
                   (string_append (size_mnemonic_forwards w)
                      (string_append (maybe_u_forwards u)
                         (string_append "Cap"
                            (string_append (spc_forwards tt)
                               (string_append (reg_name_forwards rd)
                                  (string_append (sep_forwards tt)
                                     (string_append (reg_name_forwards cs) ""))))))))
        : string)
    | CStoreCap (rd,rs,w) =>
       returnm ((string_append "s"
                   (string_append (size_mnemonic_forwards w)
                      (string_append "Cap"
                         (string_append (spc_forwards tt)
                            (string_append (reg_name_forwards rd)
                               (string_append (sep_forwards tt)
                                  (string_append (reg_name_forwards rs) "")))))))
        : string)
    | CStoreCapCap (rd,rs) =>
       returnm ((string_append "lqCap"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards rs) "")))))
        : string)
    | CLoadCapCap (rd,rs) =>
       returnm ((string_append "sqCap"
                   (string_append (spc_forwards tt)
                      (string_append (reg_name_forwards rd)
                         (string_append (sep_forwards tt) (string_append (reg_name_forwards rs) "")))))
        : string)
    | ILLEGAL (s) =>
       returnm ((string_append "illegal"
                   (string_append (spc_forwards tt) (string_append (decimal_string_of_bits s) "")))
        : string)
    | C_ILLEGAL (s) =>
       returnm ((string_append "c.illegal"
                   (string_append (spc_forwards tt) (string_append (decimal_string_of_bits s) "")))
        : string)
    | _ => exit tt  : M (string)
    end)
    : M (string).

Definition _s924_ (_s925_ : string) 
: M (option (mword 16)) :=
   
   let _s926_ := _s925_ in
   (if ((string_startswith _s926_ "c.illegal")) then
      (match (string_drop _s926_ (projT1 (string_length "c.illegal"))) with
       | _s927_ =>
          (spc_matches_prefix _s927_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some (tt,(existT _ _s928_ _)) =>
                       match (string_drop _s927_ _s928_) with
                       | _s929_ =>
                          match (hex_bits_16_matches_prefix _s929_) with
                          | Some (s,(existT _ _s930_ _)) =>
                             let p0_ := string_drop _s929_ _s930_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 16))
       end)
       : M (option (mword 16))
    else returnm (None  : option (mword 16)))
    : M (option (mword 16)).

Definition _s916_ (_s917_ : string) 
: M (option (mword 32)) :=
   
   let _s918_ := _s917_ in
   (if ((string_startswith _s918_ "illegal")) then
      (match (string_drop _s918_ (projT1 (string_length "illegal"))) with
       | _s919_ =>
          (spc_matches_prefix _s919_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some (tt,(existT _ _s920_ _)) =>
                       match (string_drop _s919_ _s920_) with
                       | _s921_ =>
                          match (hex_bits_32_matches_prefix _s921_) with
                          | Some (s,(existT _ _s922_ _)) =>
                             let p0_ := string_drop _s921_ _s922_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 32))
       end)
       : M (option (mword 32))
    else returnm (None  : option (mword 32)))
    : M (option (mword 32)).

Definition _s904_ (_s905_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s906_ := _s905_ in
   (if ((string_startswith _s906_ "sqCap")) then
      (match (string_drop _s906_ (projT1 (string_length "sqCap"))) with
       | _s907_ =>
          (spc_matches_prefix _s907_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s908_ _)) =>
              (match (string_drop _s907_ _s908_) with
               | _s909_ =>
                  (reg_name_matches_prefix _s909_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s910_ _)) =>
                      (match (string_drop _s909_ _s910_) with
                       | _s911_ =>
                          (sep_matches_prefix _s911_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s912_ _)) =>
                              (match (string_drop _s911_ _s912_) with
                               | _s913_ =>
                                  (reg_name_matches_prefix _s913_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (rs,(existT _ _s914_ _)) =>
                                               let p0_ := string_drop _s913_ _s914_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, rs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s892_ (_s893_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s894_ := _s893_ in
   (if ((string_startswith _s894_ "lqCap")) then
      (match (string_drop _s894_ (projT1 (string_length "lqCap"))) with
       | _s895_ =>
          (spc_matches_prefix _s895_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s896_ _)) =>
              (match (string_drop _s895_ _s896_) with
               | _s897_ =>
                  (reg_name_matches_prefix _s897_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s898_ _)) =>
                      (match (string_drop _s897_ _s898_) with
                       | _s899_ =>
                          (sep_matches_prefix _s899_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s900_ _)) =>
                              (match (string_drop _s899_ _s900_) with
                               | _s901_ =>
                                  (reg_name_matches_prefix _s901_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (rs,(existT _ _s902_ _)) =>
                                               let p0_ := string_drop _s901_ _s902_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, rs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s877_ (_s878_ : string) 
: M (option ((word_width * mword 5 * mword 5))) :=
   
   let _s879_ := _s878_ in
   (if ((string_startswith _s879_ "s")) then
      (match (string_drop _s879_ (projT1 (string_length "s"))) with
       | _s880_ =>
          (size_mnemonic_matches_prefix _s880_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some (w,(existT _ _s881_ _)) =>
              let _s882_ := string_drop _s880_ _s881_ in
              (if ((string_startswith _s882_ "Cap")) then
                 (match (string_drop _s882_ (projT1 (string_length "Cap"))) with
                  | _s883_ =>
                     (spc_matches_prefix _s883_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some (tt,(existT _ _s884_ _)) =>
                         (match (string_drop _s883_ _s884_) with
                          | _s885_ =>
                             (reg_name_matches_prefix _s885_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some (rd,(existT _ _s886_ _)) =>
                                 (match (string_drop _s885_ _s886_) with
                                  | _s887_ =>
                                     (sep_matches_prefix _s887_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some (tt,(existT _ _s888_ _)) =>
                                         (match (string_drop _s887_ _s888_) with
                                          | _s889_ =>
                                             (reg_name_matches_prefix _s889_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             returnm ((match w__4 with
                                                       | Some (rs,(existT _ _s890_ _)) =>
                                                          let p0_ := string_drop _s889_ _s890_ in
                                                          if ((generic_eq p0_ "")) then
                                                            Some
                                                              ((w, rd, rs))
                                                          else None
                                                       | _ => None
                                                       end)
                                              : option ((word_width * mword 5 * mword 5)))
                                          end)
                                          : M (option ((word_width * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None  : option ((word_width * mword 5 * mword 5)))
                                      end)
                                      : M (option ((word_width * mword 5 * mword 5)))
                                  end)
                                  : M (option ((word_width * mword 5 * mword 5)))
                              | _ => returnm (None  : option ((word_width * mword 5 * mword 5)))
                              end)
                              : M (option ((word_width * mword 5 * mword 5)))
                          end)
                          : M (option ((word_width * mword 5 * mword 5)))
                      | _ => returnm (None  : option ((word_width * mword 5 * mword 5)))
                      end)
                      : M (option ((word_width * mword 5 * mword 5)))
                  end)
                  : M (option ((word_width * mword 5 * mword 5)))
               else returnm (None  : option ((word_width * mword 5 * mword 5))))
               : M (option ((word_width * mword 5 * mword 5)))
           | _ => returnm (None  : option ((word_width * mword 5 * mword 5)))
           end)
           : M (option ((word_width * mword 5 * mword 5)))
       end)
       : M (option ((word_width * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * mword 5 * mword 5))))
    : M (option ((word_width * mword 5 * mword 5))).

Definition _s860_ (_s861_ : string) 
: M (option ((word_width * bool * mword 5 * mword 5))) :=
   
   let _s862_ := _s861_ in
   (if ((string_startswith _s862_ "l")) then
      (match (string_drop _s862_ (projT1 (string_length "l"))) with
       | _s863_ =>
          (size_mnemonic_matches_prefix _s863_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some (w,(existT _ _s864_ _)) =>
              (match (string_drop _s863_ _s864_) with
               | _s865_ =>
                  (maybe_u_matches_prefix _s865_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (u,(existT _ _s866_ _)) =>
                      let _s867_ := string_drop _s865_ _s866_ in
                      (if ((string_startswith _s867_ "Cap")) then
                         (match (string_drop _s867_ (projT1 (string_length "Cap"))) with
                          | _s868_ =>
                             (spc_matches_prefix _s868_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some (tt,(existT _ _s869_ _)) =>
                                 (match (string_drop _s868_ _s869_) with
                                  | _s870_ =>
                                     (reg_name_matches_prefix _s870_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some (rd,(existT _ _s871_ _)) =>
                                         (match (string_drop _s870_ _s871_) with
                                          | _s872_ =>
                                             (sep_matches_prefix _s872_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some (tt,(existT _ _s873_ _)) =>
                                                 (match (string_drop _s872_ _s873_) with
                                                  | _s874_ =>
                                                     (reg_name_matches_prefix _s874_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     returnm ((match w__5 with
                                                               | Some (cs,(existT _ _s875_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s874_ _s875_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((w, u, rd, cs))
                                                                  else None
                                                               | _ => None
                                                               end)
                                                      : option ((word_width * bool * mword 5 * mword 5)))
                                                  end)
                                                  : M (option ((word_width * bool * mword 5 * mword 5)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((word_width * bool * mword 5 * mword 5)))
                                              end)
                                              : M (option ((word_width * bool * mword 5 * mword 5)))
                                          end)
                                          : M (option ((word_width * bool * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None
                                          : option ((word_width * bool * mword 5 * mword 5)))
                                      end)
                                      : M (option ((word_width * bool * mword 5 * mword 5)))
                                  end)
                                  : M (option ((word_width * bool * mword 5 * mword 5)))
                              | _ =>
                                 returnm (None  : option ((word_width * bool * mword 5 * mword 5)))
                              end)
                              : M (option ((word_width * bool * mword 5 * mword 5)))
                          end)
                          : M (option ((word_width * bool * mword 5 * mword 5)))
                       else returnm (None  : option ((word_width * bool * mword 5 * mword 5))))
                       : M (option ((word_width * bool * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((word_width * bool * mword 5 * mword 5)))
                   end)
                   : M (option ((word_width * bool * mword 5 * mword 5)))
               end)
               : M (option ((word_width * bool * mword 5 * mword 5)))
           | _ => returnm (None  : option ((word_width * bool * mword 5 * mword 5)))
           end)
           : M (option ((word_width * bool * mword 5 * mword 5)))
       end)
       : M (option ((word_width * bool * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * bool * mword 5 * mword 5))))
    : M (option ((word_width * bool * mword 5 * mword 5))).

Definition _s844_ (_s845_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s846_ := _s845_ in
   (if ((string_startswith _s846_ "CSetBoundsImmediate")) then
      (match (string_drop _s846_ (projT1 (string_length "CSetBoundsImmediate"))) with
       | _s847_ =>
          (spc_matches_prefix _s847_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s848_ _)) =>
              (match (string_drop _s847_ _s848_) with
               | _s849_ =>
                  (reg_name_matches_prefix _s849_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s850_ _)) =>
                      (match (string_drop _s849_ _s850_) with
                       | _s851_ =>
                          (sep_matches_prefix _s851_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s852_ _)) =>
                              (match (string_drop _s851_ _s852_) with
                               | _s853_ =>
                                  (reg_name_matches_prefix _s853_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s854_ _)) =>
                                      (match (string_drop _s853_ _s854_) with
                                       | _s855_ =>
                                          (sep_matches_prefix _s855_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s856_ _)) =>
                                                       match (string_drop _s855_ _s856_) with
                                                       | _s857_ =>
                                                          match (hex_bits_12_matches_prefix _s857_) with
                                                          | Some (imm12,(existT _ _s858_ _)) =>
                                                             let p0_ := string_drop _s857_ _s858_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((cd, cb, imm12))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s828_ (_s829_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s830_ := _s829_ in
   (if ((string_startswith _s830_ "CIncOffsetImmediate")) then
      (match (string_drop _s830_ (projT1 (string_length "CIncOffsetImmediate"))) with
       | _s831_ =>
          (spc_matches_prefix _s831_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s832_ _)) =>
              (match (string_drop _s831_ _s832_) with
               | _s833_ =>
                  (reg_name_matches_prefix _s833_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s834_ _)) =>
                      (match (string_drop _s833_ _s834_) with
                       | _s835_ =>
                          (sep_matches_prefix _s835_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s836_ _)) =>
                              (match (string_drop _s835_ _s836_) with
                               | _s837_ =>
                                  (reg_name_matches_prefix _s837_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s838_ _)) =>
                                      (match (string_drop _s837_ _s838_) with
                                       | _s839_ =>
                                          (sep_matches_prefix _s839_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s840_ _)) =>
                                                       match (string_drop _s839_ _s840_) with
                                                       | _s841_ =>
                                                          match (hex_bits_12_matches_prefix _s841_) with
                                                          | Some (imm12,(existT _ _s842_ _)) =>
                                                             let p0_ := string_drop _s841_ _s842_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((cd, cb, imm12))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s816_ (_s817_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s818_ := _s817_ in
   (if ((string_startswith _s818_ "CCallFast")) then
      (match (string_drop _s818_ (projT1 (string_length "CCallFast"))) with
       | _s819_ =>
          (spc_matches_prefix _s819_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s820_ _)) =>
              (match (string_drop _s819_ _s820_) with
               | _s821_ =>
                  (reg_name_matches_prefix _s821_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cs,(existT _ _s822_ _)) =>
                      (match (string_drop _s821_ _s822_) with
                       | _s823_ =>
                          (sep_matches_prefix _s823_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s824_ _)) =>
                              (match (string_drop _s823_ _s824_) with
                               | _s825_ =>
                                  (reg_name_matches_prefix _s825_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s826_ _)) =>
                                               let p0_ := string_drop _s825_ _s826_ in
                                               if ((generic_eq p0_ "")) then Some ((cs, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s800_ (_s801_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s802_ := _s801_ in
   (if ((string_startswith _s802_ "CFromPtr")) then
      (match (string_drop _s802_ (projT1 (string_length "CFromPtr"))) with
       | _s803_ =>
          (spc_matches_prefix _s803_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s804_ _)) =>
              (match (string_drop _s803_ _s804_) with
               | _s805_ =>
                  (reg_name_matches_prefix _s805_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s806_ _)) =>
                      (match (string_drop _s805_ _s806_) with
                       | _s807_ =>
                          (sep_matches_prefix _s807_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s808_ _)) =>
                              (match (string_drop _s807_ _s808_) with
                               | _s809_ =>
                                  (reg_name_matches_prefix _s809_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s810_ _)) =>
                                      (match (string_drop _s809_ _s810_) with
                                       | _s811_ =>
                                          (sep_matches_prefix _s811_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s812_ _)) =>
                                              (match (string_drop _s811_ _s812_) with
                                               | _s813_ =>
                                                  (reg_name_matches_prefix _s813_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rs,(existT _ _s814_ _)) =>
                                                               let p0_ := string_drop _s813_ _s814_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cb, rs))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s784_ (_s785_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s786_ := _s785_ in
   (if ((string_startswith _s786_ "CToPtr")) then
      (match (string_drop _s786_ (projT1 (string_length "CToPtr"))) with
       | _s787_ =>
          (spc_matches_prefix _s787_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s788_ _)) =>
              (match (string_drop _s787_ _s788_) with
               | _s789_ =>
                  (reg_name_matches_prefix _s789_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s790_ _)) =>
                      (match (string_drop _s789_ _s790_) with
                       | _s791_ =>
                          (sep_matches_prefix _s791_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s792_ _)) =>
                              (match (string_drop _s791_ _s792_) with
                               | _s793_ =>
                                  (reg_name_matches_prefix _s793_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s794_ _)) =>
                                      (match (string_drop _s793_ _s794_) with
                                       | _s795_ =>
                                          (sep_matches_prefix _s795_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s796_ _)) =>
                                              (match (string_drop _s795_ _s796_) with
                                               | _s797_ =>
                                                  (reg_name_matches_prefix _s797_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (cs,(existT _ _s798_ _)) =>
                                                               let p0_ := string_drop _s797_ _s798_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rd, cb, cs))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s768_ (_s769_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s770_ := _s769_ in
   (if ((string_startswith _s770_ "CSetBoundsExact")) then
      (match (string_drop _s770_ (projT1 (string_length "CSetBoundsExact"))) with
       | _s771_ =>
          (spc_matches_prefix _s771_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s772_ _)) =>
              (match (string_drop _s771_ _s772_) with
               | _s773_ =>
                  (reg_name_matches_prefix _s773_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s774_ _)) =>
                      (match (string_drop _s773_ _s774_) with
                       | _s775_ =>
                          (sep_matches_prefix _s775_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s776_ _)) =>
                              (match (string_drop _s775_ _s776_) with
                               | _s777_ =>
                                  (reg_name_matches_prefix _s777_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s778_ _)) =>
                                      (match (string_drop _s777_ _s778_) with
                                       | _s779_ =>
                                          (sep_matches_prefix _s779_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s780_ _)) =>
                                              (match (string_drop _s779_ _s780_) with
                                               | _s781_ =>
                                                  (reg_name_matches_prefix _s781_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s782_ _)) =>
                                                               let p0_ := string_drop _s781_ _s782_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s752_ (_s753_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s754_ := _s753_ in
   (if ((string_startswith _s754_ "CSetBounds")) then
      (match (string_drop _s754_ (projT1 (string_length "CSetBounds"))) with
       | _s755_ =>
          (spc_matches_prefix _s755_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s756_ _)) =>
              (match (string_drop _s755_ _s756_) with
               | _s757_ =>
                  (reg_name_matches_prefix _s757_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s758_ _)) =>
                      (match (string_drop _s757_ _s758_) with
                       | _s759_ =>
                          (sep_matches_prefix _s759_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s760_ _)) =>
                              (match (string_drop _s759_ _s760_) with
                               | _s761_ =>
                                  (reg_name_matches_prefix _s761_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s762_ _)) =>
                                      (match (string_drop _s761_ _s762_) with
                                       | _s763_ =>
                                          (sep_matches_prefix _s763_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s764_ _)) =>
                                              (match (string_drop _s763_ _s764_) with
                                               | _s765_ =>
                                                  (reg_name_matches_prefix _s765_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s766_ _)) =>
                                                               let p0_ := string_drop _s765_ _s766_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s736_ (_s737_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s738_ := _s737_ in
   (if ((string_startswith _s738_ "CIncOffset")) then
      (match (string_drop _s738_ (projT1 (string_length "CIncOffset"))) with
       | _s739_ =>
          (spc_matches_prefix _s739_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s740_ _)) =>
              (match (string_drop _s739_ _s740_) with
               | _s741_ =>
                  (reg_name_matches_prefix _s741_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s742_ _)) =>
                      (match (string_drop _s741_ _s742_) with
                       | _s743_ =>
                          (sep_matches_prefix _s743_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s744_ _)) =>
                              (match (string_drop _s743_ _s744_) with
                               | _s745_ =>
                                  (reg_name_matches_prefix _s745_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s746_ _)) =>
                                      (match (string_drop _s745_ _s746_) with
                                       | _s747_ =>
                                          (sep_matches_prefix _s747_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s748_ _)) =>
                                              (match (string_drop _s747_ _s748_) with
                                               | _s749_ =>
                                                  (reg_name_matches_prefix _s749_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s750_ _)) =>
                                                               let p0_ := string_drop _s749_ _s750_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s720_ (_s721_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s722_ := _s721_ in
   (if ((string_startswith _s722_ "CSetOffset")) then
      (match (string_drop _s722_ (projT1 (string_length "CSetOffset"))) with
       | _s723_ =>
          (spc_matches_prefix _s723_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s724_ _)) =>
              (match (string_drop _s723_ _s724_) with
               | _s725_ =>
                  (reg_name_matches_prefix _s725_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s726_ _)) =>
                      (match (string_drop _s725_ _s726_) with
                       | _s727_ =>
                          (sep_matches_prefix _s727_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s728_ _)) =>
                              (match (string_drop _s727_ _s728_) with
                               | _s729_ =>
                                  (reg_name_matches_prefix _s729_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s730_ _)) =>
                                      (match (string_drop _s729_ _s730_) with
                                       | _s731_ =>
                                          (sep_matches_prefix _s731_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s732_ _)) =>
                                              (match (string_drop _s731_ _s732_) with
                                               | _s733_ =>
                                                  (reg_name_matches_prefix _s733_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s734_ _)) =>
                                                               let p0_ := string_drop _s733_ _s734_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s704_ (_s705_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s706_ := _s705_ in
   (if ((string_startswith _s706_ "CAndPerm")) then
      (match (string_drop _s706_ (projT1 (string_length "CAndPerm"))) with
       | _s707_ =>
          (spc_matches_prefix _s707_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s708_ _)) =>
              (match (string_drop _s707_ _s708_) with
               | _s709_ =>
                  (reg_name_matches_prefix _s709_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s710_ _)) =>
                      (match (string_drop _s709_ _s710_) with
                       | _s711_ =>
                          (sep_matches_prefix _s711_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s712_ _)) =>
                              (match (string_drop _s711_ _s712_) with
                               | _s713_ =>
                                  (reg_name_matches_prefix _s713_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s714_ _)) =>
                                      (match (string_drop _s713_ _s714_) with
                                       | _s715_ =>
                                          (sep_matches_prefix _s715_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s716_ _)) =>
                                              (match (string_drop _s715_ _s716_) with
                                               | _s717_ =>
                                                  (reg_name_matches_prefix _s717_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s718_ _)) =>
                                                               let p0_ := string_drop _s717_ _s718_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s688_ (_s689_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s690_ := _s689_ in
   (if ((string_startswith _s690_ "CUnseal")) then
      (match (string_drop _s690_ (projT1 (string_length "CUnseal"))) with
       | _s691_ =>
          (spc_matches_prefix _s691_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s692_ _)) =>
              (match (string_drop _s691_ _s692_) with
               | _s693_ =>
                  (reg_name_matches_prefix _s693_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s694_ _)) =>
                      (match (string_drop _s693_ _s694_) with
                       | _s695_ =>
                          (sep_matches_prefix _s695_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s696_ _)) =>
                              (match (string_drop _s695_ _s696_) with
                               | _s697_ =>
                                  (reg_name_matches_prefix _s697_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s698_ _)) =>
                                      (match (string_drop _s697_ _s698_) with
                                       | _s699_ =>
                                          (sep_matches_prefix _s699_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s700_ _)) =>
                                              (match (string_drop _s699_ _s700_) with
                                               | _s701_ =>
                                                  (reg_name_matches_prefix _s701_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (ct,(existT _ _s702_ _)) =>
                                                               let p0_ := string_drop _s701_ _s702_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, ct))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s672_ (_s673_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s674_ := _s673_ in
   (if ((string_startswith _s674_ "CSeal")) then
      (match (string_drop _s674_ (projT1 (string_length "CSeal"))) with
       | _s675_ =>
          (spc_matches_prefix _s675_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s676_ _)) =>
              (match (string_drop _s675_ _s676_) with
               | _s677_ =>
                  (reg_name_matches_prefix _s677_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s678_ _)) =>
                      (match (string_drop _s677_ _s678_) with
                       | _s679_ =>
                          (sep_matches_prefix _s679_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s680_ _)) =>
                              (match (string_drop _s679_ _s680_) with
                               | _s681_ =>
                                  (reg_name_matches_prefix _s681_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s682_ _)) =>
                                      (match (string_drop _s681_ _s682_) with
                                       | _s683_ =>
                                          (sep_matches_prefix _s683_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s684_ _)) =>
                                              (match (string_drop _s683_ _s684_) with
                                               | _s685_ =>
                                                  (reg_name_matches_prefix _s685_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (ct,(existT _ _s686_ _)) =>
                                                               let p0_ := string_drop _s685_ _s686_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, ct))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s660_ (_s661_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s662_ := _s661_ in
   (if ((string_startswith _s662_ "CJALR")) then
      (match (string_drop _s662_ (projT1 (string_length "CJALR"))) with
       | _s663_ =>
          (spc_matches_prefix _s663_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s664_ _)) =>
              (match (string_drop _s663_ _s664_) with
               | _s665_ =>
                  (reg_name_matches_prefix _s665_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s666_ _)) =>
                      (match (string_drop _s665_ _s666_) with
                       | _s667_ =>
                          (sep_matches_prefix _s667_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s668_ _)) =>
                              (match (string_drop _s667_ _s668_) with
                               | _s669_ =>
                                  (reg_name_matches_prefix _s669_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s670_ _)) =>
                                               let p0_ := string_drop _s669_ _s670_ in
                                               if ((generic_eq p0_ "")) then Some ((cd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s652_ (_s653_ : string) 
: M (option (mword 5)) :=
   
   let _s654_ := _s653_ in
   (if ((string_startswith _s654_ "CJR")) then
      (match (string_drop _s654_ (projT1 (string_length "CJR"))) with
       | _s655_ =>
          (spc_matches_prefix _s655_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s656_ _)) =>
              (match (string_drop _s655_ _s656_) with
               | _s657_ =>
                  (reg_name_matches_prefix _s657_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some (cb,(existT _ _s658_ _)) =>
                               let p0_ := string_drop _s657_ _s658_ in
                               if ((generic_eq p0_ "")) then Some (cb)
                               else None
                            | _ => None
                            end)
                   : option (mword 5))
               end)
               : M (option (mword 5))
           | _ => returnm (None  : option (mword 5))
           end)
           : M (option (mword 5))
       end)
       : M (option (mword 5))
    else returnm (None  : option (mword 5)))
    : M (option (mword 5)).

Definition _s640_ (_s641_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s642_ := _s641_ in
   (if ((string_startswith _s642_ "CClearTag")) then
      (match (string_drop _s642_ (projT1 (string_length "CClearTag"))) with
       | _s643_ =>
          (spc_matches_prefix _s643_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s644_ _)) =>
              (match (string_drop _s643_ _s644_) with
               | _s645_ =>
                  (reg_name_matches_prefix _s645_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s646_ _)) =>
                      (match (string_drop _s645_ _s646_) with
                       | _s647_ =>
                          (sep_matches_prefix _s647_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s648_ _)) =>
                              (match (string_drop _s647_ _s648_) with
                               | _s649_ =>
                                  (reg_name_matches_prefix _s649_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cs,(existT _ _s650_ _)) =>
                                               let p0_ := string_drop _s649_ _s650_ in
                                               if ((generic_eq p0_ "")) then Some ((cd, cs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s628_ (_s629_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s630_ := _s629_ in
   (if ((string_startswith _s630_ "CMove")) then
      (match (string_drop _s630_ (projT1 (string_length "CMove"))) with
       | _s631_ =>
          (spc_matches_prefix _s631_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s632_ _)) =>
              (match (string_drop _s631_ _s632_) with
               | _s633_ =>
                  (reg_name_matches_prefix _s633_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s634_ _)) =>
                      (match (string_drop _s633_ _s634_) with
                       | _s635_ =>
                          (sep_matches_prefix _s635_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s636_ _)) =>
                              (match (string_drop _s635_ _s636_) with
                               | _s637_ =>
                                  (reg_name_matches_prefix _s637_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cs,(existT _ _s638_ _)) =>
                                               let p0_ := string_drop _s637_ _s638_ in
                                               if ((generic_eq p0_ "")) then Some ((cd, cs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s616_ (_s617_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s618_ := _s617_ in
   (if ((string_startswith _s618_ "CGetAddr")) then
      (match (string_drop _s618_ (projT1 (string_length "CGetAddr"))) with
       | _s619_ =>
          (spc_matches_prefix _s619_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s620_ _)) =>
              (match (string_drop _s619_ _s620_) with
               | _s621_ =>
                  (reg_name_matches_prefix _s621_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s622_ _)) =>
                      (match (string_drop _s621_ _s622_) with
                       | _s623_ =>
                          (sep_matches_prefix _s623_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s624_ _)) =>
                              (match (string_drop _s623_ _s624_) with
                               | _s625_ =>
                                  (reg_name_matches_prefix _s625_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s626_ _)) =>
                                               let p0_ := string_drop _s625_ _s626_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s604_ (_s605_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s606_ := _s605_ in
   (if ((string_startswith _s606_ "CGetOffset")) then
      (match (string_drop _s606_ (projT1 (string_length "CGetOffset"))) with
       | _s607_ =>
          (spc_matches_prefix _s607_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s608_ _)) =>
              (match (string_drop _s607_ _s608_) with
               | _s609_ =>
                  (reg_name_matches_prefix _s609_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s610_ _)) =>
                      (match (string_drop _s609_ _s610_) with
                       | _s611_ =>
                          (sep_matches_prefix _s611_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s612_ _)) =>
                              (match (string_drop _s611_ _s612_) with
                               | _s613_ =>
                                  (reg_name_matches_prefix _s613_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s614_ _)) =>
                                               let p0_ := string_drop _s613_ _s614_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s592_ (_s593_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s594_ := _s593_ in
   (if ((string_startswith _s594_ "CGetSealed")) then
      (match (string_drop _s594_ (projT1 (string_length "CGetSealed"))) with
       | _s595_ =>
          (spc_matches_prefix _s595_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s596_ _)) =>
              (match (string_drop _s595_ _s596_) with
               | _s597_ =>
                  (reg_name_matches_prefix _s597_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s598_ _)) =>
                      (match (string_drop _s597_ _s598_) with
                       | _s599_ =>
                          (sep_matches_prefix _s599_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s600_ _)) =>
                              (match (string_drop _s599_ _s600_) with
                               | _s601_ =>
                                  (reg_name_matches_prefix _s601_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s602_ _)) =>
                                               let p0_ := string_drop _s601_ _s602_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s580_ (_s581_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s582_ := _s581_ in
   (if ((string_startswith _s582_ "CGetTag")) then
      (match (string_drop _s582_ (projT1 (string_length "CGetTag"))) with
       | _s583_ =>
          (spc_matches_prefix _s583_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s584_ _)) =>
              (match (string_drop _s583_ _s584_) with
               | _s585_ =>
                  (reg_name_matches_prefix _s585_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s586_ _)) =>
                      (match (string_drop _s585_ _s586_) with
                       | _s587_ =>
                          (sep_matches_prefix _s587_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s588_ _)) =>
                              (match (string_drop _s587_ _s588_) with
                               | _s589_ =>
                                  (reg_name_matches_prefix _s589_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s590_ _)) =>
                                               let p0_ := string_drop _s589_ _s590_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s568_ (_s569_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s570_ := _s569_ in
   (if ((string_startswith _s570_ "CGetLen")) then
      (match (string_drop _s570_ (projT1 (string_length "CGetLen"))) with
       | _s571_ =>
          (spc_matches_prefix _s571_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s572_ _)) =>
              (match (string_drop _s571_ _s572_) with
               | _s573_ =>
                  (reg_name_matches_prefix _s573_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s574_ _)) =>
                      (match (string_drop _s573_ _s574_) with
                       | _s575_ =>
                          (sep_matches_prefix _s575_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s576_ _)) =>
                              (match (string_drop _s575_ _s576_) with
                               | _s577_ =>
                                  (reg_name_matches_prefix _s577_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s578_ _)) =>
                                               let p0_ := string_drop _s577_ _s578_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s556_ (_s557_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s558_ := _s557_ in
   (if ((string_startswith _s558_ "CGetBase")) then
      (match (string_drop _s558_ (projT1 (string_length "CGetBase"))) with
       | _s559_ =>
          (spc_matches_prefix _s559_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s560_ _)) =>
              (match (string_drop _s559_ _s560_) with
               | _s561_ =>
                  (reg_name_matches_prefix _s561_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s562_ _)) =>
                      (match (string_drop _s561_ _s562_) with
                       | _s563_ =>
                          (sep_matches_prefix _s563_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s564_ _)) =>
                              (match (string_drop _s563_ _s564_) with
                               | _s565_ =>
                                  (reg_name_matches_prefix _s565_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s566_ _)) =>
                                               let p0_ := string_drop _s565_ _s566_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s544_ (_s545_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s546_ := _s545_ in
   (if ((string_startswith _s546_ "CGetType")) then
      (match (string_drop _s546_ (projT1 (string_length "CGetType"))) with
       | _s547_ =>
          (spc_matches_prefix _s547_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s548_ _)) =>
              (match (string_drop _s547_ _s548_) with
               | _s549_ =>
                  (reg_name_matches_prefix _s549_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s550_ _)) =>
                      (match (string_drop _s549_ _s550_) with
                       | _s551_ =>
                          (sep_matches_prefix _s551_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s552_ _)) =>
                              (match (string_drop _s551_ _s552_) with
                               | _s553_ =>
                                  (reg_name_matches_prefix _s553_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s554_ _)) =>
                                               let p0_ := string_drop _s553_ _s554_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s532_ (_s533_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s534_ := _s533_ in
   (if ((string_startswith _s534_ "CGetPerm")) then
      (match (string_drop _s534_ (projT1 (string_length "CGetPerm"))) with
       | _s535_ =>
          (spc_matches_prefix _s535_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s536_ _)) =>
              (match (string_drop _s535_ _s536_) with
               | _s537_ =>
                  (reg_name_matches_prefix _s537_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s538_ _)) =>
                      (match (string_drop _s537_ _s538_) with
                       | _s539_ =>
                          (sep_matches_prefix _s539_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s540_ _)) =>
                              (match (string_drop _s539_ _s540_) with
                               | _s541_ =>
                                  (reg_name_matches_prefix _s541_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s542_ _)) =>
                                               let p0_ := string_drop _s541_ _s542_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s517_ (_s518_ : string) 
: M (option ((sopw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s518_ with
    | _s519_ =>
       (shiftiwop_mnemonic_matches_prefix _s519_) >>= fun w__0 : option ((sopw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s520_ _)) =>
           (match (string_drop _s519_ _s520_) with
            | _s521_ =>
               (spc_matches_prefix _s521_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s522_ _)) =>
                   (match (string_drop _s521_ _s522_) with
                    | _s523_ =>
                       (reg_name_matches_prefix _s523_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s524_ _)) =>
                           (match (string_drop _s523_ _s524_) with
                            | _s525_ =>
                               (sep_matches_prefix _s525_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s526_ _)) =>
                                   (match (string_drop _s525_ _s526_) with
                                    | _s527_ =>
                                       (reg_name_matches_prefix _s527_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       returnm ((match w__4 with
                                                 | Some (rs1,(existT _ _s528_ _)) =>
                                                    match (string_drop _s527_ _s528_) with
                                                    | _s529_ =>
                                                       match (hex_bits_5_matches_prefix _s529_) with
                                                       | Some (shamt,(existT _ _s530_ _)) =>
                                                          let p0_ := string_drop _s529_ _s530_ in
                                                          if ((generic_eq p0_ "")) then
                                                            Some
                                                              ((op, rd, rs1, shamt))
                                                          else None
                                                       | _ => None
                                                       end
                                                    end
                                                 | _ => None
                                                 end)
                                        : option ((sopw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sopw * mword 5 * mword 5 * mword 5))).

Definition _s500_ (_s501_ : string) 
: M (option ((ropw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s501_ with
    | _s502_ =>
       (rtypew_mnemonic_matches_prefix _s502_) >>= fun w__0 : option ((ropw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s503_ _)) =>
           (match (string_drop _s502_ _s503_) with
            | _s504_ =>
               (spc_matches_prefix _s504_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s505_ _)) =>
                   (match (string_drop _s504_ _s505_) with
                    | _s506_ =>
                       (reg_name_matches_prefix _s506_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s507_ _)) =>
                           (match (string_drop _s506_ _s507_) with
                            | _s508_ =>
                               (sep_matches_prefix _s508_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s509_ _)) =>
                                   (match (string_drop _s508_ _s509_) with
                                    | _s510_ =>
                                       (reg_name_matches_prefix _s510_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s511_ _)) =>
                                           (match (string_drop _s510_ _s511_) with
                                            | _s512_ =>
                                               (sep_matches_prefix _s512_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some (tt,(existT _ _s513_ _)) =>
                                                   (match (string_drop _s512_ _s513_) with
                                                    | _s514_ =>
                                                       (reg_name_matches_prefix _s514_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some (rs2,(existT _ _s515_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s514_ _s515_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((ropw * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((ropw * mword 5 * mword 5 * mword 5))).

Definition _s483_ (_s484_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s484_ with
    | _s485_ =>
       (shiftw_mnemonic_matches_prefix _s485_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s486_ _)) =>
           (match (string_drop _s485_ _s486_) with
            | _s487_ =>
               (spc_matches_prefix _s487_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s488_ _)) =>
                   (match (string_drop _s487_ _s488_) with
                    | _s489_ =>
                       (reg_name_matches_prefix _s489_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s490_ _)) =>
                           (match (string_drop _s489_ _s490_) with
                            | _s491_ =>
                               (sep_matches_prefix _s491_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s492_ _)) =>
                                   (match (string_drop _s491_ _s492_) with
                                    | _s493_ =>
                                       (reg_name_matches_prefix _s493_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s494_ _)) =>
                                           (match (string_drop _s493_ _s494_) with
                                            | _s495_ =>
                                               (sep_matches_prefix _s495_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s496_ _)) =>
                                                            match (string_drop _s495_ _s496_) with
                                                            | _s497_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s497_) with
                                                               | Some (shamt,(existT _ _s498_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s497_ _s498_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 5))).

Definition _s467_ (_s468_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s469_ := _s468_ in
   (if ((string_startswith _s469_ "addiw")) then
      (match (string_drop _s469_ (projT1 (string_length "addiw"))) with
       | _s470_ =>
          (spc_matches_prefix _s470_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s471_ _)) =>
              (match (string_drop _s470_ _s471_) with
               | _s472_ =>
                  (reg_name_matches_prefix _s472_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s473_ _)) =>
                      (match (string_drop _s472_ _s473_) with
                       | _s474_ =>
                          (sep_matches_prefix _s474_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s475_ _)) =>
                              (match (string_drop _s474_ _s475_) with
                               | _s476_ =>
                                  (reg_name_matches_prefix _s476_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (rs1,(existT _ _s477_ _)) =>
                                      (match (string_drop _s476_ _s477_) with
                                       | _s478_ =>
                                          (sep_matches_prefix _s478_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s479_ _)) =>
                                                       match (string_drop _s478_ _s479_) with
                                                       | _s480_ =>
                                                          match (hex_bits_12_matches_prefix _s480_) with
                                                          | Some (imm,(existT _ _s481_ _)) =>
                                                             let p0_ := string_drop _s480_ _s481_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s450_ (_s451_ : string) 
: M (option ((rop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s451_ with
    | _s452_ =>
       (rtype_mnemonic_matches_prefix _s452_) >>= fun w__0 : option ((rop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s453_ _)) =>
           (match (string_drop _s452_ _s453_) with
            | _s454_ =>
               (spc_matches_prefix _s454_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s455_ _)) =>
                   (match (string_drop _s454_ _s455_) with
                    | _s456_ =>
                       (reg_name_matches_prefix _s456_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s457_ _)) =>
                           (match (string_drop _s456_ _s457_) with
                            | _s458_ =>
                               (sep_matches_prefix _s458_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s459_ _)) =>
                                   (match (string_drop _s458_ _s459_) with
                                    | _s460_ =>
                                       (reg_name_matches_prefix _s460_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s461_ _)) =>
                                           (match (string_drop _s460_ _s461_) with
                                            | _s462_ =>
                                               (sep_matches_prefix _s462_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some (tt,(existT _ _s463_ _)) =>
                                                   (match (string_drop _s462_ _s463_) with
                                                    | _s464_ =>
                                                       (reg_name_matches_prefix _s464_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some (rs2,(existT _ _s465_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s464_ _s465_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((rop * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((rop * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((rop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((rop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((rop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((rop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((rop * mword 5 * mword 5 * mword 5))).

Definition _s435_ (_s436_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 6))) :=
   
   (match _s436_ with
    | _s437_ =>
       (shiftiop_mnemonic_matches_prefix _s437_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s438_ _)) =>
           (match (string_drop _s437_ _s438_) with
            | _s439_ =>
               (spc_matches_prefix _s439_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s440_ _)) =>
                   (match (string_drop _s439_ _s440_) with
                    | _s441_ =>
                       (reg_name_matches_prefix _s441_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s442_ _)) =>
                           (match (string_drop _s441_ _s442_) with
                            | _s443_ =>
                               (sep_matches_prefix _s443_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s444_ _)) =>
                                   (match (string_drop _s443_ _s444_) with
                                    | _s445_ =>
                                       (reg_name_matches_prefix _s445_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       returnm ((match w__4 with
                                                 | Some (rs1,(existT _ _s446_ _)) =>
                                                    match (string_drop _s445_ _s446_) with
                                                    | _s447_ =>
                                                       match (hex_bits_6_matches_prefix _s447_) with
                                                       | Some (shamt,(existT _ _s448_ _)) =>
                                                          let p0_ := string_drop _s447_ _s448_ in
                                                          if ((generic_eq p0_ "")) then
                                                            Some
                                                              ((op, rd, rs1, shamt))
                                                          else None
                                                       | _ => None
                                                       end
                                                    end
                                                 | _ => None
                                                 end)
                                        : option ((sop * mword 5 * mword 5 * mword 6)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 6)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 6)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 6)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 6)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 6)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 6)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 6))).

Definition _s418_ (_s419_ : string) 
: M (option ((iop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s419_ with
    | _s420_ =>
       (itype_mnemonic_matches_prefix _s420_) >>= fun w__0 : option ((iop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s421_ _)) =>
           (match (string_drop _s420_ _s421_) with
            | _s422_ =>
               (spc_matches_prefix _s422_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s423_ _)) =>
                   (match (string_drop _s422_ _s423_) with
                    | _s424_ =>
                       (reg_name_matches_prefix _s424_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s425_ _)) =>
                           (match (string_drop _s424_ _s425_) with
                            | _s426_ =>
                               (sep_matches_prefix _s426_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s427_ _)) =>
                                   (match (string_drop _s426_ _s427_) with
                                    | _s428_ =>
                                       (reg_name_matches_prefix _s428_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s429_ _)) =>
                                           (match (string_drop _s428_ _s429_) with
                                            | _s430_ =>
                                               (sep_matches_prefix _s430_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s431_ _)) =>
                                                            match (string_drop _s430_ _s431_) with
                                                            | _s432_ =>
                                                               match (hex_bits_12_matches_prefix
                                                                        _s432_) with
                                                               | Some (imm,(existT _ _s433_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s432_ _s433_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((iop * mword 5 * mword 5 * mword 12)))
                                            end)
                                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                        | _ =>
                                           returnm (None
                                            : option ((iop * mword 5 * mword 5 * mword 12)))
                                        end)
                                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                    end)
                                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                | _ =>
                                   returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                                end)
                                : M (option ((iop * mword 5 * mword 5 * mword 12)))
                            end)
                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                        end)
                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                    end)
                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                end)
                : M (option ((iop * mword 5 * mword 5 * mword 12)))
            end)
            : M (option ((iop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((iop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((iop * mword 5 * mword 5 * mword 12))).

Definition _s401_ (_s402_ : string) 
: M (option ((bop * mword 5 * mword 5 * mword 13))) :=
   
   (match _s402_ with
    | _s403_ =>
       (btype_mnemonic_matches_prefix _s403_) >>= fun w__0 : option ((bop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s404_ _)) =>
           (match (string_drop _s403_ _s404_) with
            | _s405_ =>
               (spc_matches_prefix _s405_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s406_ _)) =>
                   (match (string_drop _s405_ _s406_) with
                    | _s407_ =>
                       (reg_name_matches_prefix _s407_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rs1,(existT _ _s408_ _)) =>
                           (match (string_drop _s407_ _s408_) with
                            | _s409_ =>
                               (sep_matches_prefix _s409_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s410_ _)) =>
                                   (match (string_drop _s409_ _s410_) with
                                    | _s411_ =>
                                       (reg_name_matches_prefix _s411_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs2,(existT _ _s412_ _)) =>
                                           (match (string_drop _s411_ _s412_) with
                                            | _s413_ =>
                                               (sep_matches_prefix _s413_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s414_ _)) =>
                                                            match (string_drop _s413_ _s414_) with
                                                            | _s415_ =>
                                                               match (hex_bits_13_matches_prefix
                                                                        _s415_) with
                                                               | Some (imm,(existT _ _s416_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s415_ _s416_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rs1, rs2, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((bop * mword 5 * mword 5 * mword 13)))
                                            end)
                                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                        | _ =>
                                           returnm (None
                                            : option ((bop * mword 5 * mword 5 * mword 13)))
                                        end)
                                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                    end)
                                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                | _ =>
                                   returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                                end)
                                : M (option ((bop * mword 5 * mword 5 * mword 13)))
                            end)
                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                        end)
                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                    end)
                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                end)
                : M (option ((bop * mword 5 * mword 5 * mword 13)))
            end)
            : M (option ((bop * mword 5 * mword 5 * mword 13)))
        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
        end)
        : M (option ((bop * mword 5 * mword 5 * mword 13)))
    end)
    : M (option ((bop * mword 5 * mword 5 * mword 13))).

Definition _s385_ (_s386_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s387_ := _s386_ in
   (if ((string_startswith _s387_ "jalr")) then
      (match (string_drop _s387_ (projT1 (string_length "jalr"))) with
       | _s388_ =>
          (spc_matches_prefix _s388_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s389_ _)) =>
              (match (string_drop _s388_ _s389_) with
               | _s390_ =>
                  (reg_name_matches_prefix _s390_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s391_ _)) =>
                      (match (string_drop _s390_ _s391_) with
                       | _s392_ =>
                          (sep_matches_prefix _s392_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s393_ _)) =>
                              (match (string_drop _s392_ _s393_) with
                               | _s394_ =>
                                  (reg_name_matches_prefix _s394_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (rs1,(existT _ _s395_ _)) =>
                                      (match (string_drop _s394_ _s395_) with
                                       | _s396_ =>
                                          (sep_matches_prefix _s396_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s397_ _)) =>
                                                       match (string_drop _s396_ _s397_) with
                                                       | _s398_ =>
                                                          match (hex_bits_12_matches_prefix _s398_) with
                                                          | Some (imm,(existT _ _s399_ _)) =>
                                                             let p0_ := string_drop _s398_ _s399_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s373_ (_s374_ : string) 
: M (option ((mword 5 * mword 21))) :=
   
   let _s375_ := _s374_ in
   (if ((string_startswith _s375_ "jal")) then
      (match (string_drop _s375_ (projT1 (string_length "jal"))) with
       | _s376_ =>
          (spc_matches_prefix _s376_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s377_ _)) =>
              (match (string_drop _s376_ _s377_) with
               | _s378_ =>
                  (reg_name_matches_prefix _s378_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s379_ _)) =>
                      (match (string_drop _s378_ _s379_) with
                       | _s380_ =>
                          (sep_matches_prefix _s380_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some (tt,(existT _ _s381_ _)) =>
                                       match (string_drop _s380_ _s381_) with
                                       | _s382_ =>
                                          match (hex_bits_21_matches_prefix _s382_) with
                                          | Some (imm,(existT _ _s383_ _)) =>
                                             let p0_ := string_drop _s382_ _s383_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 21)))
                       end)
                       : M (option ((mword 5 * mword 21)))
                   | _ => returnm (None  : option ((mword 5 * mword 21)))
                   end)
                   : M (option ((mword 5 * mword 21)))
               end)
               : M (option ((mword 5 * mword 21)))
           | _ => returnm (None  : option ((mword 5 * mword 21)))
           end)
           : M (option ((mword 5 * mword 21)))
       end)
       : M (option ((mword 5 * mword 21)))
    else returnm (None  : option ((mword 5 * mword 21))))
    : M (option ((mword 5 * mword 21))).

Definition _s360_ (_s361_ : string) 
: M (option ((uop * mword 5 * mword 20))) :=
   
   (match _s361_ with
    | _s362_ =>
       (utype_mnemonic_matches_prefix _s362_) >>= fun w__0 : option ((uop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s363_ _)) =>
           (match (string_drop _s362_ _s363_) with
            | _s364_ =>
               (spc_matches_prefix _s364_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s365_ _)) =>
                   (match (string_drop _s364_ _s365_) with
                    | _s366_ =>
                       (reg_name_matches_prefix _s366_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s367_ _)) =>
                           (match (string_drop _s366_ _s367_) with
                            | _s368_ =>
                               (sep_matches_prefix _s368_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some (tt,(existT _ _s369_ _)) =>
                                            match (string_drop _s368_ _s369_) with
                                            | _s370_ =>
                                               match (hex_bits_20_matches_prefix _s370_) with
                                               | Some (imm,(existT _ _s371_ _)) =>
                                                  let p0_ := string_drop _s370_ _s371_ in
                                                  if ((generic_eq p0_ "")) then Some ((op, rd, imm))
                                                  else None
                                               | _ => None
                                               end
                                            end
                                         | _ => None
                                         end)
                                : option ((uop * mword 5 * mword 20)))
                            end)
                            : M (option ((uop * mword 5 * mword 20)))
                        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                        end)
                        : M (option ((uop * mword 5 * mword 20)))
                    end)
                    : M (option ((uop * mword 5 * mword 20)))
                | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                end)
                : M (option ((uop * mword 5 * mword 20)))
            end)
            : M (option ((uop * mword 5 * mword 20)))
        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
        end)
        : M (option ((uop * mword 5 * mword 20)))
    end)
    : M (option ((uop * mword 5 * mword 20))).

Definition assembly_backwards (arg_ : string) 
: M (ast) :=
   
   let _s372_ := arg_ in
   (_s360_ _s372_) >>= fun w__0 : option ((uop * mword 5 * mword 20)) =>
   (if ((match w__0 with | Some (op,rd,imm) => true | _ => false end)) then
      (_s360_ _s372_) >>= fun w__1 : option ((uop * mword 5 * mword 20)) =>
      (match w__1 with
       | Some (op,rd,imm) => returnm ((UTYPE ((imm, rd, op)))  : ast )
       | _ => exit tt  : M (ast)
       end)
       : M (ast)
    else
      (_s373_ _s372_) >>= fun w__4 : option ((mword 5 * mword 21)) =>
      (if ((match w__4 with | Some (rd,imm) => true | _ => false end)) then
         (_s373_ _s372_) >>= fun w__5 : option ((mword 5 * mword 21)) =>
         (match w__5 with
          | Some (rd,imm) => returnm ((RISCV_JAL ((imm, rd)))  : ast )
          | _ => exit tt  : M (ast)
          end)
          : M (ast)
       else
         (_s385_ _s372_) >>= fun w__8 : option ((mword 5 * mword 5 * mword 12)) =>
         (if ((match w__8 with | Some (rd,rs1,imm) => true | _ => false end)) then
            (_s385_ _s372_) >>= fun w__9 : option ((mword 5 * mword 5 * mword 12)) =>
            (match w__9 with
             | Some (rd,rs1,imm) => returnm ((RISCV_JALR ((imm, rs1, rd)))  : ast )
             | _ => exit tt  : M (ast)
             end)
             : M (ast)
          else
            (_s401_ _s372_) >>= fun w__12 : option ((bop * mword 5 * mword 5 * mword 13)) =>
            (if ((match w__12 with | Some (op,rs1,rs2,imm) => true | _ => false end)) then
               (_s401_ _s372_) >>= fun w__13 : option ((bop * mword 5 * mword 5 * mword 13)) =>
               (match w__13 with
                | Some (op,rs1,rs2,imm) => returnm ((BTYPE ((imm, rs2, rs1, op)))  : ast )
                | _ => exit tt  : M (ast)
                end)
                : M (ast)
             else
               (_s418_ _s372_) >>= fun w__16 : option ((iop * mword 5 * mword 5 * mword 12)) =>
               (if ((match w__16 with | Some (op,rd,rs1,imm) => true | _ => false end)) then
                  (_s418_ _s372_) >>= fun w__17 : option ((iop * mword 5 * mword 5 * mword 12)) =>
                  (match w__17 with
                   | Some (op,rd,rs1,imm) => returnm ((ITYPE ((imm, rs1, rd, op)))  : ast )
                   | _ => exit tt  : M (ast)
                   end)
                   : M (ast)
                else
                  (_s435_ _s372_) >>= fun w__20 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                  (if ((match w__20 with | Some (op,rd,rs1,shamt) => true | _ => false end)) then
                     (_s435_ _s372_) >>= fun w__21 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                     (match w__21 with
                      | Some (op,rd,rs1,shamt) =>
                         returnm ((SHIFTIOP ((shamt, rs1, rd, op)))  : ast )
                      | _ => exit tt  : M (ast)
                      end)
                      : M (ast)
                   else
                     (_s450_ _s372_) >>= fun w__24 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                     (if ((match w__24 with | Some (op,rd,rs1,rs2) => true | _ => false end)) then
                        (_s450_ _s372_) >>= fun w__25 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                        (match w__25 with
                         | Some (op,rd,rs1,rs2) => returnm ((RTYPE ((rs2, rs1, rd, op)))  : ast )
                         | _ => exit tt  : M (ast)
                         end)
                         : M (ast)
                      else
                        (_s467_ _s372_) >>= fun w__28 : option ((mword 5 * mword 5 * mword 12)) =>
                        (if ((match w__28 with | Some (rd,rs1,imm) => true | _ => false end)) then
                           (_s467_ _s372_) >>= fun w__29 : option ((mword 5 * mword 5 * mword 12)) =>
                           (match w__29 with
                            | Some (rd,rs1,imm) => returnm ((ADDIW ((imm, rs1, rd)))  : ast )
                            | _ => exit tt  : M (ast)
                            end)
                            : M (ast)
                         else
                           (_s483_ _s372_) >>= fun w__32 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                           (if ((match w__32 with | Some (op,rd,rs1,shamt) => true | _ => false end))
                            then
                              (_s483_ _s372_) >>= fun w__33 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                              (match w__33 with
                               | Some (op,rd,rs1,shamt) =>
                                  returnm ((SHIFTW ((shamt, rs1, rd, op)))  : ast )
                               | _ => exit tt  : M (ast)
                               end)
                               : M (ast)
                            else
                              (_s500_ _s372_) >>= fun w__36 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                              (if ((match w__36 with | Some (op,rd,rs1,rs2) => true | _ => false end))
                               then
                                 (_s500_ _s372_) >>= fun w__37 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                                 (match w__37 with
                                  | Some (op,rd,rs1,rs2) =>
                                     returnm ((RTYPEW ((rs2, rs1, rd, op)))  : ast )
                                  | _ => exit tt  : M (ast)
                                  end)
                                  : M (ast)
                               else
                                 (_s517_ _s372_) >>= fun w__40 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                 (if ((match w__40 with
                                       | Some (op,rd,rs1,shamt) => true
                                       | _ => false
                                       end)) then
                                    (_s517_ _s372_) >>= fun w__41 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                    (match w__41 with
                                     | Some (op,rd,rs1,shamt) =>
                                        returnm ((SHIFTIWOP ((shamt, rs1, rd, op)))  : ast )
                                     | _ => exit tt  : M (ast)
                                     end)
                                     : M (ast)
                                  else
                                    (_s532_ _s372_) >>= fun w__44 : option ((mword 5 * mword 5)) =>
                                    (if ((match w__44 with | Some (rd,cb) => true | _ => false end))
                                     then
                                       (_s532_ _s372_) >>= fun w__45 : option ((mword 5 * mword 5)) =>
                                       (match w__45 with
                                        | Some (rd,cb) => returnm ((CGetPerm ((rd, cb)))  : ast )
                                        | _ => exit tt  : M (ast)
                                        end)
                                        : M (ast)
                                     else
                                       (_s544_ _s372_) >>= fun w__48 : option ((mword 5 * mword 5)) =>
                                       (if ((match w__48 with
                                             | Some (rd,cb) => true
                                             | _ => false
                                             end)) then
                                          (_s544_ _s372_) >>= fun w__49 : option ((mword 5 * mword 5)) =>
                                          (match w__49 with
                                           | Some (rd,cb) => returnm ((CGetType ((rd, cb)))  : ast )
                                           | _ => exit tt  : M (ast)
                                           end)
                                           : M (ast)
                                        else
                                          (_s556_ _s372_) >>= fun w__52 : option ((mword 5 * mword 5)) =>
                                          (if ((match w__52 with
                                                | Some (rd,cb) => true
                                                | _ => false
                                                end)) then
                                             (_s556_ _s372_) >>= fun w__53 : option ((mword 5 * mword 5)) =>
                                             (match w__53 with
                                              | Some (rd,cb) =>
                                                 returnm ((CGetBase ((rd, cb)))  : ast )
                                              | _ => exit tt  : M (ast)
                                              end)
                                              : M (ast)
                                           else
                                             (_s568_ _s372_) >>= fun w__56 : option ((mword 5 * mword 5)) =>
                                             (if ((match w__56 with
                                                   | Some (rd,cb) => true
                                                   | _ => false
                                                   end)) then
                                                (_s568_ _s372_) >>= fun w__57 : option ((mword 5 * mword 5)) =>
                                                (match w__57 with
                                                 | Some (rd,cb) =>
                                                    returnm ((CGetLen ((rd, cb)))  : ast )
                                                 | _ => exit tt  : M (ast)
                                                 end)
                                                 : M (ast)
                                              else
                                                (_s580_ _s372_) >>= fun w__60 : option ((mword 5 * mword 5)) =>
                                                (if ((match w__60 with
                                                      | Some (rd,cb) => true
                                                      | _ => false
                                                      end)) then
                                                   (_s580_ _s372_) >>= fun w__61 : option ((mword 5 * mword 5)) =>
                                                   (match w__61 with
                                                    | Some (rd,cb) =>
                                                       returnm ((CGetTag ((rd, cb)))  : ast )
                                                    | _ => exit tt  : M (ast)
                                                    end)
                                                    : M (ast)
                                                 else
                                                   (_s592_ _s372_) >>= fun w__64 : option ((mword 5 * mword 5)) =>
                                                   (if ((match w__64 with
                                                         | Some (rd,cb) => true
                                                         | _ => false
                                                         end)) then
                                                      (_s592_ _s372_) >>= fun w__65 : option ((mword 5 * mword 5)) =>
                                                      (match w__65 with
                                                       | Some (rd,cb) =>
                                                          returnm ((CGetSealed ((rd, cb)))  : ast )
                                                       | _ => exit tt  : M (ast)
                                                       end)
                                                       : M (ast)
                                                    else
                                                      (_s604_ _s372_) >>= fun w__68 : option ((mword 5 * mword 5)) =>
                                                      (if ((match w__68 with
                                                            | Some (rd,cb) => true
                                                            | _ => false
                                                            end)) then
                                                         (_s604_ _s372_) >>= fun w__69 : option ((mword 5 * mword 5)) =>
                                                         (match w__69 with
                                                          | Some (rd,cb) =>
                                                             returnm ((CGetOffset
                                                                         ((rd, cb)))
                                                              : ast )
                                                          | _ => exit tt  : M (ast)
                                                          end)
                                                          : M (ast)
                                                       else
                                                         (_s616_ _s372_) >>= fun w__72 : option ((mword 5 * mword 5)) =>
                                                         (if ((match w__72 with
                                                               | Some (rd,cb) => true
                                                               | _ => false
                                                               end)) then
                                                            (_s616_ _s372_) >>= fun w__73 : option ((mword 5 * mword 5)) =>
                                                            (match w__73 with
                                                             | Some (rd,cb) =>
                                                                returnm ((CGetAddr
                                                                            ((rd, cb)))
                                                                 : ast )
                                                             | _ => exit tt  : M (ast)
                                                             end)
                                                             : M (ast)
                                                          else
                                                            (_s628_ _s372_) >>= fun w__76 : option ((mword 5 * mword 5)) =>
                                                            (if ((match w__76 with
                                                                  | Some (cd,cs) => true
                                                                  | _ => false
                                                                  end)) then
                                                               (_s628_ _s372_) >>= fun w__77 : option ((mword 5 * mword 5)) =>
                                                               (match w__77 with
                                                                | Some (cd,cs) =>
                                                                   returnm ((CMove
                                                                               ((cd, cs)))
                                                                    : ast )
                                                                | _ => exit tt  : M (ast)
                                                                end)
                                                                : M (ast)
                                                             else
                                                               (_s640_ _s372_) >>= fun w__80 : option ((mword 5 * mword 5)) =>
                                                               (if ((match w__80 with
                                                                     | Some (cd,cs) => true
                                                                     | _ => false
                                                                     end)) then
                                                                  (_s640_ _s372_) >>= fun w__81 : option ((mword 5 * mword 5)) =>
                                                                  (match w__81 with
                                                                   | Some (cd,cs) =>
                                                                      returnm ((CClearTag
                                                                                  ((cd, cs)))
                                                                       : ast )
                                                                   | _ => exit tt  : M (ast)
                                                                   end)
                                                                   : M (ast)
                                                                else
                                                                  (_s652_ _s372_) >>= fun w__84 : option (mword 5) =>
                                                                  (if ((match w__84 with
                                                                        | Some (cb) => true
                                                                        | _ => false
                                                                        end)) then
                                                                     (_s652_ _s372_) >>= fun w__85 : option (mword 5) =>
                                                                     (match w__85 with
                                                                      | Some (cb) =>
                                                                         returnm ((CJALR
                                                                                     (((vec_of_bits [B0;B0;B0;B0;B0]
                                                                                         : mword 5), cb)))
                                                                          : ast )
                                                                      | _ => exit tt  : M (ast)
                                                                      end)
                                                                      : M (ast)
                                                                   else
                                                                     (_s660_ _s372_) >>= fun w__88 : option ((mword 5 * mword 5)) =>
                                                                     (if ((match w__88 with
                                                                           | Some (cd,cb) => true
                                                                           | _ => false
                                                                           end)) then
                                                                        (_s660_ _s372_) >>= fun w__89 : option ((mword 5 * mword 5)) =>
                                                                        (match w__89 with
                                                                         | Some (cd,cb) =>
                                                                            returnm ((CJALR
                                                                                        ((cd, cb)))
                                                                             : ast )
                                                                         | _ => exit tt  : M (ast)
                                                                         end)
                                                                         : M (ast)
                                                                      else
                                                                        (_s672_ _s372_) >>= fun w__92 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                        (if ((match w__92 with
                                                                              | Some (cd,cs,ct) =>
                                                                                 true
                                                                              | _ => false
                                                                              end)) then
                                                                           (_s672_ _s372_) >>= fun w__93 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                           (match w__93 with
                                                                            | Some (cd,cs,ct) =>
                                                                               returnm ((CSeal
                                                                                           ((cd, cs, ct)))
                                                                                : ast )
                                                                            | _ =>
                                                                               exit tt  : M (ast)
                                                                            end)
                                                                            : M (ast)
                                                                         else
                                                                           (_s688_ _s372_) >>= fun w__96 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                           (if ((match w__96 with
                                                                                 | Some (cd,cs,ct) =>
                                                                                    true
                                                                                 | _ => false
                                                                                 end)) then
                                                                              (_s688_ _s372_) >>= fun w__97 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                              (match w__97 with
                                                                               | Some (cd,cs,ct) =>
                                                                                  returnm ((CUnseal
                                                                                              ((cd, cs, ct)))
                                                                                   : ast )
                                                                               | _ =>
                                                                                  exit tt  : M (ast)
                                                                               end)
                                                                               : M (ast)
                                                                            else
                                                                              (_s704_ _s372_) >>= fun w__100 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                              (if ((match w__100 with
                                                                                    | Some
                                                                                      (cd,cs,rt) =>
                                                                                       true
                                                                                    | _ => false
                                                                                    end)) then
                                                                                 (_s704_ _s372_) >>= fun w__101 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                 (match w__101 with
                                                                                  | Some (cd,cs,rt) =>
                                                                                     returnm ((CAndPerm
                                                                                                 ((cd, cs, rt)))
                                                                                      : ast )
                                                                                  | _ =>
                                                                                     exit tt
                                                                                      : M (ast)
                                                                                  end)
                                                                                  : M (ast)
                                                                               else
                                                                                 (_s720_ _s372_) >>= fun w__104 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                 (if ((match w__104 with
                                                                                       | Some
                                                                                         (cd,cs,rt) =>
                                                                                          true
                                                                                       | _ => false
                                                                                       end)) then
                                                                                    (_s720_ _s372_) >>= fun w__105 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                    (match w__105 with
                                                                                     | Some
                                                                                       (cd,cs,rt) =>
                                                                                        returnm ((CSetOffset
                                                                                                    ((cd, cs, rt)))
                                                                                         : ast )
                                                                                     | _ =>
                                                                                        exit tt
                                                                                         : M (ast)
                                                                                     end)
                                                                                     : M (ast)
                                                                                  else
                                                                                    (_s736_ _s372_) >>= fun w__108 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                    (if ((match w__108 with
                                                                                          | Some
                                                                                            (cd,cs,rt) =>
                                                                                             true
                                                                                          | _ =>
                                                                                             false
                                                                                          end)) then
                                                                                       (_s736_
                                                                                          _s372_) >>= fun w__109 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                       (match w__109 with
                                                                                        | Some
                                                                                          (cd,cs,rt) =>
                                                                                           returnm ((CIncOffset
                                                                                                       ((cd, cs, rt)))
                                                                                            : ast )
                                                                                        | _ =>
                                                                                           exit tt
                                                                                            : M (ast)
                                                                                        end)
                                                                                        : M (ast)
                                                                                     else
                                                                                       (_s752_
                                                                                          _s372_) >>= fun w__112 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                       (if ((match w__112 with
                                                                                             | Some
                                                                                               (cd,cs,rt) =>
                                                                                                true
                                                                                             | _ =>
                                                                                                false
                                                                                             end))
                                                                                        then
                                                                                          (_s752_
                                                                                             _s372_) >>= fun w__113 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                          (match w__113 with
                                                                                           | Some
                                                                                             (cd,cs,rt) =>
                                                                                              returnm ((CSetBounds
                                                                                                          ((cd, cs, rt)))
                                                                                               : ast )
                                                                                           | _ =>
                                                                                              exit tt
                                                                                               : M (ast)
                                                                                           end)
                                                                                           : M (ast)
                                                                                        else
                                                                                          (_s768_
                                                                                             _s372_) >>= fun w__116 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                          (if ((match w__116 with
                                                                                                | Some
                                                                                                  (cd,cs,rt) =>
                                                                                                   true
                                                                                                | _ =>
                                                                                                   false
                                                                                                end))
                                                                                           then
                                                                                             (_s768_
                                                                                                _s372_) >>= fun w__117 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                             (match w__117 with
                                                                                              | Some
                                                                                                (cd,cs,rt) =>
                                                                                                 returnm ((CSetBoundsExact
                                                                                                             ((cd, cs, rt)))
                                                                                                  : ast )
                                                                                              | _ =>
                                                                                                 exit tt
                                                                                                  : M (ast)
                                                                                              end)
                                                                                              : M (ast)
                                                                                           else
                                                                                             (_s784_
                                                                                                _s372_) >>= fun w__120 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                             (if ((match w__120 with
                                                                                                   | Some
                                                                                                     (rd,cb,cs) =>
                                                                                                      true
                                                                                                   | _ =>
                                                                                                      false
                                                                                                   end))
                                                                                              then
                                                                                                (_s784_
                                                                                                   _s372_) >>= fun w__121 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                (match w__121 with
                                                                                                 | Some
                                                                                                   (rd,cb,cs) =>
                                                                                                    returnm ((CToPtr
                                                                                                                ((rd, cb, cs)))
                                                                                                     : ast )
                                                                                                 | _ =>
                                                                                                    exit tt
                                                                                                     : M (ast)
                                                                                                 end)
                                                                                                 : M (ast)
                                                                                              else
                                                                                                (_s800_
                                                                                                   _s372_) >>= fun w__124 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                (if ((match w__124 with
                                                                                                      | Some
                                                                                                        (cd,cb,rs) =>
                                                                                                         true
                                                                                                      | _ =>
                                                                                                         false
                                                                                                      end))
                                                                                                 then
                                                                                                   (_s800_
                                                                                                      _s372_) >>= fun w__125 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                   (match w__125 with
                                                                                                    | Some
                                                                                                      (cd,cb,rs) =>
                                                                                                       returnm ((CFromPtr
                                                                                                                   ((cd, cb, rs)))
                                                                                                        : ast )
                                                                                                    | _ =>
                                                                                                       exit tt
                                                                                                        : M (ast)
                                                                                                    end)
                                                                                                    : M (ast)
                                                                                                 else
                                                                                                   (_s816_
                                                                                                      _s372_) >>= fun w__128 : option ((mword 5 * mword 5)) =>
                                                                                                   (if
                                                                                                      ((match w__128 with
                                                                                                        | Some
                                                                                                          (cs,cb) =>
                                                                                                           true
                                                                                                        | _ =>
                                                                                                           false
                                                                                                        end))
                                                                                                    then
                                                                                                      (_s816_
                                                                                                         _s372_) >>= fun w__129 : option ((mword 5 * mword 5)) =>
                                                                                                      (match w__129 with
                                                                                                       | Some
                                                                                                         (cs,cb) =>
                                                                                                          returnm ((CCall
                                                                                                                      ((cs, cb, (vec_of_bits [B0;B0;B0;B0;B1]
                                                                                                                                  : mword 5))))
                                                                                                           : ast )
                                                                                                       | _ =>
                                                                                                          exit tt
                                                                                                           : M (ast)
                                                                                                       end)
                                                                                                       : M (ast)
                                                                                                    else
                                                                                                      (_s828_
                                                                                                         _s372_) >>= fun w__132 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                      (if
                                                                                                         ((match w__132 with
                                                                                                           | Some
                                                                                                             (cd,cb,imm12) =>
                                                                                                              true
                                                                                                           | _ =>
                                                                                                              false
                                                                                                           end))
                                                                                                       then
                                                                                                         (_s828_
                                                                                                            _s372_) >>= fun w__133 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                         (match w__133 with
                                                                                                          | Some
                                                                                                            (cd,cb,imm12) =>
                                                                                                             returnm ((CIncOffsetImmediate
                                                                                                                         ((cd, cb, imm12)))
                                                                                                              : ast )
                                                                                                          | _ =>
                                                                                                             exit tt
                                                                                                              : M (ast)
                                                                                                          end)
                                                                                                          : M (ast)
                                                                                                       else
                                                                                                         (_s844_
                                                                                                            _s372_) >>= fun w__136 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                         (if
                                                                                                            ((match w__136 with
                                                                                                              | Some
                                                                                                                (cd,cb,imm12) =>
                                                                                                                 true
                                                                                                              | _ =>
                                                                                                                 false
                                                                                                              end))
                                                                                                          then
                                                                                                            (_s844_
                                                                                                               _s372_) >>= fun w__137 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                            (match w__137 with
                                                                                                             | Some
                                                                                                               (cd,cb,imm12) =>
                                                                                                                returnm ((CSetBoundsImmediate
                                                                                                                            ((cd, cb, imm12)))
                                                                                                                 : ast )
                                                                                                             | _ =>
                                                                                                                exit tt
                                                                                                                 : M (ast)
                                                                                                             end)
                                                                                                             : M (ast)
                                                                                                          else
                                                                                                            (_s860_
                                                                                                               _s372_) >>= fun w__140 : option ((word_width * bool * mword 5 * mword 5)) =>
                                                                                                            (if
                                                                                                               ((match w__140 with
                                                                                                                 | Some
                                                                                                                   (w,u,rd,cs) =>
                                                                                                                    true
                                                                                                                 | _ =>
                                                                                                                    false
                                                                                                                 end))
                                                                                                             then
                                                                                                               (_s860_
                                                                                                                  _s372_) >>= fun w__141 : option ((word_width * bool * mword 5 * mword 5)) =>
                                                                                                               (match w__141 with
                                                                                                                | Some
                                                                                                                  (w,u,rd,cs) =>
                                                                                                                   returnm ((CLoadCap
                                                                                                                               ((rd, cs, u, w)))
                                                                                                                    : ast )
                                                                                                                | _ =>
                                                                                                                   exit tt
                                                                                                                    : M (ast)
                                                                                                                end)
                                                                                                                : M (ast)
                                                                                                             else
                                                                                                               (_s877_
                                                                                                                  _s372_) >>= fun w__144 : option ((word_width * mword 5 * mword 5)) =>
                                                                                                               (if
                                                                                                                  ((match w__144 with
                                                                                                                    | Some
                                                                                                                      (w,rd,rs) =>
                                                                                                                       true
                                                                                                                    | _ =>
                                                                                                                       false
                                                                                                                    end))
                                                                                                                then
                                                                                                                  (_s877_
                                                                                                                     _s372_) >>= fun w__145 : option ((word_width * mword 5 * mword 5)) =>
                                                                                                                  (match w__145 with
                                                                                                                   | Some
                                                                                                                     (w,rd,rs) =>
                                                                                                                      returnm ((CStoreCap
                                                                                                                                  ((rd, rs, w)))
                                                                                                                       : ast )
                                                                                                                   | _ =>
                                                                                                                      exit tt
                                                                                                                       : M (ast)
                                                                                                                   end)
                                                                                                                   : M (ast)
                                                                                                                else
                                                                                                                  (_s892_
                                                                                                                     _s372_) >>= fun w__148 : option ((mword 5 * mword 5)) =>
                                                                                                                  (if
                                                                                                                     ((match w__148 with
                                                                                                                       | Some
                                                                                                                         (rd,rs) =>
                                                                                                                          true
                                                                                                                       | _ =>
                                                                                                                          false
                                                                                                                       end))
                                                                                                                   then
                                                                                                                     (_s892_
                                                                                                                        _s372_) >>= fun w__149 : option ((mword 5 * mword 5)) =>
                                                                                                                     (match w__149 with
                                                                                                                      | Some
                                                                                                                        (rd,rs) =>
                                                                                                                         returnm ((CStoreCapCap
                                                                                                                                     ((rd, rs)))
                                                                                                                          : ast )
                                                                                                                      | _ =>
                                                                                                                         exit tt
                                                                                                                          : M (ast)
                                                                                                                      end)
                                                                                                                      : M (ast)
                                                                                                                   else
                                                                                                                     (_s904_
                                                                                                                        _s372_) >>= fun w__152 : option ((mword 5 * mword 5)) =>
                                                                                                                     (if
                                                                                                                        ((match w__152 with
                                                                                                                          | Some
                                                                                                                            (rd,rs) =>
                                                                                                                             true
                                                                                                                          | _ =>
                                                                                                                             false
                                                                                                                          end))
                                                                                                                      then
                                                                                                                        (_s904_
                                                                                                                           _s372_) >>= fun w__153 : option ((mword 5 * mword 5)) =>
                                                                                                                        (match w__153 with
                                                                                                                         | Some
                                                                                                                           (rd,rs) =>
                                                                                                                            returnm ((CLoadCapCap
                                                                                                                                        ((rd, rs)))
                                                                                                                             : ast )
                                                                                                                         | _ =>
                                                                                                                            exit tt
                                                                                                                             : M (ast)
                                                                                                                         end)
                                                                                                                         : M (ast)
                                                                                                                      else
                                                                                                                        (_s916_
                                                                                                                           _s372_) >>= fun w__156 : option (mword 32) =>
                                                                                                                        (if
                                                                                                                           ((match w__156 with
                                                                                                                             | Some
                                                                                                                               (s) =>
                                                                                                                                true
                                                                                                                             | _ =>
                                                                                                                                false
                                                                                                                             end))
                                                                                                                         then
                                                                                                                           (_s916_
                                                                                                                              _s372_) >>= fun w__157 : option (mword 32) =>
                                                                                                                           (match w__157 with
                                                                                                                            | Some
                                                                                                                              (s) =>
                                                                                                                               returnm ((ILLEGAL
                                                                                                                                           (s))
                                                                                                                                : ast )
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (ast)
                                                                                                                            end)
                                                                                                                            : M (ast)
                                                                                                                         else
                                                                                                                           (_s924_
                                                                                                                              _s372_) >>= fun w__160 : option (mword 16) =>
                                                                                                                           (match w__160 with
                                                                                                                            | Some
                                                                                                                              (s) =>
                                                                                                                               returnm ((C_ILLEGAL
                                                                                                                                           (s))
                                                                                                                                : ast )
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (ast)
                                                                                                                            end)
                                                                                                                            : M (ast))
                                                                                                                         : M (ast))
                                                                                                                      : M (ast))
                                                                                                                   : M (ast))
                                                                                                                : M (ast))
                                                                                                             : M (ast))
                                                                                                          : M (ast))
                                                                                                       : M (ast))
                                                                                                    : M (ast))
                                                                                                 : M (ast))
                                                                                              : M (ast))
                                                                                           : M (ast))
                                                                                        : M (ast))
                                                                                     : M (ast))
                                                                                  : M (ast))
                                                                               : M (ast))
                                                                            : M (ast))
                                                                         : M (ast))
                                                                      : M (ast))
                                                                   : M (ast))
                                                                : M (ast))
                                                             : M (ast))
                                                          : M (ast))
                                                       : M (ast))
                                                    : M (ast))
                                                 : M (ast))
                                              : M (ast))
                                           : M (ast))
                                        : M (ast))
                                     : M (ast))
                                  : M (ast))
                               : M (ast))
                            : M (ast))
                         : M (ast))
                      : M (ast))
                   : M (ast))
                : M (ast))
             : M (ast))
          : M (ast))
       : M (ast))
    : M (ast).

Definition assembly_forwards_matches (arg_ : ast) 
: bool :=
   
   match arg_ with
   | UTYPE (imm,rd,op) => true
   | RISCV_JAL (imm,rd) => true
   | RISCV_JALR (imm,rs1,rd) => true
   | BTYPE (imm,rs2,rs1,op) => true
   | ITYPE (imm,rs1,rd,op) => true
   | SHIFTIOP (shamt,rs1,rd,op) => true
   | RTYPE (rs2,rs1,rd,op) => true
   | ADDIW (imm,rs1,rd) => true
   | SHIFTW (shamt,rs1,rd,op) => true
   | RTYPEW (rs2,rs1,rd,op) => true
   | SHIFTIWOP (shamt,rs1,rd,op) => true
   | CGetPerm (rd,cb) => true
   | CGetType (rd,cb) => true
   | CGetBase (rd,cb) => true
   | CGetLen (rd,cb) => true
   | CGetTag (rd,cb) => true
   | CGetSealed (rd,cb) => true
   | CGetOffset (rd,cb) => true
   | CGetAddr (rd,cb) => true
   | CMove (cd,cs) => true
   | CClearTag (cd,cs) => true
   | CJALR (b__0,cb) =>
      if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__0))
                             (projT1
                              (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))))) then
        true
      else true
   | CSeal (cd,cs,ct) => true
   | CUnseal (cd,cs,ct) => true
   | CAndPerm (cd,cs,rt) => true
   | CSetOffset (cd,cs,rt) => true
   | CIncOffset (cd,cs,rt) => true
   | CSetBounds (cd,cs,rt) => true
   | CSetBoundsExact (cd,cs,rt) => true
   | CToPtr (rd,cb,cs) => true
   | CFromPtr (cd,cb,rs) => true
   | CCall (cs,cb,b__1) =>
      if sumbool_of_bool ((Z.eqb (projT1 (regbits_to_regno b__1))
                             (projT1
                              (regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))))) then
        true
      else
        let g__2 := CCall ((cs, cb, b__1)) in
        false
   | CIncOffsetImmediate (cd,cb,imm12) => true
   | CSetBoundsImmediate (cd,cb,imm12) => true
   | CLoadCap (rd,cs,u,w) => true
   | CStoreCap (rd,rs,w) => true
   | CStoreCapCap (rd,rs) => true
   | CLoadCapCap (rd,rs) => true
   | ILLEGAL (s) => true
   | C_ILLEGAL (s) => true
   | g__2 => false
   end.

Definition _s1496_ (_s1497_ : string) 
: M (option (mword 16)) :=
   
   let _s1498_ := _s1497_ in
   (if ((string_startswith _s1498_ "c.illegal")) then
      (match (string_drop _s1498_ (projT1 (string_length "c.illegal"))) with
       | _s1499_ =>
          (spc_matches_prefix _s1499_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some (tt,(existT _ _s1500_ _)) =>
                       match (string_drop _s1499_ _s1500_) with
                       | _s1501_ =>
                          match (hex_bits_16_matches_prefix _s1501_) with
                          | Some (s,(existT _ _s1502_ _)) =>
                             let p0_ := string_drop _s1501_ _s1502_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 16))
       end)
       : M (option (mword 16))
    else returnm (None  : option (mword 16)))
    : M (option (mword 16)).

Definition _s1488_ (_s1489_ : string) 
: M (option (mword 32)) :=
   
   let _s1490_ := _s1489_ in
   (if ((string_startswith _s1490_ "illegal")) then
      (match (string_drop _s1490_ (projT1 (string_length "illegal"))) with
       | _s1491_ =>
          (spc_matches_prefix _s1491_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some (tt,(existT _ _s1492_ _)) =>
                       match (string_drop _s1491_ _s1492_) with
                       | _s1493_ =>
                          match (hex_bits_32_matches_prefix _s1493_) with
                          | Some (s,(existT _ _s1494_ _)) =>
                             let p0_ := string_drop _s1493_ _s1494_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 32))
       end)
       : M (option (mword 32))
    else returnm (None  : option (mword 32)))
    : M (option (mword 32)).

Definition _s1476_ (_s1477_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1478_ := _s1477_ in
   (if ((string_startswith _s1478_ "sqCap")) then
      (match (string_drop _s1478_ (projT1 (string_length "sqCap"))) with
       | _s1479_ =>
          (spc_matches_prefix _s1479_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1480_ _)) =>
              (match (string_drop _s1479_ _s1480_) with
               | _s1481_ =>
                  (reg_name_matches_prefix _s1481_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1482_ _)) =>
                      (match (string_drop _s1481_ _s1482_) with
                       | _s1483_ =>
                          (sep_matches_prefix _s1483_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1484_ _)) =>
                              (match (string_drop _s1483_ _s1484_) with
                               | _s1485_ =>
                                  (reg_name_matches_prefix _s1485_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (rs,(existT _ _s1486_ _)) =>
                                               let p0_ := string_drop _s1485_ _s1486_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, rs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1464_ (_s1465_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1466_ := _s1465_ in
   (if ((string_startswith _s1466_ "lqCap")) then
      (match (string_drop _s1466_ (projT1 (string_length "lqCap"))) with
       | _s1467_ =>
          (spc_matches_prefix _s1467_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1468_ _)) =>
              (match (string_drop _s1467_ _s1468_) with
               | _s1469_ =>
                  (reg_name_matches_prefix _s1469_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1470_ _)) =>
                      (match (string_drop _s1469_ _s1470_) with
                       | _s1471_ =>
                          (sep_matches_prefix _s1471_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1472_ _)) =>
                              (match (string_drop _s1471_ _s1472_) with
                               | _s1473_ =>
                                  (reg_name_matches_prefix _s1473_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (rs,(existT _ _s1474_ _)) =>
                                               let p0_ := string_drop _s1473_ _s1474_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, rs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1449_ (_s1450_ : string) 
: M (option ((word_width * mword 5 * mword 5))) :=
   
   let _s1451_ := _s1450_ in
   (if ((string_startswith _s1451_ "s")) then
      (match (string_drop _s1451_ (projT1 (string_length "s"))) with
       | _s1452_ =>
          (size_mnemonic_matches_prefix _s1452_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some (w,(existT _ _s1453_ _)) =>
              let _s1454_ := string_drop _s1452_ _s1453_ in
              (if ((string_startswith _s1454_ "Cap")) then
                 (match (string_drop _s1454_ (projT1 (string_length "Cap"))) with
                  | _s1455_ =>
                     (spc_matches_prefix _s1455_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some (tt,(existT _ _s1456_ _)) =>
                         (match (string_drop _s1455_ _s1456_) with
                          | _s1457_ =>
                             (reg_name_matches_prefix _s1457_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some (rd,(existT _ _s1458_ _)) =>
                                 (match (string_drop _s1457_ _s1458_) with
                                  | _s1459_ =>
                                     (sep_matches_prefix _s1459_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some (tt,(existT _ _s1460_ _)) =>
                                         (match (string_drop _s1459_ _s1460_) with
                                          | _s1461_ =>
                                             (reg_name_matches_prefix _s1461_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             returnm ((match w__4 with
                                                       | Some (rs,(existT _ _s1462_ _)) =>
                                                          let p0_ := string_drop _s1461_ _s1462_ in
                                                          if ((generic_eq p0_ "")) then
                                                            Some
                                                              ((w, rd, rs))
                                                          else None
                                                       | _ => None
                                                       end)
                                              : option ((word_width * mword 5 * mword 5)))
                                          end)
                                          : M (option ((word_width * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None  : option ((word_width * mword 5 * mword 5)))
                                      end)
                                      : M (option ((word_width * mword 5 * mword 5)))
                                  end)
                                  : M (option ((word_width * mword 5 * mword 5)))
                              | _ => returnm (None  : option ((word_width * mword 5 * mword 5)))
                              end)
                              : M (option ((word_width * mword 5 * mword 5)))
                          end)
                          : M (option ((word_width * mword 5 * mword 5)))
                      | _ => returnm (None  : option ((word_width * mword 5 * mword 5)))
                      end)
                      : M (option ((word_width * mword 5 * mword 5)))
                  end)
                  : M (option ((word_width * mword 5 * mword 5)))
               else returnm (None  : option ((word_width * mword 5 * mword 5))))
               : M (option ((word_width * mword 5 * mword 5)))
           | _ => returnm (None  : option ((word_width * mword 5 * mword 5)))
           end)
           : M (option ((word_width * mword 5 * mword 5)))
       end)
       : M (option ((word_width * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * mword 5 * mword 5))))
    : M (option ((word_width * mword 5 * mword 5))).

Definition _s1432_ (_s1433_ : string) 
: M (option ((word_width * bool * mword 5 * mword 5))) :=
   
   let _s1434_ := _s1433_ in
   (if ((string_startswith _s1434_ "l")) then
      (match (string_drop _s1434_ (projT1 (string_length "l"))) with
       | _s1435_ =>
          (size_mnemonic_matches_prefix _s1435_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some (w,(existT _ _s1436_ _)) =>
              (match (string_drop _s1435_ _s1436_) with
               | _s1437_ =>
                  (maybe_u_matches_prefix _s1437_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (u,(existT _ _s1438_ _)) =>
                      let _s1439_ := string_drop _s1437_ _s1438_ in
                      (if ((string_startswith _s1439_ "Cap")) then
                         (match (string_drop _s1439_ (projT1 (string_length "Cap"))) with
                          | _s1440_ =>
                             (spc_matches_prefix _s1440_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some (tt,(existT _ _s1441_ _)) =>
                                 (match (string_drop _s1440_ _s1441_) with
                                  | _s1442_ =>
                                     (reg_name_matches_prefix _s1442_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some (rd,(existT _ _s1443_ _)) =>
                                         (match (string_drop _s1442_ _s1443_) with
                                          | _s1444_ =>
                                             (sep_matches_prefix _s1444_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some (tt,(existT _ _s1445_ _)) =>
                                                 (match (string_drop _s1444_ _s1445_) with
                                                  | _s1446_ =>
                                                     (reg_name_matches_prefix _s1446_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     returnm ((match w__5 with
                                                               | Some (cs,(existT _ _s1447_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1446_ _s1447_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((w, u, rd, cs))
                                                                  else None
                                                               | _ => None
                                                               end)
                                                      : option ((word_width * bool * mword 5 * mword 5)))
                                                  end)
                                                  : M (option ((word_width * bool * mword 5 * mword 5)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((word_width * bool * mword 5 * mword 5)))
                                              end)
                                              : M (option ((word_width * bool * mword 5 * mword 5)))
                                          end)
                                          : M (option ((word_width * bool * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None
                                          : option ((word_width * bool * mword 5 * mword 5)))
                                      end)
                                      : M (option ((word_width * bool * mword 5 * mword 5)))
                                  end)
                                  : M (option ((word_width * bool * mword 5 * mword 5)))
                              | _ =>
                                 returnm (None  : option ((word_width * bool * mword 5 * mword 5)))
                              end)
                              : M (option ((word_width * bool * mword 5 * mword 5)))
                          end)
                          : M (option ((word_width * bool * mword 5 * mword 5)))
                       else returnm (None  : option ((word_width * bool * mword 5 * mword 5))))
                       : M (option ((word_width * bool * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((word_width * bool * mword 5 * mword 5)))
                   end)
                   : M (option ((word_width * bool * mword 5 * mword 5)))
               end)
               : M (option ((word_width * bool * mword 5 * mword 5)))
           | _ => returnm (None  : option ((word_width * bool * mword 5 * mword 5)))
           end)
           : M (option ((word_width * bool * mword 5 * mword 5)))
       end)
       : M (option ((word_width * bool * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * bool * mword 5 * mword 5))))
    : M (option ((word_width * bool * mword 5 * mword 5))).

Definition _s1416_ (_s1417_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s1418_ := _s1417_ in
   (if ((string_startswith _s1418_ "CSetBoundsImmediate")) then
      (match (string_drop _s1418_ (projT1 (string_length "CSetBoundsImmediate"))) with
       | _s1419_ =>
          (spc_matches_prefix _s1419_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1420_ _)) =>
              (match (string_drop _s1419_ _s1420_) with
               | _s1421_ =>
                  (reg_name_matches_prefix _s1421_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1422_ _)) =>
                      (match (string_drop _s1421_ _s1422_) with
                       | _s1423_ =>
                          (sep_matches_prefix _s1423_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1424_ _)) =>
                              (match (string_drop _s1423_ _s1424_) with
                               | _s1425_ =>
                                  (reg_name_matches_prefix _s1425_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1426_ _)) =>
                                      (match (string_drop _s1425_ _s1426_) with
                                       | _s1427_ =>
                                          (sep_matches_prefix _s1427_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s1428_ _)) =>
                                                       match (string_drop _s1427_ _s1428_) with
                                                       | _s1429_ =>
                                                          match (hex_bits_12_matches_prefix _s1429_) with
                                                          | Some (imm12,(existT _ _s1430_ _)) =>
                                                             let p0_ := string_drop _s1429_ _s1430_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((cd, cb, imm12))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s1400_ (_s1401_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s1402_ := _s1401_ in
   (if ((string_startswith _s1402_ "CIncOffsetImmediate")) then
      (match (string_drop _s1402_ (projT1 (string_length "CIncOffsetImmediate"))) with
       | _s1403_ =>
          (spc_matches_prefix _s1403_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1404_ _)) =>
              (match (string_drop _s1403_ _s1404_) with
               | _s1405_ =>
                  (reg_name_matches_prefix _s1405_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1406_ _)) =>
                      (match (string_drop _s1405_ _s1406_) with
                       | _s1407_ =>
                          (sep_matches_prefix _s1407_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1408_ _)) =>
                              (match (string_drop _s1407_ _s1408_) with
                               | _s1409_ =>
                                  (reg_name_matches_prefix _s1409_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1410_ _)) =>
                                      (match (string_drop _s1409_ _s1410_) with
                                       | _s1411_ =>
                                          (sep_matches_prefix _s1411_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s1412_ _)) =>
                                                       match (string_drop _s1411_ _s1412_) with
                                                       | _s1413_ =>
                                                          match (hex_bits_12_matches_prefix _s1413_) with
                                                          | Some (imm12,(existT _ _s1414_ _)) =>
                                                             let p0_ := string_drop _s1413_ _s1414_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((cd, cb, imm12))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s1388_ (_s1389_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1390_ := _s1389_ in
   (if ((string_startswith _s1390_ "CCallFast")) then
      (match (string_drop _s1390_ (projT1 (string_length "CCallFast"))) with
       | _s1391_ =>
          (spc_matches_prefix _s1391_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1392_ _)) =>
              (match (string_drop _s1391_ _s1392_) with
               | _s1393_ =>
                  (reg_name_matches_prefix _s1393_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cs,(existT _ _s1394_ _)) =>
                      (match (string_drop _s1393_ _s1394_) with
                       | _s1395_ =>
                          (sep_matches_prefix _s1395_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1396_ _)) =>
                              (match (string_drop _s1395_ _s1396_) with
                               | _s1397_ =>
                                  (reg_name_matches_prefix _s1397_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1398_ _)) =>
                                               let p0_ := string_drop _s1397_ _s1398_ in
                                               if ((generic_eq p0_ "")) then Some ((cs, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1372_ (_s1373_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1374_ := _s1373_ in
   (if ((string_startswith _s1374_ "CFromPtr")) then
      (match (string_drop _s1374_ (projT1 (string_length "CFromPtr"))) with
       | _s1375_ =>
          (spc_matches_prefix _s1375_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1376_ _)) =>
              (match (string_drop _s1375_ _s1376_) with
               | _s1377_ =>
                  (reg_name_matches_prefix _s1377_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1378_ _)) =>
                      (match (string_drop _s1377_ _s1378_) with
                       | _s1379_ =>
                          (sep_matches_prefix _s1379_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1380_ _)) =>
                              (match (string_drop _s1379_ _s1380_) with
                               | _s1381_ =>
                                  (reg_name_matches_prefix _s1381_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1382_ _)) =>
                                      (match (string_drop _s1381_ _s1382_) with
                                       | _s1383_ =>
                                          (sep_matches_prefix _s1383_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1384_ _)) =>
                                              (match (string_drop _s1383_ _s1384_) with
                                               | _s1385_ =>
                                                  (reg_name_matches_prefix _s1385_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rs,(existT _ _s1386_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1385_ _s1386_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cb, rs))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1356_ (_s1357_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1358_ := _s1357_ in
   (if ((string_startswith _s1358_ "CToPtr")) then
      (match (string_drop _s1358_ (projT1 (string_length "CToPtr"))) with
       | _s1359_ =>
          (spc_matches_prefix _s1359_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1360_ _)) =>
              (match (string_drop _s1359_ _s1360_) with
               | _s1361_ =>
                  (reg_name_matches_prefix _s1361_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1362_ _)) =>
                      (match (string_drop _s1361_ _s1362_) with
                       | _s1363_ =>
                          (sep_matches_prefix _s1363_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1364_ _)) =>
                              (match (string_drop _s1363_ _s1364_) with
                               | _s1365_ =>
                                  (reg_name_matches_prefix _s1365_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1366_ _)) =>
                                      (match (string_drop _s1365_ _s1366_) with
                                       | _s1367_ =>
                                          (sep_matches_prefix _s1367_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1368_ _)) =>
                                              (match (string_drop _s1367_ _s1368_) with
                                               | _s1369_ =>
                                                  (reg_name_matches_prefix _s1369_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (cs,(existT _ _s1370_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1369_ _s1370_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rd, cb, cs))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1340_ (_s1341_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1342_ := _s1341_ in
   (if ((string_startswith _s1342_ "CSetBoundsExact")) then
      (match (string_drop _s1342_ (projT1 (string_length "CSetBoundsExact"))) with
       | _s1343_ =>
          (spc_matches_prefix _s1343_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1344_ _)) =>
              (match (string_drop _s1343_ _s1344_) with
               | _s1345_ =>
                  (reg_name_matches_prefix _s1345_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1346_ _)) =>
                      (match (string_drop _s1345_ _s1346_) with
                       | _s1347_ =>
                          (sep_matches_prefix _s1347_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1348_ _)) =>
                              (match (string_drop _s1347_ _s1348_) with
                               | _s1349_ =>
                                  (reg_name_matches_prefix _s1349_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1350_ _)) =>
                                      (match (string_drop _s1349_ _s1350_) with
                                       | _s1351_ =>
                                          (sep_matches_prefix _s1351_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1352_ _)) =>
                                              (match (string_drop _s1351_ _s1352_) with
                                               | _s1353_ =>
                                                  (reg_name_matches_prefix _s1353_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1354_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1353_ _s1354_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1324_ (_s1325_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1326_ := _s1325_ in
   (if ((string_startswith _s1326_ "CSetBounds")) then
      (match (string_drop _s1326_ (projT1 (string_length "CSetBounds"))) with
       | _s1327_ =>
          (spc_matches_prefix _s1327_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1328_ _)) =>
              (match (string_drop _s1327_ _s1328_) with
               | _s1329_ =>
                  (reg_name_matches_prefix _s1329_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1330_ _)) =>
                      (match (string_drop _s1329_ _s1330_) with
                       | _s1331_ =>
                          (sep_matches_prefix _s1331_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1332_ _)) =>
                              (match (string_drop _s1331_ _s1332_) with
                               | _s1333_ =>
                                  (reg_name_matches_prefix _s1333_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1334_ _)) =>
                                      (match (string_drop _s1333_ _s1334_) with
                                       | _s1335_ =>
                                          (sep_matches_prefix _s1335_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1336_ _)) =>
                                              (match (string_drop _s1335_ _s1336_) with
                                               | _s1337_ =>
                                                  (reg_name_matches_prefix _s1337_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1338_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1337_ _s1338_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1308_ (_s1309_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1310_ := _s1309_ in
   (if ((string_startswith _s1310_ "CIncOffset")) then
      (match (string_drop _s1310_ (projT1 (string_length "CIncOffset"))) with
       | _s1311_ =>
          (spc_matches_prefix _s1311_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1312_ _)) =>
              (match (string_drop _s1311_ _s1312_) with
               | _s1313_ =>
                  (reg_name_matches_prefix _s1313_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1314_ _)) =>
                      (match (string_drop _s1313_ _s1314_) with
                       | _s1315_ =>
                          (sep_matches_prefix _s1315_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1316_ _)) =>
                              (match (string_drop _s1315_ _s1316_) with
                               | _s1317_ =>
                                  (reg_name_matches_prefix _s1317_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1318_ _)) =>
                                      (match (string_drop _s1317_ _s1318_) with
                                       | _s1319_ =>
                                          (sep_matches_prefix _s1319_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1320_ _)) =>
                                              (match (string_drop _s1319_ _s1320_) with
                                               | _s1321_ =>
                                                  (reg_name_matches_prefix _s1321_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1322_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1321_ _s1322_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1292_ (_s1293_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1294_ := _s1293_ in
   (if ((string_startswith _s1294_ "CSetOffset")) then
      (match (string_drop _s1294_ (projT1 (string_length "CSetOffset"))) with
       | _s1295_ =>
          (spc_matches_prefix _s1295_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1296_ _)) =>
              (match (string_drop _s1295_ _s1296_) with
               | _s1297_ =>
                  (reg_name_matches_prefix _s1297_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1298_ _)) =>
                      (match (string_drop _s1297_ _s1298_) with
                       | _s1299_ =>
                          (sep_matches_prefix _s1299_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1300_ _)) =>
                              (match (string_drop _s1299_ _s1300_) with
                               | _s1301_ =>
                                  (reg_name_matches_prefix _s1301_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1302_ _)) =>
                                      (match (string_drop _s1301_ _s1302_) with
                                       | _s1303_ =>
                                          (sep_matches_prefix _s1303_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1304_ _)) =>
                                              (match (string_drop _s1303_ _s1304_) with
                                               | _s1305_ =>
                                                  (reg_name_matches_prefix _s1305_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1306_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1305_ _s1306_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1276_ (_s1277_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1278_ := _s1277_ in
   (if ((string_startswith _s1278_ "CAndPerm")) then
      (match (string_drop _s1278_ (projT1 (string_length "CAndPerm"))) with
       | _s1279_ =>
          (spc_matches_prefix _s1279_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1280_ _)) =>
              (match (string_drop _s1279_ _s1280_) with
               | _s1281_ =>
                  (reg_name_matches_prefix _s1281_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1282_ _)) =>
                      (match (string_drop _s1281_ _s1282_) with
                       | _s1283_ =>
                          (sep_matches_prefix _s1283_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1284_ _)) =>
                              (match (string_drop _s1283_ _s1284_) with
                               | _s1285_ =>
                                  (reg_name_matches_prefix _s1285_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1286_ _)) =>
                                      (match (string_drop _s1285_ _s1286_) with
                                       | _s1287_ =>
                                          (sep_matches_prefix _s1287_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1288_ _)) =>
                                              (match (string_drop _s1287_ _s1288_) with
                                               | _s1289_ =>
                                                  (reg_name_matches_prefix _s1289_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1290_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1289_ _s1290_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, rt))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1260_ (_s1261_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1262_ := _s1261_ in
   (if ((string_startswith _s1262_ "CUnseal")) then
      (match (string_drop _s1262_ (projT1 (string_length "CUnseal"))) with
       | _s1263_ =>
          (spc_matches_prefix _s1263_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1264_ _)) =>
              (match (string_drop _s1263_ _s1264_) with
               | _s1265_ =>
                  (reg_name_matches_prefix _s1265_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1266_ _)) =>
                      (match (string_drop _s1265_ _s1266_) with
                       | _s1267_ =>
                          (sep_matches_prefix _s1267_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1268_ _)) =>
                              (match (string_drop _s1267_ _s1268_) with
                               | _s1269_ =>
                                  (reg_name_matches_prefix _s1269_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1270_ _)) =>
                                      (match (string_drop _s1269_ _s1270_) with
                                       | _s1271_ =>
                                          (sep_matches_prefix _s1271_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1272_ _)) =>
                                              (match (string_drop _s1271_ _s1272_) with
                                               | _s1273_ =>
                                                  (reg_name_matches_prefix _s1273_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (ct,(existT _ _s1274_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1273_ _s1274_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, ct))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1244_ (_s1245_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1246_ := _s1245_ in
   (if ((string_startswith _s1246_ "CSeal")) then
      (match (string_drop _s1246_ (projT1 (string_length "CSeal"))) with
       | _s1247_ =>
          (spc_matches_prefix _s1247_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1248_ _)) =>
              (match (string_drop _s1247_ _s1248_) with
               | _s1249_ =>
                  (reg_name_matches_prefix _s1249_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1250_ _)) =>
                      (match (string_drop _s1249_ _s1250_) with
                       | _s1251_ =>
                          (sep_matches_prefix _s1251_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1252_ _)) =>
                              (match (string_drop _s1251_ _s1252_) with
                               | _s1253_ =>
                                  (reg_name_matches_prefix _s1253_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1254_ _)) =>
                                      (match (string_drop _s1253_ _s1254_) with
                                       | _s1255_ =>
                                          (sep_matches_prefix _s1255_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1256_ _)) =>
                                              (match (string_drop _s1255_ _s1256_) with
                                               | _s1257_ =>
                                                  (reg_name_matches_prefix _s1257_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (ct,(existT _ _s1258_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1257_ _s1258_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((cd, cs, ct))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1232_ (_s1233_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1234_ := _s1233_ in
   (if ((string_startswith _s1234_ "CJALR")) then
      (match (string_drop _s1234_ (projT1 (string_length "CJALR"))) with
       | _s1235_ =>
          (spc_matches_prefix _s1235_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1236_ _)) =>
              (match (string_drop _s1235_ _s1236_) with
               | _s1237_ =>
                  (reg_name_matches_prefix _s1237_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1238_ _)) =>
                      (match (string_drop _s1237_ _s1238_) with
                       | _s1239_ =>
                          (sep_matches_prefix _s1239_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1240_ _)) =>
                              (match (string_drop _s1239_ _s1240_) with
                               | _s1241_ =>
                                  (reg_name_matches_prefix _s1241_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1242_ _)) =>
                                               let p0_ := string_drop _s1241_ _s1242_ in
                                               if ((generic_eq p0_ "")) then Some ((cd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1224_ (_s1225_ : string) 
: M (option (mword 5)) :=
   
   let _s1226_ := _s1225_ in
   (if ((string_startswith _s1226_ "CJR")) then
      (match (string_drop _s1226_ (projT1 (string_length "CJR"))) with
       | _s1227_ =>
          (spc_matches_prefix _s1227_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1228_ _)) =>
              (match (string_drop _s1227_ _s1228_) with
               | _s1229_ =>
                  (reg_name_matches_prefix _s1229_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some (cb,(existT _ _s1230_ _)) =>
                               let p0_ := string_drop _s1229_ _s1230_ in
                               if ((generic_eq p0_ "")) then Some (cb)
                               else None
                            | _ => None
                            end)
                   : option (mword 5))
               end)
               : M (option (mword 5))
           | _ => returnm (None  : option (mword 5))
           end)
           : M (option (mword 5))
       end)
       : M (option (mword 5))
    else returnm (None  : option (mword 5)))
    : M (option (mword 5)).

Definition _s1212_ (_s1213_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1214_ := _s1213_ in
   (if ((string_startswith _s1214_ "CClearTag")) then
      (match (string_drop _s1214_ (projT1 (string_length "CClearTag"))) with
       | _s1215_ =>
          (spc_matches_prefix _s1215_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1216_ _)) =>
              (match (string_drop _s1215_ _s1216_) with
               | _s1217_ =>
                  (reg_name_matches_prefix _s1217_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1218_ _)) =>
                      (match (string_drop _s1217_ _s1218_) with
                       | _s1219_ =>
                          (sep_matches_prefix _s1219_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1220_ _)) =>
                              (match (string_drop _s1219_ _s1220_) with
                               | _s1221_ =>
                                  (reg_name_matches_prefix _s1221_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cs,(existT _ _s1222_ _)) =>
                                               let p0_ := string_drop _s1221_ _s1222_ in
                                               if ((generic_eq p0_ "")) then Some ((cd, cs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1200_ (_s1201_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1202_ := _s1201_ in
   (if ((string_startswith _s1202_ "CMove")) then
      (match (string_drop _s1202_ (projT1 (string_length "CMove"))) with
       | _s1203_ =>
          (spc_matches_prefix _s1203_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1204_ _)) =>
              (match (string_drop _s1203_ _s1204_) with
               | _s1205_ =>
                  (reg_name_matches_prefix _s1205_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1206_ _)) =>
                      (match (string_drop _s1205_ _s1206_) with
                       | _s1207_ =>
                          (sep_matches_prefix _s1207_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1208_ _)) =>
                              (match (string_drop _s1207_ _s1208_) with
                               | _s1209_ =>
                                  (reg_name_matches_prefix _s1209_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cs,(existT _ _s1210_ _)) =>
                                               let p0_ := string_drop _s1209_ _s1210_ in
                                               if ((generic_eq p0_ "")) then Some ((cd, cs))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1188_ (_s1189_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1190_ := _s1189_ in
   (if ((string_startswith _s1190_ "CGetAddr")) then
      (match (string_drop _s1190_ (projT1 (string_length "CGetAddr"))) with
       | _s1191_ =>
          (spc_matches_prefix _s1191_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1192_ _)) =>
              (match (string_drop _s1191_ _s1192_) with
               | _s1193_ =>
                  (reg_name_matches_prefix _s1193_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1194_ _)) =>
                      (match (string_drop _s1193_ _s1194_) with
                       | _s1195_ =>
                          (sep_matches_prefix _s1195_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1196_ _)) =>
                              (match (string_drop _s1195_ _s1196_) with
                               | _s1197_ =>
                                  (reg_name_matches_prefix _s1197_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1198_ _)) =>
                                               let p0_ := string_drop _s1197_ _s1198_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1176_ (_s1177_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1178_ := _s1177_ in
   (if ((string_startswith _s1178_ "CGetOffset")) then
      (match (string_drop _s1178_ (projT1 (string_length "CGetOffset"))) with
       | _s1179_ =>
          (spc_matches_prefix _s1179_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1180_ _)) =>
              (match (string_drop _s1179_ _s1180_) with
               | _s1181_ =>
                  (reg_name_matches_prefix _s1181_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1182_ _)) =>
                      (match (string_drop _s1181_ _s1182_) with
                       | _s1183_ =>
                          (sep_matches_prefix _s1183_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1184_ _)) =>
                              (match (string_drop _s1183_ _s1184_) with
                               | _s1185_ =>
                                  (reg_name_matches_prefix _s1185_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1186_ _)) =>
                                               let p0_ := string_drop _s1185_ _s1186_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1164_ (_s1165_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1166_ := _s1165_ in
   (if ((string_startswith _s1166_ "CGetSealed")) then
      (match (string_drop _s1166_ (projT1 (string_length "CGetSealed"))) with
       | _s1167_ =>
          (spc_matches_prefix _s1167_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1168_ _)) =>
              (match (string_drop _s1167_ _s1168_) with
               | _s1169_ =>
                  (reg_name_matches_prefix _s1169_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1170_ _)) =>
                      (match (string_drop _s1169_ _s1170_) with
                       | _s1171_ =>
                          (sep_matches_prefix _s1171_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1172_ _)) =>
                              (match (string_drop _s1171_ _s1172_) with
                               | _s1173_ =>
                                  (reg_name_matches_prefix _s1173_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1174_ _)) =>
                                               let p0_ := string_drop _s1173_ _s1174_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1152_ (_s1153_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1154_ := _s1153_ in
   (if ((string_startswith _s1154_ "CGetTag")) then
      (match (string_drop _s1154_ (projT1 (string_length "CGetTag"))) with
       | _s1155_ =>
          (spc_matches_prefix _s1155_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1156_ _)) =>
              (match (string_drop _s1155_ _s1156_) with
               | _s1157_ =>
                  (reg_name_matches_prefix _s1157_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1158_ _)) =>
                      (match (string_drop _s1157_ _s1158_) with
                       | _s1159_ =>
                          (sep_matches_prefix _s1159_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1160_ _)) =>
                              (match (string_drop _s1159_ _s1160_) with
                               | _s1161_ =>
                                  (reg_name_matches_prefix _s1161_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1162_ _)) =>
                                               let p0_ := string_drop _s1161_ _s1162_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1140_ (_s1141_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1142_ := _s1141_ in
   (if ((string_startswith _s1142_ "CGetLen")) then
      (match (string_drop _s1142_ (projT1 (string_length "CGetLen"))) with
       | _s1143_ =>
          (spc_matches_prefix _s1143_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1144_ _)) =>
              (match (string_drop _s1143_ _s1144_) with
               | _s1145_ =>
                  (reg_name_matches_prefix _s1145_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1146_ _)) =>
                      (match (string_drop _s1145_ _s1146_) with
                       | _s1147_ =>
                          (sep_matches_prefix _s1147_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1148_ _)) =>
                              (match (string_drop _s1147_ _s1148_) with
                               | _s1149_ =>
                                  (reg_name_matches_prefix _s1149_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1150_ _)) =>
                                               let p0_ := string_drop _s1149_ _s1150_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1128_ (_s1129_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1130_ := _s1129_ in
   (if ((string_startswith _s1130_ "CGetBase")) then
      (match (string_drop _s1130_ (projT1 (string_length "CGetBase"))) with
       | _s1131_ =>
          (spc_matches_prefix _s1131_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1132_ _)) =>
              (match (string_drop _s1131_ _s1132_) with
               | _s1133_ =>
                  (reg_name_matches_prefix _s1133_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1134_ _)) =>
                      (match (string_drop _s1133_ _s1134_) with
                       | _s1135_ =>
                          (sep_matches_prefix _s1135_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1136_ _)) =>
                              (match (string_drop _s1135_ _s1136_) with
                               | _s1137_ =>
                                  (reg_name_matches_prefix _s1137_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1138_ _)) =>
                                               let p0_ := string_drop _s1137_ _s1138_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1116_ (_s1117_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1118_ := _s1117_ in
   (if ((string_startswith _s1118_ "CGetType")) then
      (match (string_drop _s1118_ (projT1 (string_length "CGetType"))) with
       | _s1119_ =>
          (spc_matches_prefix _s1119_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1120_ _)) =>
              (match (string_drop _s1119_ _s1120_) with
               | _s1121_ =>
                  (reg_name_matches_prefix _s1121_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1122_ _)) =>
                      (match (string_drop _s1121_ _s1122_) with
                       | _s1123_ =>
                          (sep_matches_prefix _s1123_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1124_ _)) =>
                              (match (string_drop _s1123_ _s1124_) with
                               | _s1125_ =>
                                  (reg_name_matches_prefix _s1125_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1126_ _)) =>
                                               let p0_ := string_drop _s1125_ _s1126_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1104_ (_s1105_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1106_ := _s1105_ in
   (if ((string_startswith _s1106_ "CGetPerm")) then
      (match (string_drop _s1106_ (projT1 (string_length "CGetPerm"))) with
       | _s1107_ =>
          (spc_matches_prefix _s1107_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1108_ _)) =>
              (match (string_drop _s1107_ _s1108_) with
               | _s1109_ =>
                  (reg_name_matches_prefix _s1109_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1110_ _)) =>
                      (match (string_drop _s1109_ _s1110_) with
                       | _s1111_ =>
                          (sep_matches_prefix _s1111_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1112_ _)) =>
                              (match (string_drop _s1111_ _s1112_) with
                               | _s1113_ =>
                                  (reg_name_matches_prefix _s1113_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1114_ _)) =>
                                               let p0_ := string_drop _s1113_ _s1114_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, cb))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1089_ (_s1090_ : string) 
: M (option ((sopw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1090_ with
    | _s1091_ =>
       (shiftiwop_mnemonic_matches_prefix _s1091_) >>= fun w__0 : option ((sopw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1092_ _)) =>
           (match (string_drop _s1091_ _s1092_) with
            | _s1093_ =>
               (spc_matches_prefix _s1093_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1094_ _)) =>
                   (match (string_drop _s1093_ _s1094_) with
                    | _s1095_ =>
                       (reg_name_matches_prefix _s1095_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1096_ _)) =>
                           (match (string_drop _s1095_ _s1096_) with
                            | _s1097_ =>
                               (sep_matches_prefix _s1097_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1098_ _)) =>
                                   (match (string_drop _s1097_ _s1098_) with
                                    | _s1099_ =>
                                       (reg_name_matches_prefix _s1099_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       returnm ((match w__4 with
                                                 | Some (rs1,(existT _ _s1100_ _)) =>
                                                    match (string_drop _s1099_ _s1100_) with
                                                    | _s1101_ =>
                                                       match (hex_bits_5_matches_prefix _s1101_) with
                                                       | Some (shamt,(existT _ _s1102_ _)) =>
                                                          let p0_ := string_drop _s1101_ _s1102_ in
                                                          if ((generic_eq p0_ "")) then
                                                            Some
                                                              ((op, rd, rs1, shamt))
                                                          else None
                                                       | _ => None
                                                       end
                                                    end
                                                 | _ => None
                                                 end)
                                        : option ((sopw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sopw * mword 5 * mword 5 * mword 5))).

Definition _s1072_ (_s1073_ : string) 
: M (option ((ropw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1073_ with
    | _s1074_ =>
       (rtypew_mnemonic_matches_prefix _s1074_) >>= fun w__0 : option ((ropw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1075_ _)) =>
           (match (string_drop _s1074_ _s1075_) with
            | _s1076_ =>
               (spc_matches_prefix _s1076_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1077_ _)) =>
                   (match (string_drop _s1076_ _s1077_) with
                    | _s1078_ =>
                       (reg_name_matches_prefix _s1078_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1079_ _)) =>
                           (match (string_drop _s1078_ _s1079_) with
                            | _s1080_ =>
                               (sep_matches_prefix _s1080_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1081_ _)) =>
                                   (match (string_drop _s1080_ _s1081_) with
                                    | _s1082_ =>
                                       (reg_name_matches_prefix _s1082_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1083_ _)) =>
                                           (match (string_drop _s1082_ _s1083_) with
                                            | _s1084_ =>
                                               (sep_matches_prefix _s1084_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some (tt,(existT _ _s1085_ _)) =>
                                                   (match (string_drop _s1084_ _s1085_) with
                                                    | _s1086_ =>
                                                       (reg_name_matches_prefix _s1086_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some (rs2,(existT _ _s1087_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1086_ _s1087_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((ropw * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((ropw * mword 5 * mword 5 * mword 5))).

Definition _s1055_ (_s1056_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1056_ with
    | _s1057_ =>
       (shiftw_mnemonic_matches_prefix _s1057_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1058_ _)) =>
           (match (string_drop _s1057_ _s1058_) with
            | _s1059_ =>
               (spc_matches_prefix _s1059_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1060_ _)) =>
                   (match (string_drop _s1059_ _s1060_) with
                    | _s1061_ =>
                       (reg_name_matches_prefix _s1061_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1062_ _)) =>
                           (match (string_drop _s1061_ _s1062_) with
                            | _s1063_ =>
                               (sep_matches_prefix _s1063_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1064_ _)) =>
                                   (match (string_drop _s1063_ _s1064_) with
                                    | _s1065_ =>
                                       (reg_name_matches_prefix _s1065_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1066_ _)) =>
                                           (match (string_drop _s1065_ _s1066_) with
                                            | _s1067_ =>
                                               (sep_matches_prefix _s1067_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s1068_ _)) =>
                                                            match (string_drop _s1067_ _s1068_) with
                                                            | _s1069_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s1069_) with
                                                               | Some (shamt,(existT _ _s1070_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1069_ _s1070_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 5))).

Definition _s1039_ (_s1040_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s1041_ := _s1040_ in
   (if ((string_startswith _s1041_ "addiw")) then
      (match (string_drop _s1041_ (projT1 (string_length "addiw"))) with
       | _s1042_ =>
          (spc_matches_prefix _s1042_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1043_ _)) =>
              (match (string_drop _s1042_ _s1043_) with
               | _s1044_ =>
                  (reg_name_matches_prefix _s1044_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1045_ _)) =>
                      (match (string_drop _s1044_ _s1045_) with
                       | _s1046_ =>
                          (sep_matches_prefix _s1046_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1047_ _)) =>
                              (match (string_drop _s1046_ _s1047_) with
                               | _s1048_ =>
                                  (reg_name_matches_prefix _s1048_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (rs1,(existT _ _s1049_ _)) =>
                                      (match (string_drop _s1048_ _s1049_) with
                                       | _s1050_ =>
                                          (sep_matches_prefix _s1050_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s1051_ _)) =>
                                                       match (string_drop _s1050_ _s1051_) with
                                                       | _s1052_ =>
                                                          match (hex_bits_12_matches_prefix _s1052_) with
                                                          | Some (imm,(existT _ _s1053_ _)) =>
                                                             let p0_ := string_drop _s1052_ _s1053_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s1022_ (_s1023_ : string) 
: M (option ((rop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1023_ with
    | _s1024_ =>
       (rtype_mnemonic_matches_prefix _s1024_) >>= fun w__0 : option ((rop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1025_ _)) =>
           (match (string_drop _s1024_ _s1025_) with
            | _s1026_ =>
               (spc_matches_prefix _s1026_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1027_ _)) =>
                   (match (string_drop _s1026_ _s1027_) with
                    | _s1028_ =>
                       (reg_name_matches_prefix _s1028_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1029_ _)) =>
                           (match (string_drop _s1028_ _s1029_) with
                            | _s1030_ =>
                               (sep_matches_prefix _s1030_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1031_ _)) =>
                                   (match (string_drop _s1030_ _s1031_) with
                                    | _s1032_ =>
                                       (reg_name_matches_prefix _s1032_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1033_ _)) =>
                                           (match (string_drop _s1032_ _s1033_) with
                                            | _s1034_ =>
                                               (sep_matches_prefix _s1034_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some (tt,(existT _ _s1035_ _)) =>
                                                   (match (string_drop _s1034_ _s1035_) with
                                                    | _s1036_ =>
                                                       (reg_name_matches_prefix _s1036_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some (rs2,(existT _ _s1037_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1036_ _s1037_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((rop * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((rop * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((rop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((rop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((rop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((rop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((rop * mword 5 * mword 5 * mword 5))).

Definition _s1007_ (_s1008_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 6))) :=
   
   (match _s1008_ with
    | _s1009_ =>
       (shiftiop_mnemonic_matches_prefix _s1009_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1010_ _)) =>
           (match (string_drop _s1009_ _s1010_) with
            | _s1011_ =>
               (spc_matches_prefix _s1011_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1012_ _)) =>
                   (match (string_drop _s1011_ _s1012_) with
                    | _s1013_ =>
                       (reg_name_matches_prefix _s1013_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1014_ _)) =>
                           (match (string_drop _s1013_ _s1014_) with
                            | _s1015_ =>
                               (sep_matches_prefix _s1015_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1016_ _)) =>
                                   (match (string_drop _s1015_ _s1016_) with
                                    | _s1017_ =>
                                       (reg_name_matches_prefix _s1017_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       returnm ((match w__4 with
                                                 | Some (rs1,(existT _ _s1018_ _)) =>
                                                    match (string_drop _s1017_ _s1018_) with
                                                    | _s1019_ =>
                                                       match (hex_bits_6_matches_prefix _s1019_) with
                                                       | Some (shamt,(existT _ _s1020_ _)) =>
                                                          let p0_ := string_drop _s1019_ _s1020_ in
                                                          if ((generic_eq p0_ "")) then
                                                            Some
                                                              ((op, rd, rs1, shamt))
                                                          else None
                                                       | _ => None
                                                       end
                                                    end
                                                 | _ => None
                                                 end)
                                        : option ((sop * mword 5 * mword 5 * mword 6)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 6)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 6)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 6)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 6)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 6)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 6)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 6))).

Definition _s990_ (_s991_ : string) 
: M (option ((iop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s991_ with
    | _s992_ =>
       (itype_mnemonic_matches_prefix _s992_) >>= fun w__0 : option ((iop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s993_ _)) =>
           (match (string_drop _s992_ _s993_) with
            | _s994_ =>
               (spc_matches_prefix _s994_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s995_ _)) =>
                   (match (string_drop _s994_ _s995_) with
                    | _s996_ =>
                       (reg_name_matches_prefix _s996_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s997_ _)) =>
                           (match (string_drop _s996_ _s997_) with
                            | _s998_ =>
                               (sep_matches_prefix _s998_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s999_ _)) =>
                                   (match (string_drop _s998_ _s999_) with
                                    | _s1000_ =>
                                       (reg_name_matches_prefix _s1000_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1001_ _)) =>
                                           (match (string_drop _s1000_ _s1001_) with
                                            | _s1002_ =>
                                               (sep_matches_prefix _s1002_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s1003_ _)) =>
                                                            match (string_drop _s1002_ _s1003_) with
                                                            | _s1004_ =>
                                                               match (hex_bits_12_matches_prefix
                                                                        _s1004_) with
                                                               | Some (imm,(existT _ _s1005_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1004_ _s1005_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((iop * mword 5 * mword 5 * mword 12)))
                                            end)
                                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                        | _ =>
                                           returnm (None
                                            : option ((iop * mword 5 * mword 5 * mword 12)))
                                        end)
                                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                    end)
                                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                | _ =>
                                   returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                                end)
                                : M (option ((iop * mword 5 * mword 5 * mword 12)))
                            end)
                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                        end)
                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                    end)
                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                end)
                : M (option ((iop * mword 5 * mword 5 * mword 12)))
            end)
            : M (option ((iop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((iop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((iop * mword 5 * mword 5 * mword 12))).

Definition _s973_ (_s974_ : string) 
: M (option ((bop * mword 5 * mword 5 * mword 13))) :=
   
   (match _s974_ with
    | _s975_ =>
       (btype_mnemonic_matches_prefix _s975_) >>= fun w__0 : option ((bop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s976_ _)) =>
           (match (string_drop _s975_ _s976_) with
            | _s977_ =>
               (spc_matches_prefix _s977_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s978_ _)) =>
                   (match (string_drop _s977_ _s978_) with
                    | _s979_ =>
                       (reg_name_matches_prefix _s979_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rs1,(existT _ _s980_ _)) =>
                           (match (string_drop _s979_ _s980_) with
                            | _s981_ =>
                               (sep_matches_prefix _s981_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s982_ _)) =>
                                   (match (string_drop _s981_ _s982_) with
                                    | _s983_ =>
                                       (reg_name_matches_prefix _s983_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs2,(existT _ _s984_ _)) =>
                                           (match (string_drop _s983_ _s984_) with
                                            | _s985_ =>
                                               (sep_matches_prefix _s985_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s986_ _)) =>
                                                            match (string_drop _s985_ _s986_) with
                                                            | _s987_ =>
                                                               match (hex_bits_13_matches_prefix
                                                                        _s987_) with
                                                               | Some (imm,(existT _ _s988_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s987_ _s988_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rs1, rs2, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((bop * mword 5 * mword 5 * mword 13)))
                                            end)
                                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                        | _ =>
                                           returnm (None
                                            : option ((bop * mword 5 * mword 5 * mword 13)))
                                        end)
                                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                    end)
                                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                | _ =>
                                   returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                                end)
                                : M (option ((bop * mword 5 * mword 5 * mword 13)))
                            end)
                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                        end)
                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                    end)
                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                end)
                : M (option ((bop * mword 5 * mword 5 * mword 13)))
            end)
            : M (option ((bop * mword 5 * mword 5 * mword 13)))
        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
        end)
        : M (option ((bop * mword 5 * mword 5 * mword 13)))
    end)
    : M (option ((bop * mword 5 * mword 5 * mword 13))).

Definition _s957_ (_s958_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s959_ := _s958_ in
   (if ((string_startswith _s959_ "jalr")) then
      (match (string_drop _s959_ (projT1 (string_length "jalr"))) with
       | _s960_ =>
          (spc_matches_prefix _s960_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s961_ _)) =>
              (match (string_drop _s960_ _s961_) with
               | _s962_ =>
                  (reg_name_matches_prefix _s962_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s963_ _)) =>
                      (match (string_drop _s962_ _s963_) with
                       | _s964_ =>
                          (sep_matches_prefix _s964_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s965_ _)) =>
                              (match (string_drop _s964_ _s965_) with
                               | _s966_ =>
                                  (reg_name_matches_prefix _s966_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (rs1,(existT _ _s967_ _)) =>
                                      (match (string_drop _s966_ _s967_) with
                                       | _s968_ =>
                                          (sep_matches_prefix _s968_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s969_ _)) =>
                                                       match (string_drop _s968_ _s969_) with
                                                       | _s970_ =>
                                                          match (hex_bits_12_matches_prefix _s970_) with
                                                          | Some (imm,(existT _ _s971_ _)) =>
                                                             let p0_ := string_drop _s970_ _s971_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s945_ (_s946_ : string) 
: M (option ((mword 5 * mword 21))) :=
   
   let _s947_ := _s946_ in
   (if ((string_startswith _s947_ "jal")) then
      (match (string_drop _s947_ (projT1 (string_length "jal"))) with
       | _s948_ =>
          (spc_matches_prefix _s948_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s949_ _)) =>
              (match (string_drop _s948_ _s949_) with
               | _s950_ =>
                  (reg_name_matches_prefix _s950_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s951_ _)) =>
                      (match (string_drop _s950_ _s951_) with
                       | _s952_ =>
                          (sep_matches_prefix _s952_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some (tt,(existT _ _s953_ _)) =>
                                       match (string_drop _s952_ _s953_) with
                                       | _s954_ =>
                                          match (hex_bits_21_matches_prefix _s954_) with
                                          | Some (imm,(existT _ _s955_ _)) =>
                                             let p0_ := string_drop _s954_ _s955_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 21)))
                       end)
                       : M (option ((mword 5 * mword 21)))
                   | _ => returnm (None  : option ((mword 5 * mword 21)))
                   end)
                   : M (option ((mword 5 * mword 21)))
               end)
               : M (option ((mword 5 * mword 21)))
           | _ => returnm (None  : option ((mword 5 * mword 21)))
           end)
           : M (option ((mword 5 * mword 21)))
       end)
       : M (option ((mword 5 * mword 21)))
    else returnm (None  : option ((mword 5 * mword 21))))
    : M (option ((mword 5 * mword 21))).

Definition _s932_ (_s933_ : string) 
: M (option ((uop * mword 5 * mword 20))) :=
   
   (match _s933_ with
    | _s934_ =>
       (utype_mnemonic_matches_prefix _s934_) >>= fun w__0 : option ((uop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s935_ _)) =>
           (match (string_drop _s934_ _s935_) with
            | _s936_ =>
               (spc_matches_prefix _s936_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s937_ _)) =>
                   (match (string_drop _s936_ _s937_) with
                    | _s938_ =>
                       (reg_name_matches_prefix _s938_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s939_ _)) =>
                           (match (string_drop _s938_ _s939_) with
                            | _s940_ =>
                               (sep_matches_prefix _s940_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some (tt,(existT _ _s941_ _)) =>
                                            match (string_drop _s940_ _s941_) with
                                            | _s942_ =>
                                               match (hex_bits_20_matches_prefix _s942_) with
                                               | Some (imm,(existT _ _s943_ _)) =>
                                                  let p0_ := string_drop _s942_ _s943_ in
                                                  if ((generic_eq p0_ "")) then Some ((op, rd, imm))
                                                  else None
                                               | _ => None
                                               end
                                            end
                                         | _ => None
                                         end)
                                : option ((uop * mword 5 * mword 20)))
                            end)
                            : M (option ((uop * mword 5 * mword 20)))
                        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                        end)
                        : M (option ((uop * mword 5 * mword 20)))
                    end)
                    : M (option ((uop * mword 5 * mword 20)))
                | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                end)
                : M (option ((uop * mword 5 * mword 20)))
            end)
            : M (option ((uop * mword 5 * mword 20)))
        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
        end)
        : M (option ((uop * mword 5 * mword 20)))
    end)
    : M (option ((uop * mword 5 * mword 20))).

Definition assembly_backwards_matches (arg_ : string) 
: M (bool) :=
   
   let _s944_ := arg_ in
   (_s932_ _s944_) >>= fun w__0 : option ((uop * mword 5 * mword 20)) =>
   (if ((match w__0 with | Some (op,rd,imm) => true | _ => false end)) then
      (_s932_ _s944_) >>= fun w__1 : option ((uop * mword 5 * mword 20)) =>
      (match w__1 with
       | Some (op,rd,imm) =>
          returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
       | _ => exit tt  : M (bool)
       end)
       : M (bool)
    else
      (_s945_ _s944_) >>= fun w__4 : option ((mword 5 * mword 21)) =>
      (if ((match w__4 with | Some (rd,imm) => true | _ => false end)) then
         (_s945_ _s944_) >>= fun w__5 : option ((mword 5 * mword 21)) =>
         (match w__5 with
          | Some (rd,imm) =>
             returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
          | _ => exit tt  : M (bool)
          end)
          : M (bool)
       else
         (_s957_ _s944_) >>= fun w__8 : option ((mword 5 * mword 5 * mword 12)) =>
         (if ((match w__8 with | Some (rd,rs1,imm) => true | _ => false end)) then
            (_s957_ _s944_) >>= fun w__9 : option ((mword 5 * mword 5 * mword 12)) =>
            (match w__9 with
             | Some (rd,rs1,imm) =>
                returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
             | _ => exit tt  : M (bool)
             end)
             : M (bool)
          else
            (_s973_ _s944_) >>= fun w__12 : option ((bop * mword 5 * mword 5 * mword 13)) =>
            (if ((match w__12 with | Some (op,rs1,rs2,imm) => true | _ => false end)) then
               (_s973_ _s944_) >>= fun w__13 : option ((bop * mword 5 * mword 5 * mword 13)) =>
               (match w__13 with
                | Some (op,rs1,rs2,imm) =>
                   returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
                | _ => exit tt  : M (bool)
                end)
                : M (bool)
             else
               (_s990_ _s944_) >>= fun w__16 : option ((iop * mword 5 * mword 5 * mword 12)) =>
               (if ((match w__16 with | Some (op,rd,rs1,imm) => true | _ => false end)) then
                  (_s990_ _s944_) >>= fun w__17 : option ((iop * mword 5 * mword 5 * mword 12)) =>
                  (match w__17 with
                   | Some (op,rd,rs1,imm) =>
                      returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
                   | _ => exit tt  : M (bool)
                   end)
                   : M (bool)
                else
                  (_s1007_ _s944_) >>= fun w__20 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                  (if ((match w__20 with | Some (op,rd,rs1,shamt) => true | _ => false end)) then
                     (_s1007_ _s944_) >>= fun w__21 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                     (match w__21 with
                      | Some (op,rd,rs1,shamt) =>
                         returnm (projT1
                         (build_ex
                         true
                          : {_bool : bool & ArithFact (_bool = true)}))
                      | _ => exit tt  : M (bool)
                      end)
                      : M (bool)
                   else
                     (_s1022_ _s944_) >>= fun w__24 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                     (if ((match w__24 with | Some (op,rd,rs1,rs2) => true | _ => false end)) then
                        (_s1022_ _s944_) >>= fun w__25 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                        (match w__25 with
                         | Some (op,rd,rs1,rs2) =>
                            returnm (projT1
                            (build_ex
                            true
                             : {_bool : bool & ArithFact (_bool = true)}))
                         | _ => exit tt  : M (bool)
                         end)
                         : M (bool)
                      else
                        (_s1039_ _s944_) >>= fun w__28 : option ((mword 5 * mword 5 * mword 12)) =>
                        (if ((match w__28 with | Some (rd,rs1,imm) => true | _ => false end)) then
                           (_s1039_ _s944_) >>= fun w__29 : option ((mword 5 * mword 5 * mword 12)) =>
                           (match w__29 with
                            | Some (rd,rs1,imm) =>
                               returnm (projT1
                               (build_ex
                               true
                                : {_bool : bool & ArithFact (_bool = true)}))
                            | _ => exit tt  : M (bool)
                            end)
                            : M (bool)
                         else
                           (_s1055_ _s944_) >>= fun w__32 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                           (if ((match w__32 with | Some (op,rd,rs1,shamt) => true | _ => false end))
                            then
                              (_s1055_ _s944_) >>= fun w__33 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                              (match w__33 with
                               | Some (op,rd,rs1,shamt) =>
                                  returnm (projT1
                                  (build_ex
                                  true
                                   : {_bool : bool & ArithFact (_bool = true)}))
                               | _ => exit tt  : M (bool)
                               end)
                               : M (bool)
                            else
                              (_s1072_ _s944_) >>= fun w__36 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                              (if ((match w__36 with | Some (op,rd,rs1,rs2) => true | _ => false end))
                               then
                                 (_s1072_ _s944_) >>= fun w__37 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                                 (match w__37 with
                                  | Some (op,rd,rs1,rs2) =>
                                     returnm (projT1
                                     (build_ex
                                     true
                                      : {_bool : bool & ArithFact (_bool = true)}))
                                  | _ => exit tt  : M (bool)
                                  end)
                                  : M (bool)
                               else
                                 (_s1089_ _s944_) >>= fun w__40 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                 (if ((match w__40 with
                                       | Some (op,rd,rs1,shamt) => true
                                       | _ => false
                                       end)) then
                                    (_s1089_ _s944_) >>= fun w__41 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                    (match w__41 with
                                     | Some (op,rd,rs1,shamt) =>
                                        returnm (projT1
                                        (build_ex
                                        true
                                         : {_bool : bool & ArithFact (_bool = true)}))
                                     | _ => exit tt  : M (bool)
                                     end)
                                     : M (bool)
                                  else
                                    (_s1104_ _s944_) >>= fun w__44 : option ((mword 5 * mword 5)) =>
                                    (if ((match w__44 with | Some (rd,cb) => true | _ => false end))
                                     then
                                       (_s1104_ _s944_) >>= fun w__45 : option ((mword 5 * mword 5)) =>
                                       (match w__45 with
                                        | Some (rd,cb) =>
                                           returnm (projT1
                                           (build_ex
                                           true
                                            : {_bool : bool & ArithFact (_bool = true)}))
                                        | _ => exit tt  : M (bool)
                                        end)
                                        : M (bool)
                                     else
                                       (_s1116_ _s944_) >>= fun w__48 : option ((mword 5 * mword 5)) =>
                                       (if ((match w__48 with
                                             | Some (rd,cb) => true
                                             | _ => false
                                             end)) then
                                          (_s1116_ _s944_) >>= fun w__49 : option ((mword 5 * mword 5)) =>
                                          (match w__49 with
                                           | Some (rd,cb) =>
                                              returnm (projT1
                                              (build_ex
                                              true
                                               : {_bool : bool & ArithFact (_bool = true)}))
                                           | _ => exit tt  : M (bool)
                                           end)
                                           : M (bool)
                                        else
                                          (_s1128_ _s944_) >>= fun w__52 : option ((mword 5 * mword 5)) =>
                                          (if ((match w__52 with
                                                | Some (rd,cb) => true
                                                | _ => false
                                                end)) then
                                             (_s1128_ _s944_) >>= fun w__53 : option ((mword 5 * mword 5)) =>
                                             (match w__53 with
                                              | Some (rd,cb) =>
                                                 returnm (projT1
                                                 (build_ex
                                                 true
                                                  : {_bool : bool & ArithFact (_bool = true)}))
                                              | _ => exit tt  : M (bool)
                                              end)
                                              : M (bool)
                                           else
                                             (_s1140_ _s944_) >>= fun w__56 : option ((mword 5 * mword 5)) =>
                                             (if ((match w__56 with
                                                   | Some (rd,cb) => true
                                                   | _ => false
                                                   end)) then
                                                (_s1140_ _s944_) >>= fun w__57 : option ((mword 5 * mword 5)) =>
                                                (match w__57 with
                                                 | Some (rd,cb) =>
                                                    returnm (projT1
                                                    (build_ex
                                                    true
                                                     : {_bool : bool & ArithFact (_bool = true)}))
                                                 | _ => exit tt  : M (bool)
                                                 end)
                                                 : M (bool)
                                              else
                                                (_s1152_ _s944_) >>= fun w__60 : option ((mword 5 * mword 5)) =>
                                                (if ((match w__60 with
                                                      | Some (rd,cb) => true
                                                      | _ => false
                                                      end)) then
                                                   (_s1152_ _s944_) >>= fun w__61 : option ((mword 5 * mword 5)) =>
                                                   (match w__61 with
                                                    | Some (rd,cb) =>
                                                       returnm (projT1
                                                       (build_ex
                                                       true
                                                        : {_bool : bool & ArithFact (_bool = true)}))
                                                    | _ => exit tt  : M (bool)
                                                    end)
                                                    : M (bool)
                                                 else
                                                   (_s1164_ _s944_) >>= fun w__64 : option ((mword 5 * mword 5)) =>
                                                   (if ((match w__64 with
                                                         | Some (rd,cb) => true
                                                         | _ => false
                                                         end)) then
                                                      (_s1164_ _s944_) >>= fun w__65 : option ((mword 5 * mword 5)) =>
                                                      (match w__65 with
                                                       | Some (rd,cb) =>
                                                          returnm (projT1
                                                          (build_ex
                                                          true
                                                           : {_bool : bool & ArithFact (_bool = true)}))
                                                       | _ => exit tt  : M (bool)
                                                       end)
                                                       : M (bool)
                                                    else
                                                      (_s1176_ _s944_) >>= fun w__68 : option ((mword 5 * mword 5)) =>
                                                      (if ((match w__68 with
                                                            | Some (rd,cb) => true
                                                            | _ => false
                                                            end)) then
                                                         (_s1176_ _s944_) >>= fun w__69 : option ((mword 5 * mword 5)) =>
                                                         (match w__69 with
                                                          | Some (rd,cb) =>
                                                             returnm (projT1
                                                             (build_ex
                                                             true
                                                              : {_bool : bool & ArithFact (_bool =
                                                               true)}))
                                                          | _ => exit tt  : M (bool)
                                                          end)
                                                          : M (bool)
                                                       else
                                                         (_s1188_ _s944_) >>= fun w__72 : option ((mword 5 * mword 5)) =>
                                                         (if ((match w__72 with
                                                               | Some (rd,cb) => true
                                                               | _ => false
                                                               end)) then
                                                            (_s1188_ _s944_) >>= fun w__73 : option ((mword 5 * mword 5)) =>
                                                            (match w__73 with
                                                             | Some (rd,cb) =>
                                                                returnm (projT1
                                                                (build_ex
                                                                true
                                                                 : {_bool : bool & ArithFact (_bool =
                                                                  true)}))
                                                             | _ => exit tt  : M (bool)
                                                             end)
                                                             : M (bool)
                                                          else
                                                            (_s1200_ _s944_) >>= fun w__76 : option ((mword 5 * mword 5)) =>
                                                            (if ((match w__76 with
                                                                  | Some (cd,cs) => true
                                                                  | _ => false
                                                                  end)) then
                                                               (_s1200_ _s944_) >>= fun w__77 : option ((mword 5 * mword 5)) =>
                                                               (match w__77 with
                                                                | Some (cd,cs) =>
                                                                   returnm (projT1
                                                                   (build_ex
                                                                   true
                                                                    : {_bool : bool & ArithFact (_bool =
                                                                     true)}))
                                                                | _ => exit tt  : M (bool)
                                                                end)
                                                                : M (bool)
                                                             else
                                                               (_s1212_ _s944_) >>= fun w__80 : option ((mword 5 * mword 5)) =>
                                                               (if ((match w__80 with
                                                                     | Some (cd,cs) => true
                                                                     | _ => false
                                                                     end)) then
                                                                  (_s1212_ _s944_) >>= fun w__81 : option ((mword 5 * mword 5)) =>
                                                                  (match w__81 with
                                                                   | Some (cd,cs) =>
                                                                      returnm (projT1
                                                                      (build_ex
                                                                      true
                                                                       : {_bool : bool & ArithFact (_bool =
                                                                        true)}))
                                                                   | _ => exit tt  : M (bool)
                                                                   end)
                                                                   : M (bool)
                                                                else
                                                                  (_s1224_ _s944_) >>= fun w__84 : option (mword 5) =>
                                                                  (if ((match w__84 with
                                                                        | Some (cb) => true
                                                                        | _ => false
                                                                        end)) then
                                                                     (_s1224_ _s944_) >>= fun w__85 : option (mword 5) =>
                                                                     (match w__85 with
                                                                      | Some (cb) =>
                                                                         returnm (projT1
                                                                         (build_ex
                                                                         true
                                                                          : {_bool : bool & ArithFact (_bool =
                                                                           true)}))
                                                                      | _ => exit tt  : M (bool)
                                                                      end)
                                                                      : M (bool)
                                                                   else
                                                                     (_s1232_ _s944_) >>= fun w__88 : option ((mword 5 * mword 5)) =>
                                                                     (if ((match w__88 with
                                                                           | Some (cd,cb) => true
                                                                           | _ => false
                                                                           end)) then
                                                                        (_s1232_ _s944_) >>= fun w__89 : option ((mword 5 * mword 5)) =>
                                                                        (match w__89 with
                                                                         | Some (cd,cb) =>
                                                                            returnm (projT1
                                                                            (build_ex
                                                                            true
                                                                             : {_bool : bool & ArithFact (_bool =
                                                                              true)}))
                                                                         | _ => exit tt  : M (bool)
                                                                         end)
                                                                         : M (bool)
                                                                      else
                                                                        (_s1244_ _s944_) >>= fun w__92 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                        (if ((match w__92 with
                                                                              | Some (cd,cs,ct) =>
                                                                                 true
                                                                              | _ => false
                                                                              end)) then
                                                                           (_s1244_ _s944_) >>= fun w__93 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                           (match w__93 with
                                                                            | Some (cd,cs,ct) =>
                                                                               returnm (projT1
                                                                               (build_ex
                                                                               true
                                                                                : {_bool : bool & ArithFact (_bool =
                                                                                 true)}))
                                                                            | _ =>
                                                                               exit tt  : M (bool)
                                                                            end)
                                                                            : M (bool)
                                                                         else
                                                                           (_s1260_ _s944_) >>= fun w__96 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                           (if ((match w__96 with
                                                                                 | Some (cd,cs,ct) =>
                                                                                    true
                                                                                 | _ => false
                                                                                 end)) then
                                                                              (_s1260_ _s944_) >>= fun w__97 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                              (match w__97 with
                                                                               | Some (cd,cs,ct) =>
                                                                                  returnm (projT1
                                                                                  (build_ex
                                                                                  true
                                                                                   : {_bool : bool & ArithFact (_bool =
                                                                                    true)}))
                                                                               | _ =>
                                                                                  exit tt
                                                                                   : M (bool)
                                                                               end)
                                                                               : M (bool)
                                                                            else
                                                                              (_s1276_ _s944_) >>= fun w__100 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                              (if ((match w__100 with
                                                                                    | Some
                                                                                      (cd,cs,rt) =>
                                                                                       true
                                                                                    | _ => false
                                                                                    end)) then
                                                                                 (_s1276_ _s944_) >>= fun w__101 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                 (match w__101 with
                                                                                  | Some (cd,cs,rt) =>
                                                                                     returnm (projT1
                                                                                     (build_ex
                                                                                     true
                                                                                      : {_bool : bool & ArithFact (_bool =
                                                                                       true)}))
                                                                                  | _ =>
                                                                                     exit tt
                                                                                      : M (bool)
                                                                                  end)
                                                                                  : M (bool)
                                                                               else
                                                                                 (_s1292_ _s944_) >>= fun w__104 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                 (if ((match w__104 with
                                                                                       | Some
                                                                                         (cd,cs,rt) =>
                                                                                          true
                                                                                       | _ => false
                                                                                       end)) then
                                                                                    (_s1292_ _s944_) >>= fun w__105 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                    (match w__105 with
                                                                                     | Some
                                                                                       (cd,cs,rt) =>
                                                                                        returnm (projT1
                                                                                        (build_ex
                                                                                        true
                                                                                         : {_bool : bool & ArithFact (_bool =
                                                                                          true)}))
                                                                                     | _ =>
                                                                                        exit tt
                                                                                         : M (bool)
                                                                                     end)
                                                                                     : M (bool)
                                                                                  else
                                                                                    (_s1308_ _s944_) >>= fun w__108 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                    (if ((match w__108 with
                                                                                          | Some
                                                                                            (cd,cs,rt) =>
                                                                                             true
                                                                                          | _ =>
                                                                                             false
                                                                                          end)) then
                                                                                       (_s1308_
                                                                                          _s944_) >>= fun w__109 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                       (match w__109 with
                                                                                        | Some
                                                                                          (cd,cs,rt) =>
                                                                                           returnm (projT1
                                                                                           (build_ex
                                                                                           true
                                                                                            : {_bool : bool & ArithFact (_bool =
                                                                                             true)}))
                                                                                        | _ =>
                                                                                           exit tt
                                                                                            : M (bool)
                                                                                        end)
                                                                                        : M (bool)
                                                                                     else
                                                                                       (_s1324_
                                                                                          _s944_) >>= fun w__112 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                       (if ((match w__112 with
                                                                                             | Some
                                                                                               (cd,cs,rt) =>
                                                                                                true
                                                                                             | _ =>
                                                                                                false
                                                                                             end))
                                                                                        then
                                                                                          (_s1324_
                                                                                             _s944_) >>= fun w__113 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                          (match w__113 with
                                                                                           | Some
                                                                                             (cd,cs,rt) =>
                                                                                              returnm (projT1
                                                                                              (build_ex
                                                                                              true
                                                                                               : {_bool : bool & ArithFact (_bool =
                                                                                                true)}))
                                                                                           | _ =>
                                                                                              exit tt
                                                                                               : M (bool)
                                                                                           end)
                                                                                           : M (bool)
                                                                                        else
                                                                                          (_s1340_
                                                                                             _s944_) >>= fun w__116 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                          (if ((match w__116 with
                                                                                                | Some
                                                                                                  (cd,cs,rt) =>
                                                                                                   true
                                                                                                | _ =>
                                                                                                   false
                                                                                                end))
                                                                                           then
                                                                                             (_s1340_
                                                                                                _s944_) >>= fun w__117 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                             (match w__117 with
                                                                                              | Some
                                                                                                (cd,cs,rt) =>
                                                                                                 returnm (projT1
                                                                                                 (build_ex
                                                                                                 true
                                                                                                  : {_bool : bool & ArithFact (_bool =
                                                                                                   true)}))
                                                                                              | _ =>
                                                                                                 exit tt
                                                                                                  : M (bool)
                                                                                              end)
                                                                                              : M (bool)
                                                                                           else
                                                                                             (_s1356_
                                                                                                _s944_) >>= fun w__120 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                             (if ((match w__120 with
                                                                                                   | Some
                                                                                                     (rd,cb,cs) =>
                                                                                                      true
                                                                                                   | _ =>
                                                                                                      false
                                                                                                   end))
                                                                                              then
                                                                                                (_s1356_
                                                                                                   _s944_) >>= fun w__121 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                (match w__121 with
                                                                                                 | Some
                                                                                                   (rd,cb,cs) =>
                                                                                                    returnm (projT1
                                                                                                    (build_ex
                                                                                                    true
                                                                                                     : {_bool : bool & ArithFact (_bool =
                                                                                                      true)}))
                                                                                                 | _ =>
                                                                                                    exit tt
                                                                                                     : M (bool)
                                                                                                 end)
                                                                                                 : M (bool)
                                                                                              else
                                                                                                (_s1372_
                                                                                                   _s944_) >>= fun w__124 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                (if ((match w__124 with
                                                                                                      | Some
                                                                                                        (cd,cb,rs) =>
                                                                                                         true
                                                                                                      | _ =>
                                                                                                         false
                                                                                                      end))
                                                                                                 then
                                                                                                   (_s1372_
                                                                                                      _s944_) >>= fun w__125 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                   (match w__125 with
                                                                                                    | Some
                                                                                                      (cd,cb,rs) =>
                                                                                                       returnm (projT1
                                                                                                       (build_ex
                                                                                                       true
                                                                                                        : {_bool : bool & ArithFact (_bool =
                                                                                                         true)}))
                                                                                                    | _ =>
                                                                                                       exit tt
                                                                                                        : M (bool)
                                                                                                    end)
                                                                                                    : M (bool)
                                                                                                 else
                                                                                                   (_s1388_
                                                                                                      _s944_) >>= fun w__128 : option ((mword 5 * mword 5)) =>
                                                                                                   (if
                                                                                                      ((match w__128 with
                                                                                                        | Some
                                                                                                          (cs,cb) =>
                                                                                                           true
                                                                                                        | _ =>
                                                                                                           false
                                                                                                        end))
                                                                                                    then
                                                                                                      (_s1388_
                                                                                                         _s944_) >>= fun w__129 : option ((mword 5 * mword 5)) =>
                                                                                                      (match w__129 with
                                                                                                       | Some
                                                                                                         (cs,cb) =>
                                                                                                          returnm (projT1
                                                                                                          (build_ex
                                                                                                          true
                                                                                                           : {_bool : bool & ArithFact (_bool =
                                                                                                            true)}))
                                                                                                       | _ =>
                                                                                                          exit tt
                                                                                                           : M (bool)
                                                                                                       end)
                                                                                                       : M (bool)
                                                                                                    else
                                                                                                      (_s1400_
                                                                                                         _s944_) >>= fun w__132 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                      (if
                                                                                                         ((match w__132 with
                                                                                                           | Some
                                                                                                             (cd,cb,imm12) =>
                                                                                                              true
                                                                                                           | _ =>
                                                                                                              false
                                                                                                           end))
                                                                                                       then
                                                                                                         (_s1400_
                                                                                                            _s944_) >>= fun w__133 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                         (match w__133 with
                                                                                                          | Some
                                                                                                            (cd,cb,imm12) =>
                                                                                                             returnm (projT1
                                                                                                             (build_ex
                                                                                                             true
                                                                                                              : {_bool : bool & ArithFact (_bool =
                                                                                                               true)}))
                                                                                                          | _ =>
                                                                                                             exit tt
                                                                                                              : M (bool)
                                                                                                          end)
                                                                                                          : M (bool)
                                                                                                       else
                                                                                                         (_s1416_
                                                                                                            _s944_) >>= fun w__136 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                         (if
                                                                                                            ((match w__136 with
                                                                                                              | Some
                                                                                                                (cd,cb,imm12) =>
                                                                                                                 true
                                                                                                              | _ =>
                                                                                                                 false
                                                                                                              end))
                                                                                                          then
                                                                                                            (_s1416_
                                                                                                               _s944_) >>= fun w__137 : option ((mword 5 * mword 5 * mword 12)) =>
                                                                                                            (match w__137 with
                                                                                                             | Some
                                                                                                               (cd,cb,imm12) =>
                                                                                                                returnm (projT1
                                                                                                                (build_ex
                                                                                                                true
                                                                                                                 : {_bool : bool & ArithFact (_bool =
                                                                                                                  true)}))
                                                                                                             | _ =>
                                                                                                                exit tt
                                                                                                                 : M (bool)
                                                                                                             end)
                                                                                                             : M (bool)
                                                                                                          else
                                                                                                            (_s1432_
                                                                                                               _s944_) >>= fun w__140 : option ((word_width * bool * mword 5 * mword 5)) =>
                                                                                                            (if
                                                                                                               ((match w__140 with
                                                                                                                 | Some
                                                                                                                   (w,u,rd,cs) =>
                                                                                                                    true
                                                                                                                 | _ =>
                                                                                                                    false
                                                                                                                 end))
                                                                                                             then
                                                                                                               (_s1432_
                                                                                                                  _s944_) >>= fun w__141 : option ((word_width * bool * mword 5 * mword 5)) =>
                                                                                                               (match w__141 with
                                                                                                                | Some
                                                                                                                  (w,u,rd,cs) =>
                                                                                                                   returnm (projT1
                                                                                                                   (build_ex
                                                                                                                   true
                                                                                                                    : {_bool : bool & ArithFact (_bool =
                                                                                                                     true)}))
                                                                                                                | _ =>
                                                                                                                   exit tt
                                                                                                                    : M (bool)
                                                                                                                end)
                                                                                                                : M (bool)
                                                                                                             else
                                                                                                               (_s1449_
                                                                                                                  _s944_) >>= fun w__144 : option ((word_width * mword 5 * mword 5)) =>
                                                                                                               (if
                                                                                                                  ((match w__144 with
                                                                                                                    | Some
                                                                                                                      (w,rd,rs) =>
                                                                                                                       true
                                                                                                                    | _ =>
                                                                                                                       false
                                                                                                                    end))
                                                                                                                then
                                                                                                                  (_s1449_
                                                                                                                     _s944_) >>= fun w__145 : option ((word_width * mword 5 * mword 5)) =>
                                                                                                                  (match w__145 with
                                                                                                                   | Some
                                                                                                                     (w,rd,rs) =>
                                                                                                                      returnm (projT1
                                                                                                                      (build_ex
                                                                                                                      true
                                                                                                                       : {_bool : bool & ArithFact (_bool =
                                                                                                                        true)}))
                                                                                                                   | _ =>
                                                                                                                      exit tt
                                                                                                                       : M (bool)
                                                                                                                   end)
                                                                                                                   : M (bool)
                                                                                                                else
                                                                                                                  (_s1464_
                                                                                                                     _s944_) >>= fun w__148 : option ((mword 5 * mword 5)) =>
                                                                                                                  (if
                                                                                                                     ((match w__148 with
                                                                                                                       | Some
                                                                                                                         (rd,rs) =>
                                                                                                                          true
                                                                                                                       | _ =>
                                                                                                                          false
                                                                                                                       end))
                                                                                                                   then
                                                                                                                     (_s1464_
                                                                                                                        _s944_) >>= fun w__149 : option ((mword 5 * mword 5)) =>
                                                                                                                     (match w__149 with
                                                                                                                      | Some
                                                                                                                        (rd,rs) =>
                                                                                                                         returnm (projT1
                                                                                                                         (build_ex
                                                                                                                         true
                                                                                                                          : {_bool : bool & ArithFact (_bool =
                                                                                                                           true)}))
                                                                                                                      | _ =>
                                                                                                                         exit tt
                                                                                                                          : M (bool)
                                                                                                                      end)
                                                                                                                      : M (bool)
                                                                                                                   else
                                                                                                                     (_s1476_
                                                                                                                        _s944_) >>= fun w__152 : option ((mword 5 * mword 5)) =>
                                                                                                                     (if
                                                                                                                        ((match w__152 with
                                                                                                                          | Some
                                                                                                                            (rd,rs) =>
                                                                                                                             true
                                                                                                                          | _ =>
                                                                                                                             false
                                                                                                                          end))
                                                                                                                      then
                                                                                                                        (_s1476_
                                                                                                                           _s944_) >>= fun w__153 : option ((mword 5 * mword 5)) =>
                                                                                                                        (match w__153 with
                                                                                                                         | Some
                                                                                                                           (rd,rs) =>
                                                                                                                            returnm (projT1
                                                                                                                            (build_ex
                                                                                                                            true
                                                                                                                             : {_bool : bool & ArithFact (_bool =
                                                                                                                              true)}))
                                                                                                                         | _ =>
                                                                                                                            exit tt
                                                                                                                             : M (bool)
                                                                                                                         end)
                                                                                                                         : M (bool)
                                                                                                                      else
                                                                                                                        (_s1488_
                                                                                                                           _s944_) >>= fun w__156 : option (mword 32) =>
                                                                                                                        (if
                                                                                                                           ((match w__156 with
                                                                                                                             | Some
                                                                                                                               (s) =>
                                                                                                                                true
                                                                                                                             | _ =>
                                                                                                                                false
                                                                                                                             end))
                                                                                                                         then
                                                                                                                           (_s1488_
                                                                                                                              _s944_) >>= fun w__157 : option (mword 32) =>
                                                                                                                           (match w__157 with
                                                                                                                            | Some
                                                                                                                              (s) =>
                                                                                                                               returnm (projT1
                                                                                                                               (build_ex
                                                                                                                               true
                                                                                                                                : {_bool : bool & ArithFact (_bool =
                                                                                                                                 true)}))
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (bool)
                                                                                                                            end)
                                                                                                                            : M (bool)
                                                                                                                         else
                                                                                                                           (_s1496_
                                                                                                                              _s944_) >>= fun w__160 : option (mword 16) =>
                                                                                                                           (if
                                                                                                                              ((match w__160 with
                                                                                                                                | Some
                                                                                                                                  (s) =>
                                                                                                                                   true
                                                                                                                                | _ =>
                                                                                                                                   false
                                                                                                                                end))
                                                                                                                            then
                                                                                                                              (_s1496_
                                                                                                                                 _s944_) >>= fun w__161 : option (mword 16) =>
                                                                                                                              (match w__161 with
                                                                                                                               | Some
                                                                                                                                 (s) =>
                                                                                                                                  returnm (projT1
                                                                                                                                  (build_ex
                                                                                                                                  true
                                                                                                                                   : {_bool : bool & ArithFact (_bool =
                                                                                                                                    true)}))
                                                                                                                               | _ =>
                                                                                                                                  exit tt
                                                                                                                                   : M (bool)
                                                                                                                               end)
                                                                                                                               : M (bool)
                                                                                                                            else
                                                                                                                              returnm (projT1
                                                                                                                              (build_ex
                                                                                                                              false
                                                                                                                               : {_bool : bool & ArithFact (not (_bool =
                                                                                                                                true))})))
                                                                                                                            : M (bool))
                                                                                                                         : M (bool))
                                                                                                                      : M (bool))
                                                                                                                   : M (bool))
                                                                                                                : M (bool))
                                                                                                             : M (bool))
                                                                                                          : M (bool))
                                                                                                       : M (bool))
                                                                                                    : M (bool))
                                                                                                 : M (bool))
                                                                                              : M (bool))
                                                                                           : M (bool))
                                                                                        : M (bool))
                                                                                     : M (bool))
                                                                                  : M (bool))
                                                                               : M (bool))
                                                                            : M (bool))
                                                                         : M (bool))
                                                                      : M (bool))
                                                                   : M (bool))
                                                                : M (bool))
                                                             : M (bool))
                                                          : M (bool))
                                                       : M (bool))
                                                    : M (bool))
                                                 : M (bool))
                                              : M (bool))
                                           : M (bool))
                                        : M (bool))
                                     : M (bool))
                                  : M (bool))
                               : M (bool))
                            : M (bool))
                         : M (bool))
                      : M (bool))
                   : M (bool))
                : M (bool))
             : M (bool))
          : M (bool))
       : M (bool))
    : M (bool).

Definition _s2068_ (_s2069_ : string) 
: M (option ((mword 16 * string))) :=
   
   let _s2070_ := _s2069_ in
   (if ((string_startswith _s2070_ "c.illegal")) then
      (match (string_drop _s2070_ (projT1 (string_length "c.illegal"))) with
       | _s2071_ =>
          (spc_matches_prefix _s2071_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some (tt,(existT _ _s2072_ _)) =>
                       match (string_drop _s2071_ _s2072_) with
                       | _s2073_ =>
                          match (hex_bits_16_matches_prefix _s2073_) with
                          | Some (s,(existT _ _s2074_ _)) =>
                             match (string_drop _s2073_ _s2074_) with | s_ => Some ((s, s_)) end
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 16 * string)))
       end)
       : M (option ((mword 16 * string)))
    else returnm (None  : option ((mword 16 * string))))
    : M (option ((mword 16 * string))).

Definition _s2060_ (_s2061_ : string) 
: M (option ((mword 32 * string))) :=
   
   let _s2062_ := _s2061_ in
   (if ((string_startswith _s2062_ "illegal")) then
      (match (string_drop _s2062_ (projT1 (string_length "illegal"))) with
       | _s2063_ =>
          (spc_matches_prefix _s2063_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some (tt,(existT _ _s2064_ _)) =>
                       match (string_drop _s2063_ _s2064_) with
                       | _s2065_ =>
                          match (hex_bits_32_matches_prefix _s2065_) with
                          | Some (s,(existT _ _s2066_ _)) =>
                             match (string_drop _s2065_ _s2066_) with | s_ => Some ((s, s_)) end
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 32 * string)))
       end)
       : M (option ((mword 32 * string)))
    else returnm (None  : option ((mword 32 * string))))
    : M (option ((mword 32 * string))).

Definition _s2048_ (_s2049_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s2050_ := _s2049_ in
   (if ((string_startswith _s2050_ "sqCap")) then
      (match (string_drop _s2050_ (projT1 (string_length "sqCap"))) with
       | _s2051_ =>
          (spc_matches_prefix _s2051_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s2052_ _)) =>
              (match (string_drop _s2051_ _s2052_) with
               | _s2053_ =>
                  (reg_name_matches_prefix _s2053_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s2054_ _)) =>
                      (match (string_drop _s2053_ _s2054_) with
                       | _s2055_ =>
                          (sep_matches_prefix _s2055_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s2056_ _)) =>
                              (match (string_drop _s2055_ _s2056_) with
                               | _s2057_ =>
                                  (reg_name_matches_prefix _s2057_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (rs,(existT _ _s2058_ _)) =>
                                               match (string_drop _s2057_ _s2058_) with
                                               | s_ => Some ((rd, rs, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s2036_ (_s2037_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s2038_ := _s2037_ in
   (if ((string_startswith _s2038_ "lqCap")) then
      (match (string_drop _s2038_ (projT1 (string_length "lqCap"))) with
       | _s2039_ =>
          (spc_matches_prefix _s2039_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s2040_ _)) =>
              (match (string_drop _s2039_ _s2040_) with
               | _s2041_ =>
                  (reg_name_matches_prefix _s2041_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s2042_ _)) =>
                      (match (string_drop _s2041_ _s2042_) with
                       | _s2043_ =>
                          (sep_matches_prefix _s2043_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s2044_ _)) =>
                              (match (string_drop _s2043_ _s2044_) with
                               | _s2045_ =>
                                  (reg_name_matches_prefix _s2045_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (rs,(existT _ _s2046_ _)) =>
                                               match (string_drop _s2045_ _s2046_) with
                                               | s_ => Some ((rd, rs, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s2021_ (_s2022_ : string) 
: M (option ((word_width * mword 5 * mword 5 * string))) :=
   
   let _s2023_ := _s2022_ in
   (if ((string_startswith _s2023_ "s")) then
      (match (string_drop _s2023_ (projT1 (string_length "s"))) with
       | _s2024_ =>
          (size_mnemonic_matches_prefix _s2024_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some (w,(existT _ _s2025_ _)) =>
              let _s2026_ := string_drop _s2024_ _s2025_ in
              (if ((string_startswith _s2026_ "Cap")) then
                 (match (string_drop _s2026_ (projT1 (string_length "Cap"))) with
                  | _s2027_ =>
                     (spc_matches_prefix _s2027_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some (tt,(existT _ _s2028_ _)) =>
                         (match (string_drop _s2027_ _s2028_) with
                          | _s2029_ =>
                             (reg_name_matches_prefix _s2029_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some (rd,(existT _ _s2030_ _)) =>
                                 (match (string_drop _s2029_ _s2030_) with
                                  | _s2031_ =>
                                     (sep_matches_prefix _s2031_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some (tt,(existT _ _s2032_ _)) =>
                                         (match (string_drop _s2031_ _s2032_) with
                                          | _s2033_ =>
                                             (reg_name_matches_prefix _s2033_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             returnm ((match w__4 with
                                                       | Some (rs,(existT _ _s2034_ _)) =>
                                                          match (string_drop _s2033_ _s2034_) with
                                                          | s_ => Some ((w, rd, rs, s_))
                                                          end
                                                       | _ => None
                                                       end)
                                              : option ((word_width * mword 5 * mword 5 * string)))
                                          end)
                                          : M (option ((word_width * mword 5 * mword 5 * string)))
                                      | _ =>
                                         returnm (None
                                          : option ((word_width * mword 5 * mword 5 * string)))
                                      end)
                                      : M (option ((word_width * mword 5 * mword 5 * string)))
                                  end)
                                  : M (option ((word_width * mword 5 * mword 5 * string)))
                              | _ =>
                                 returnm (None
                                  : option ((word_width * mword 5 * mword 5 * string)))
                              end)
                              : M (option ((word_width * mword 5 * mword 5 * string)))
                          end)
                          : M (option ((word_width * mword 5 * mword 5 * string)))
                      | _ => returnm (None  : option ((word_width * mword 5 * mword 5 * string)))
                      end)
                      : M (option ((word_width * mword 5 * mword 5 * string)))
                  end)
                  : M (option ((word_width * mword 5 * mword 5 * string)))
               else returnm (None  : option ((word_width * mword 5 * mword 5 * string))))
               : M (option ((word_width * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((word_width * mword 5 * mword 5 * string)))
           end)
           : M (option ((word_width * mword 5 * mword 5 * string)))
       end)
       : M (option ((word_width * mword 5 * mword 5 * string)))
    else returnm (None  : option ((word_width * mword 5 * mword 5 * string))))
    : M (option ((word_width * mword 5 * mword 5 * string))).

Definition _s2004_ (_s2005_ : string) 
: M (option ((word_width * bool * mword 5 * mword 5 * string))) :=
   
   let _s2006_ := _s2005_ in
   (if ((string_startswith _s2006_ "l")) then
      (match (string_drop _s2006_ (projT1 (string_length "l"))) with
       | _s2007_ =>
          (size_mnemonic_matches_prefix _s2007_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some (w,(existT _ _s2008_ _)) =>
              (match (string_drop _s2007_ _s2008_) with
               | _s2009_ =>
                  (maybe_u_matches_prefix _s2009_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (u,(existT _ _s2010_ _)) =>
                      let _s2011_ := string_drop _s2009_ _s2010_ in
                      (if ((string_startswith _s2011_ "Cap")) then
                         (match (string_drop _s2011_ (projT1 (string_length "Cap"))) with
                          | _s2012_ =>
                             (spc_matches_prefix _s2012_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some (tt,(existT _ _s2013_ _)) =>
                                 (match (string_drop _s2012_ _s2013_) with
                                  | _s2014_ =>
                                     (reg_name_matches_prefix _s2014_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some (rd,(existT _ _s2015_ _)) =>
                                         (match (string_drop _s2014_ _s2015_) with
                                          | _s2016_ =>
                                             (sep_matches_prefix _s2016_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some (tt,(existT _ _s2017_ _)) =>
                                                 (match (string_drop _s2016_ _s2017_) with
                                                  | _s2018_ =>
                                                     (reg_name_matches_prefix _s2018_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     returnm ((match w__5 with
                                                               | Some (cs,(existT _ _s2019_ _)) =>
                                                                  match (string_drop _s2018_ _s2019_) with
                                                                  | s_ => Some ((w, u, rd, cs, s_))
                                                                  end
                                                               | _ => None
                                                               end)
                                                      : option ((word_width * bool * mword 5 * mword 5 * string)))
                                                  end)
                                                  : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((word_width * bool * mword 5 * mword 5 * string)))
                                              end)
                                              : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                                          end)
                                          : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                                      | _ =>
                                         returnm (None
                                          : option ((word_width * bool * mword 5 * mword 5 * string)))
                                      end)
                                      : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                                  end)
                                  : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                              | _ =>
                                 returnm (None
                                  : option ((word_width * bool * mword 5 * mword 5 * string)))
                              end)
                              : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                          end)
                          : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                       else
                         returnm (None
                          : option ((word_width * bool * mword 5 * mword 5 * string))))
                       : M (option ((word_width * bool * mword 5 * mword 5 * string)))
                   | _ =>
                      returnm (None  : option ((word_width * bool * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((word_width * bool * mword 5 * mword 5 * string)))
               end)
               : M (option ((word_width * bool * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((word_width * bool * mword 5 * mword 5 * string)))
           end)
           : M (option ((word_width * bool * mword 5 * mword 5 * string)))
       end)
       : M (option ((word_width * bool * mword 5 * mword 5 * string)))
    else returnm (None  : option ((word_width * bool * mword 5 * mword 5 * string))))
    : M (option ((word_width * bool * mword 5 * mword 5 * string))).

Definition _s1988_ (_s1989_ : string) 
: M (option ((mword 5 * mword 5 * mword 12 * string))) :=
   
   let _s1990_ := _s1989_ in
   (if ((string_startswith _s1990_ "CSetBoundsImmediate")) then
      (match (string_drop _s1990_ (projT1 (string_length "CSetBoundsImmediate"))) with
       | _s1991_ =>
          (spc_matches_prefix _s1991_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1992_ _)) =>
              (match (string_drop _s1991_ _s1992_) with
               | _s1993_ =>
                  (reg_name_matches_prefix _s1993_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1994_ _)) =>
                      (match (string_drop _s1993_ _s1994_) with
                       | _s1995_ =>
                          (sep_matches_prefix _s1995_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1996_ _)) =>
                              (match (string_drop _s1995_ _s1996_) with
                               | _s1997_ =>
                                  (reg_name_matches_prefix _s1997_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1998_ _)) =>
                                      (match (string_drop _s1997_ _s1998_) with
                                       | _s1999_ =>
                                          (sep_matches_prefix _s1999_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s2000_ _)) =>
                                                       match (string_drop _s1999_ _s2000_) with
                                                       | _s2001_ =>
                                                          match (hex_bits_12_matches_prefix _s2001_) with
                                                          | Some (imm12,(existT _ _s2002_ _)) =>
                                                             match (string_drop _s2001_ _s2002_) with
                                                             | s_ => Some ((cd, cb, imm12, s_))
                                                             end
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12 * string))))
    : M (option ((mword 5 * mword 5 * mword 12 * string))).

Definition _s1972_ (_s1973_ : string) 
: M (option ((mword 5 * mword 5 * mword 12 * string))) :=
   
   let _s1974_ := _s1973_ in
   (if ((string_startswith _s1974_ "CIncOffsetImmediate")) then
      (match (string_drop _s1974_ (projT1 (string_length "CIncOffsetImmediate"))) with
       | _s1975_ =>
          (spc_matches_prefix _s1975_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1976_ _)) =>
              (match (string_drop _s1975_ _s1976_) with
               | _s1977_ =>
                  (reg_name_matches_prefix _s1977_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1978_ _)) =>
                      (match (string_drop _s1977_ _s1978_) with
                       | _s1979_ =>
                          (sep_matches_prefix _s1979_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1980_ _)) =>
                              (match (string_drop _s1979_ _s1980_) with
                               | _s1981_ =>
                                  (reg_name_matches_prefix _s1981_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1982_ _)) =>
                                      (match (string_drop _s1981_ _s1982_) with
                                       | _s1983_ =>
                                          (sep_matches_prefix _s1983_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s1984_ _)) =>
                                                       match (string_drop _s1983_ _s1984_) with
                                                       | _s1985_ =>
                                                          match (hex_bits_12_matches_prefix _s1985_) with
                                                          | Some (imm12,(existT _ _s1986_ _)) =>
                                                             match (string_drop _s1985_ _s1986_) with
                                                             | s_ => Some ((cd, cb, imm12, s_))
                                                             end
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12 * string))))
    : M (option ((mword 5 * mword 5 * mword 12 * string))).

Definition _s1960_ (_s1961_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1962_ := _s1961_ in
   (if ((string_startswith _s1962_ "CCallFast")) then
      (match (string_drop _s1962_ (projT1 (string_length "CCallFast"))) with
       | _s1963_ =>
          (spc_matches_prefix _s1963_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1964_ _)) =>
              (match (string_drop _s1963_ _s1964_) with
               | _s1965_ =>
                  (reg_name_matches_prefix _s1965_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cs,(existT _ _s1966_ _)) =>
                      (match (string_drop _s1965_ _s1966_) with
                       | _s1967_ =>
                          (sep_matches_prefix _s1967_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1968_ _)) =>
                              (match (string_drop _s1967_ _s1968_) with
                               | _s1969_ =>
                                  (reg_name_matches_prefix _s1969_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1970_ _)) =>
                                               match (string_drop _s1969_ _s1970_) with
                                               | s_ => Some ((cs, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1944_ (_s1945_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1946_ := _s1945_ in
   (if ((string_startswith _s1946_ "CFromPtr")) then
      (match (string_drop _s1946_ (projT1 (string_length "CFromPtr"))) with
       | _s1947_ =>
          (spc_matches_prefix _s1947_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1948_ _)) =>
              (match (string_drop _s1947_ _s1948_) with
               | _s1949_ =>
                  (reg_name_matches_prefix _s1949_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1950_ _)) =>
                      (match (string_drop _s1949_ _s1950_) with
                       | _s1951_ =>
                          (sep_matches_prefix _s1951_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1952_ _)) =>
                              (match (string_drop _s1951_ _s1952_) with
                               | _s1953_ =>
                                  (reg_name_matches_prefix _s1953_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1954_ _)) =>
                                      (match (string_drop _s1953_ _s1954_) with
                                       | _s1955_ =>
                                          (sep_matches_prefix _s1955_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1956_ _)) =>
                                              (match (string_drop _s1955_ _s1956_) with
                                               | _s1957_ =>
                                                  (reg_name_matches_prefix _s1957_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rs,(existT _ _s1958_ _)) =>
                                                               match (string_drop _s1957_ _s1958_) with
                                                               | s_ => Some ((cd, cb, rs, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1928_ (_s1929_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1930_ := _s1929_ in
   (if ((string_startswith _s1930_ "CToPtr")) then
      (match (string_drop _s1930_ (projT1 (string_length "CToPtr"))) with
       | _s1931_ =>
          (spc_matches_prefix _s1931_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1932_ _)) =>
              (match (string_drop _s1931_ _s1932_) with
               | _s1933_ =>
                  (reg_name_matches_prefix _s1933_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1934_ _)) =>
                      (match (string_drop _s1933_ _s1934_) with
                       | _s1935_ =>
                          (sep_matches_prefix _s1935_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1936_ _)) =>
                              (match (string_drop _s1935_ _s1936_) with
                               | _s1937_ =>
                                  (reg_name_matches_prefix _s1937_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cb,(existT _ _s1938_ _)) =>
                                      (match (string_drop _s1937_ _s1938_) with
                                       | _s1939_ =>
                                          (sep_matches_prefix _s1939_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1940_ _)) =>
                                              (match (string_drop _s1939_ _s1940_) with
                                               | _s1941_ =>
                                                  (reg_name_matches_prefix _s1941_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (cs,(existT _ _s1942_ _)) =>
                                                               match (string_drop _s1941_ _s1942_) with
                                                               | s_ => Some ((rd, cb, cs, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1912_ (_s1913_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1914_ := _s1913_ in
   (if ((string_startswith _s1914_ "CSetBoundsExact")) then
      (match (string_drop _s1914_ (projT1 (string_length "CSetBoundsExact"))) with
       | _s1915_ =>
          (spc_matches_prefix _s1915_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1916_ _)) =>
              (match (string_drop _s1915_ _s1916_) with
               | _s1917_ =>
                  (reg_name_matches_prefix _s1917_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1918_ _)) =>
                      (match (string_drop _s1917_ _s1918_) with
                       | _s1919_ =>
                          (sep_matches_prefix _s1919_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1920_ _)) =>
                              (match (string_drop _s1919_ _s1920_) with
                               | _s1921_ =>
                                  (reg_name_matches_prefix _s1921_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1922_ _)) =>
                                      (match (string_drop _s1921_ _s1922_) with
                                       | _s1923_ =>
                                          (sep_matches_prefix _s1923_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1924_ _)) =>
                                              (match (string_drop _s1923_ _s1924_) with
                                               | _s1925_ =>
                                                  (reg_name_matches_prefix _s1925_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1926_ _)) =>
                                                               match (string_drop _s1925_ _s1926_) with
                                                               | s_ => Some ((cd, cs, rt, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1896_ (_s1897_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1898_ := _s1897_ in
   (if ((string_startswith _s1898_ "CSetBounds")) then
      (match (string_drop _s1898_ (projT1 (string_length "CSetBounds"))) with
       | _s1899_ =>
          (spc_matches_prefix _s1899_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1900_ _)) =>
              (match (string_drop _s1899_ _s1900_) with
               | _s1901_ =>
                  (reg_name_matches_prefix _s1901_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1902_ _)) =>
                      (match (string_drop _s1901_ _s1902_) with
                       | _s1903_ =>
                          (sep_matches_prefix _s1903_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1904_ _)) =>
                              (match (string_drop _s1903_ _s1904_) with
                               | _s1905_ =>
                                  (reg_name_matches_prefix _s1905_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1906_ _)) =>
                                      (match (string_drop _s1905_ _s1906_) with
                                       | _s1907_ =>
                                          (sep_matches_prefix _s1907_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1908_ _)) =>
                                              (match (string_drop _s1907_ _s1908_) with
                                               | _s1909_ =>
                                                  (reg_name_matches_prefix _s1909_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1910_ _)) =>
                                                               match (string_drop _s1909_ _s1910_) with
                                                               | s_ => Some ((cd, cs, rt, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1880_ (_s1881_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1882_ := _s1881_ in
   (if ((string_startswith _s1882_ "CIncOffset")) then
      (match (string_drop _s1882_ (projT1 (string_length "CIncOffset"))) with
       | _s1883_ =>
          (spc_matches_prefix _s1883_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1884_ _)) =>
              (match (string_drop _s1883_ _s1884_) with
               | _s1885_ =>
                  (reg_name_matches_prefix _s1885_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1886_ _)) =>
                      (match (string_drop _s1885_ _s1886_) with
                       | _s1887_ =>
                          (sep_matches_prefix _s1887_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1888_ _)) =>
                              (match (string_drop _s1887_ _s1888_) with
                               | _s1889_ =>
                                  (reg_name_matches_prefix _s1889_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1890_ _)) =>
                                      (match (string_drop _s1889_ _s1890_) with
                                       | _s1891_ =>
                                          (sep_matches_prefix _s1891_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1892_ _)) =>
                                              (match (string_drop _s1891_ _s1892_) with
                                               | _s1893_ =>
                                                  (reg_name_matches_prefix _s1893_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1894_ _)) =>
                                                               match (string_drop _s1893_ _s1894_) with
                                                               | s_ => Some ((cd, cs, rt, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1864_ (_s1865_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1866_ := _s1865_ in
   (if ((string_startswith _s1866_ "CSetOffset")) then
      (match (string_drop _s1866_ (projT1 (string_length "CSetOffset"))) with
       | _s1867_ =>
          (spc_matches_prefix _s1867_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1868_ _)) =>
              (match (string_drop _s1867_ _s1868_) with
               | _s1869_ =>
                  (reg_name_matches_prefix _s1869_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1870_ _)) =>
                      (match (string_drop _s1869_ _s1870_) with
                       | _s1871_ =>
                          (sep_matches_prefix _s1871_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1872_ _)) =>
                              (match (string_drop _s1871_ _s1872_) with
                               | _s1873_ =>
                                  (reg_name_matches_prefix _s1873_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1874_ _)) =>
                                      (match (string_drop _s1873_ _s1874_) with
                                       | _s1875_ =>
                                          (sep_matches_prefix _s1875_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1876_ _)) =>
                                              (match (string_drop _s1875_ _s1876_) with
                                               | _s1877_ =>
                                                  (reg_name_matches_prefix _s1877_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1878_ _)) =>
                                                               match (string_drop _s1877_ _s1878_) with
                                                               | s_ => Some ((cd, cs, rt, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1848_ (_s1849_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1850_ := _s1849_ in
   (if ((string_startswith _s1850_ "CAndPerm")) then
      (match (string_drop _s1850_ (projT1 (string_length "CAndPerm"))) with
       | _s1851_ =>
          (spc_matches_prefix _s1851_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1852_ _)) =>
              (match (string_drop _s1851_ _s1852_) with
               | _s1853_ =>
                  (reg_name_matches_prefix _s1853_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1854_ _)) =>
                      (match (string_drop _s1853_ _s1854_) with
                       | _s1855_ =>
                          (sep_matches_prefix _s1855_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1856_ _)) =>
                              (match (string_drop _s1855_ _s1856_) with
                               | _s1857_ =>
                                  (reg_name_matches_prefix _s1857_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1858_ _)) =>
                                      (match (string_drop _s1857_ _s1858_) with
                                       | _s1859_ =>
                                          (sep_matches_prefix _s1859_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1860_ _)) =>
                                              (match (string_drop _s1859_ _s1860_) with
                                               | _s1861_ =>
                                                  (reg_name_matches_prefix _s1861_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (rt,(existT _ _s1862_ _)) =>
                                                               match (string_drop _s1861_ _s1862_) with
                                                               | s_ => Some ((cd, cs, rt, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1832_ (_s1833_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1834_ := _s1833_ in
   (if ((string_startswith _s1834_ "CUnseal")) then
      (match (string_drop _s1834_ (projT1 (string_length "CUnseal"))) with
       | _s1835_ =>
          (spc_matches_prefix _s1835_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1836_ _)) =>
              (match (string_drop _s1835_ _s1836_) with
               | _s1837_ =>
                  (reg_name_matches_prefix _s1837_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1838_ _)) =>
                      (match (string_drop _s1837_ _s1838_) with
                       | _s1839_ =>
                          (sep_matches_prefix _s1839_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1840_ _)) =>
                              (match (string_drop _s1839_ _s1840_) with
                               | _s1841_ =>
                                  (reg_name_matches_prefix _s1841_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1842_ _)) =>
                                      (match (string_drop _s1841_ _s1842_) with
                                       | _s1843_ =>
                                          (sep_matches_prefix _s1843_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1844_ _)) =>
                                              (match (string_drop _s1843_ _s1844_) with
                                               | _s1845_ =>
                                                  (reg_name_matches_prefix _s1845_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (ct,(existT _ _s1846_ _)) =>
                                                               match (string_drop _s1845_ _s1846_) with
                                                               | s_ => Some ((cd, cs, ct, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1816_ (_s1817_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s1818_ := _s1817_ in
   (if ((string_startswith _s1818_ "CSeal")) then
      (match (string_drop _s1818_ (projT1 (string_length "CSeal"))) with
       | _s1819_ =>
          (spc_matches_prefix _s1819_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1820_ _)) =>
              (match (string_drop _s1819_ _s1820_) with
               | _s1821_ =>
                  (reg_name_matches_prefix _s1821_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1822_ _)) =>
                      (match (string_drop _s1821_ _s1822_) with
                       | _s1823_ =>
                          (sep_matches_prefix _s1823_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1824_ _)) =>
                              (match (string_drop _s1823_ _s1824_) with
                               | _s1825_ =>
                                  (reg_name_matches_prefix _s1825_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (cs,(existT _ _s1826_ _)) =>
                                      (match (string_drop _s1825_ _s1826_) with
                                       | _s1827_ =>
                                          (sep_matches_prefix _s1827_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some (tt,(existT _ _s1828_ _)) =>
                                              (match (string_drop _s1827_ _s1828_) with
                                               | _s1829_ =>
                                                  (reg_name_matches_prefix _s1829_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some (ct,(existT _ _s1830_ _)) =>
                                                               match (string_drop _s1829_ _s1830_) with
                                                               | s_ => Some ((cd, cs, ct, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s1804_ (_s1805_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1806_ := _s1805_ in
   (if ((string_startswith _s1806_ "CJALR")) then
      (match (string_drop _s1806_ (projT1 (string_length "CJALR"))) with
       | _s1807_ =>
          (spc_matches_prefix _s1807_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1808_ _)) =>
              (match (string_drop _s1807_ _s1808_) with
               | _s1809_ =>
                  (reg_name_matches_prefix _s1809_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1810_ _)) =>
                      (match (string_drop _s1809_ _s1810_) with
                       | _s1811_ =>
                          (sep_matches_prefix _s1811_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1812_ _)) =>
                              (match (string_drop _s1811_ _s1812_) with
                               | _s1813_ =>
                                  (reg_name_matches_prefix _s1813_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1814_ _)) =>
                                               match (string_drop _s1813_ _s1814_) with
                                               | s_ => Some ((cd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1796_ (_s1797_ : string) 
: M (option ((mword 5 * string))) :=
   
   let _s1798_ := _s1797_ in
   (if ((string_startswith _s1798_ "CJR")) then
      (match (string_drop _s1798_ (projT1 (string_length "CJR"))) with
       | _s1799_ =>
          (spc_matches_prefix _s1799_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1800_ _)) =>
              (match (string_drop _s1799_ _s1800_) with
               | _s1801_ =>
                  (reg_name_matches_prefix _s1801_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some (cb,(existT _ _s1802_ _)) =>
                               match (string_drop _s1801_ _s1802_) with | s_ => Some ((cb, s_)) end
                            | _ => None
                            end)
                   : option ((mword 5 * string)))
               end)
               : M (option ((mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * string)))
           end)
           : M (option ((mword 5 * string)))
       end)
       : M (option ((mword 5 * string)))
    else returnm (None  : option ((mword 5 * string))))
    : M (option ((mword 5 * string))).

Definition _s1784_ (_s1785_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1786_ := _s1785_ in
   (if ((string_startswith _s1786_ "CClearTag")) then
      (match (string_drop _s1786_ (projT1 (string_length "CClearTag"))) with
       | _s1787_ =>
          (spc_matches_prefix _s1787_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1788_ _)) =>
              (match (string_drop _s1787_ _s1788_) with
               | _s1789_ =>
                  (reg_name_matches_prefix _s1789_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1790_ _)) =>
                      (match (string_drop _s1789_ _s1790_) with
                       | _s1791_ =>
                          (sep_matches_prefix _s1791_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1792_ _)) =>
                              (match (string_drop _s1791_ _s1792_) with
                               | _s1793_ =>
                                  (reg_name_matches_prefix _s1793_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cs,(existT _ _s1794_ _)) =>
                                               match (string_drop _s1793_ _s1794_) with
                                               | s_ => Some ((cd, cs, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1772_ (_s1773_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1774_ := _s1773_ in
   (if ((string_startswith _s1774_ "CMove")) then
      (match (string_drop _s1774_ (projT1 (string_length "CMove"))) with
       | _s1775_ =>
          (spc_matches_prefix _s1775_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1776_ _)) =>
              (match (string_drop _s1775_ _s1776_) with
               | _s1777_ =>
                  (reg_name_matches_prefix _s1777_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (cd,(existT _ _s1778_ _)) =>
                      (match (string_drop _s1777_ _s1778_) with
                       | _s1779_ =>
                          (sep_matches_prefix _s1779_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1780_ _)) =>
                              (match (string_drop _s1779_ _s1780_) with
                               | _s1781_ =>
                                  (reg_name_matches_prefix _s1781_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cs,(existT _ _s1782_ _)) =>
                                               match (string_drop _s1781_ _s1782_) with
                                               | s_ => Some ((cd, cs, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1760_ (_s1761_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1762_ := _s1761_ in
   (if ((string_startswith _s1762_ "CGetAddr")) then
      (match (string_drop _s1762_ (projT1 (string_length "CGetAddr"))) with
       | _s1763_ =>
          (spc_matches_prefix _s1763_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1764_ _)) =>
              (match (string_drop _s1763_ _s1764_) with
               | _s1765_ =>
                  (reg_name_matches_prefix _s1765_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1766_ _)) =>
                      (match (string_drop _s1765_ _s1766_) with
                       | _s1767_ =>
                          (sep_matches_prefix _s1767_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1768_ _)) =>
                              (match (string_drop _s1767_ _s1768_) with
                               | _s1769_ =>
                                  (reg_name_matches_prefix _s1769_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1770_ _)) =>
                                               match (string_drop _s1769_ _s1770_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1748_ (_s1749_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1750_ := _s1749_ in
   (if ((string_startswith _s1750_ "CGetOffset")) then
      (match (string_drop _s1750_ (projT1 (string_length "CGetOffset"))) with
       | _s1751_ =>
          (spc_matches_prefix _s1751_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1752_ _)) =>
              (match (string_drop _s1751_ _s1752_) with
               | _s1753_ =>
                  (reg_name_matches_prefix _s1753_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1754_ _)) =>
                      (match (string_drop _s1753_ _s1754_) with
                       | _s1755_ =>
                          (sep_matches_prefix _s1755_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1756_ _)) =>
                              (match (string_drop _s1755_ _s1756_) with
                               | _s1757_ =>
                                  (reg_name_matches_prefix _s1757_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1758_ _)) =>
                                               match (string_drop _s1757_ _s1758_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1736_ (_s1737_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1738_ := _s1737_ in
   (if ((string_startswith _s1738_ "CGetSealed")) then
      (match (string_drop _s1738_ (projT1 (string_length "CGetSealed"))) with
       | _s1739_ =>
          (spc_matches_prefix _s1739_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1740_ _)) =>
              (match (string_drop _s1739_ _s1740_) with
               | _s1741_ =>
                  (reg_name_matches_prefix _s1741_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1742_ _)) =>
                      (match (string_drop _s1741_ _s1742_) with
                       | _s1743_ =>
                          (sep_matches_prefix _s1743_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1744_ _)) =>
                              (match (string_drop _s1743_ _s1744_) with
                               | _s1745_ =>
                                  (reg_name_matches_prefix _s1745_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1746_ _)) =>
                                               match (string_drop _s1745_ _s1746_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1724_ (_s1725_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1726_ := _s1725_ in
   (if ((string_startswith _s1726_ "CGetTag")) then
      (match (string_drop _s1726_ (projT1 (string_length "CGetTag"))) with
       | _s1727_ =>
          (spc_matches_prefix _s1727_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1728_ _)) =>
              (match (string_drop _s1727_ _s1728_) with
               | _s1729_ =>
                  (reg_name_matches_prefix _s1729_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1730_ _)) =>
                      (match (string_drop _s1729_ _s1730_) with
                       | _s1731_ =>
                          (sep_matches_prefix _s1731_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1732_ _)) =>
                              (match (string_drop _s1731_ _s1732_) with
                               | _s1733_ =>
                                  (reg_name_matches_prefix _s1733_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1734_ _)) =>
                                               match (string_drop _s1733_ _s1734_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1712_ (_s1713_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1714_ := _s1713_ in
   (if ((string_startswith _s1714_ "CGetLen")) then
      (match (string_drop _s1714_ (projT1 (string_length "CGetLen"))) with
       | _s1715_ =>
          (spc_matches_prefix _s1715_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1716_ _)) =>
              (match (string_drop _s1715_ _s1716_) with
               | _s1717_ =>
                  (reg_name_matches_prefix _s1717_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1718_ _)) =>
                      (match (string_drop _s1717_ _s1718_) with
                       | _s1719_ =>
                          (sep_matches_prefix _s1719_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1720_ _)) =>
                              (match (string_drop _s1719_ _s1720_) with
                               | _s1721_ =>
                                  (reg_name_matches_prefix _s1721_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1722_ _)) =>
                                               match (string_drop _s1721_ _s1722_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1700_ (_s1701_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1702_ := _s1701_ in
   (if ((string_startswith _s1702_ "CGetBase")) then
      (match (string_drop _s1702_ (projT1 (string_length "CGetBase"))) with
       | _s1703_ =>
          (spc_matches_prefix _s1703_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1704_ _)) =>
              (match (string_drop _s1703_ _s1704_) with
               | _s1705_ =>
                  (reg_name_matches_prefix _s1705_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1706_ _)) =>
                      (match (string_drop _s1705_ _s1706_) with
                       | _s1707_ =>
                          (sep_matches_prefix _s1707_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1708_ _)) =>
                              (match (string_drop _s1707_ _s1708_) with
                               | _s1709_ =>
                                  (reg_name_matches_prefix _s1709_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1710_ _)) =>
                                               match (string_drop _s1709_ _s1710_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1688_ (_s1689_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1690_ := _s1689_ in
   (if ((string_startswith _s1690_ "CGetType")) then
      (match (string_drop _s1690_ (projT1 (string_length "CGetType"))) with
       | _s1691_ =>
          (spc_matches_prefix _s1691_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1692_ _)) =>
              (match (string_drop _s1691_ _s1692_) with
               | _s1693_ =>
                  (reg_name_matches_prefix _s1693_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1694_ _)) =>
                      (match (string_drop _s1693_ _s1694_) with
                       | _s1695_ =>
                          (sep_matches_prefix _s1695_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1696_ _)) =>
                              (match (string_drop _s1695_ _s1696_) with
                               | _s1697_ =>
                                  (reg_name_matches_prefix _s1697_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1698_ _)) =>
                                               match (string_drop _s1697_ _s1698_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1676_ (_s1677_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s1678_ := _s1677_ in
   (if ((string_startswith _s1678_ "CGetPerm")) then
      (match (string_drop _s1678_ (projT1 (string_length "CGetPerm"))) with
       | _s1679_ =>
          (spc_matches_prefix _s1679_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1680_ _)) =>
              (match (string_drop _s1679_ _s1680_) with
               | _s1681_ =>
                  (reg_name_matches_prefix _s1681_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1682_ _)) =>
                      (match (string_drop _s1681_ _s1682_) with
                       | _s1683_ =>
                          (sep_matches_prefix _s1683_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1684_ _)) =>
                              (match (string_drop _s1683_ _s1684_) with
                               | _s1685_ =>
                                  (reg_name_matches_prefix _s1685_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some (cb,(existT _ _s1686_ _)) =>
                                               match (string_drop _s1685_ _s1686_) with
                                               | s_ => Some ((rd, cb, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s1661_ (_s1662_ : string) 
: M (option ((sopw * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s1662_ with
    | _s1663_ =>
       (shiftiwop_mnemonic_matches_prefix _s1663_) >>= fun w__0 : option ((sopw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1664_ _)) =>
           (match (string_drop _s1663_ _s1664_) with
            | _s1665_ =>
               (spc_matches_prefix _s1665_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1666_ _)) =>
                   (match (string_drop _s1665_ _s1666_) with
                    | _s1667_ =>
                       (reg_name_matches_prefix _s1667_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1668_ _)) =>
                           (match (string_drop _s1667_ _s1668_) with
                            | _s1669_ =>
                               (sep_matches_prefix _s1669_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1670_ _)) =>
                                   (match (string_drop _s1669_ _s1670_) with
                                    | _s1671_ =>
                                       (reg_name_matches_prefix _s1671_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       returnm ((match w__4 with
                                                 | Some (rs1,(existT _ _s1672_ _)) =>
                                                    match (string_drop _s1671_ _s1672_) with
                                                    | _s1673_ =>
                                                       match (hex_bits_5_matches_prefix _s1673_) with
                                                       | Some (shamt,(existT _ _s1674_ _)) =>
                                                          match (string_drop _s1673_ _s1674_) with
                                                          | s_ => Some ((op, rd, rs1, shamt, s_))
                                                          end
                                                       | _ => None
                                                       end
                                                    end
                                                 | _ => None
                                                 end)
                                        : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((sopw * mword 5 * mword 5 * mword 5 * string))).

Definition _s1644_ (_s1645_ : string) 
: M (option ((ropw * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s1645_ with
    | _s1646_ =>
       (rtypew_mnemonic_matches_prefix _s1646_) >>= fun w__0 : option ((ropw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1647_ _)) =>
           (match (string_drop _s1646_ _s1647_) with
            | _s1648_ =>
               (spc_matches_prefix _s1648_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1649_ _)) =>
                   (match (string_drop _s1648_ _s1649_) with
                    | _s1650_ =>
                       (reg_name_matches_prefix _s1650_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1651_ _)) =>
                           (match (string_drop _s1650_ _s1651_) with
                            | _s1652_ =>
                               (sep_matches_prefix _s1652_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1653_ _)) =>
                                   (match (string_drop _s1652_ _s1653_) with
                                    | _s1654_ =>
                                       (reg_name_matches_prefix _s1654_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1655_ _)) =>
                                           (match (string_drop _s1654_ _s1655_) with
                                            | _s1656_ =>
                                               (sep_matches_prefix _s1656_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some (tt,(existT _ _s1657_ _)) =>
                                                   (match (string_drop _s1656_ _s1657_) with
                                                    | _s1658_ =>
                                                       (reg_name_matches_prefix _s1658_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some (rs2,(existT _ _s1659_ _)) =>
                                                                    match (string_drop _s1658_
                                                                             _s1659_) with
                                                                    | s_ =>
                                                                       Some ((op, rd, rs1, rs2, s_))
                                                                    end
                                                                 | _ => None
                                                                 end)
                                                        : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                                    end)
                                                    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                                end)
                                                : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string))).

Definition _s1627_ (_s1628_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s1628_ with
    | _s1629_ =>
       (shiftw_mnemonic_matches_prefix _s1629_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1630_ _)) =>
           (match (string_drop _s1629_ _s1630_) with
            | _s1631_ =>
               (spc_matches_prefix _s1631_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1632_ _)) =>
                   (match (string_drop _s1631_ _s1632_) with
                    | _s1633_ =>
                       (reg_name_matches_prefix _s1633_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1634_ _)) =>
                           (match (string_drop _s1633_ _s1634_) with
                            | _s1635_ =>
                               (sep_matches_prefix _s1635_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1636_ _)) =>
                                   (match (string_drop _s1635_ _s1636_) with
                                    | _s1637_ =>
                                       (reg_name_matches_prefix _s1637_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1638_ _)) =>
                                           (match (string_drop _s1637_ _s1638_) with
                                            | _s1639_ =>
                                               (sep_matches_prefix _s1639_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s1640_ _)) =>
                                                            match (string_drop _s1639_ _s1640_) with
                                                            | _s1641_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s1641_) with
                                                               | Some (shamt,(existT _ _s1642_ _)) =>
                                                                  match (string_drop _s1641_ _s1642_) with
                                                                  | s_ =>
                                                                     Some ((op, rd, rs1, shamt, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 5 * string))).

Definition _s1611_ (_s1612_ : string) 
: M (option ((mword 5 * mword 5 * mword 12 * string))) :=
   
   let _s1613_ := _s1612_ in
   (if ((string_startswith _s1613_ "addiw")) then
      (match (string_drop _s1613_ (projT1 (string_length "addiw"))) with
       | _s1614_ =>
          (spc_matches_prefix _s1614_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1615_ _)) =>
              (match (string_drop _s1614_ _s1615_) with
               | _s1616_ =>
                  (reg_name_matches_prefix _s1616_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1617_ _)) =>
                      (match (string_drop _s1616_ _s1617_) with
                       | _s1618_ =>
                          (sep_matches_prefix _s1618_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1619_ _)) =>
                              (match (string_drop _s1618_ _s1619_) with
                               | _s1620_ =>
                                  (reg_name_matches_prefix _s1620_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (rs1,(existT _ _s1621_ _)) =>
                                      (match (string_drop _s1620_ _s1621_) with
                                       | _s1622_ =>
                                          (sep_matches_prefix _s1622_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s1623_ _)) =>
                                                       match (string_drop _s1622_ _s1623_) with
                                                       | _s1624_ =>
                                                          match (hex_bits_12_matches_prefix _s1624_) with
                                                          | Some (imm,(existT _ _s1625_ _)) =>
                                                             match (string_drop _s1624_ _s1625_) with
                                                             | s_ => Some ((rd, rs1, imm, s_))
                                                             end
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12 * string))))
    : M (option ((mword 5 * mword 5 * mword 12 * string))).

Definition _s1594_ (_s1595_ : string) 
: M (option ((rop * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s1595_ with
    | _s1596_ =>
       (rtype_mnemonic_matches_prefix _s1596_) >>= fun w__0 : option ((rop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1597_ _)) =>
           (match (string_drop _s1596_ _s1597_) with
            | _s1598_ =>
               (spc_matches_prefix _s1598_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1599_ _)) =>
                   (match (string_drop _s1598_ _s1599_) with
                    | _s1600_ =>
                       (reg_name_matches_prefix _s1600_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1601_ _)) =>
                           (match (string_drop _s1600_ _s1601_) with
                            | _s1602_ =>
                               (sep_matches_prefix _s1602_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1603_ _)) =>
                                   (match (string_drop _s1602_ _s1603_) with
                                    | _s1604_ =>
                                       (reg_name_matches_prefix _s1604_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1605_ _)) =>
                                           (match (string_drop _s1604_ _s1605_) with
                                            | _s1606_ =>
                                               (sep_matches_prefix _s1606_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some (tt,(existT _ _s1607_ _)) =>
                                                   (match (string_drop _s1606_ _s1607_) with
                                                    | _s1608_ =>
                                                       (reg_name_matches_prefix _s1608_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some (rs2,(existT _ _s1609_ _)) =>
                                                                    match (string_drop _s1608_
                                                                             _s1609_) with
                                                                    | s_ =>
                                                                       Some ((op, rd, rs1, rs2, s_))
                                                                    end
                                                                 | _ => None
                                                                 end)
                                                        : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                                    end)
                                                    : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                                end)
                                                : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((rop * mword 5 * mword 5 * mword 5 * string))).

Definition _s1579_ (_s1580_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 6 * string))) :=
   
   (match _s1580_ with
    | _s1581_ =>
       (shiftiop_mnemonic_matches_prefix _s1581_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1582_ _)) =>
           (match (string_drop _s1581_ _s1582_) with
            | _s1583_ =>
               (spc_matches_prefix _s1583_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1584_ _)) =>
                   (match (string_drop _s1583_ _s1584_) with
                    | _s1585_ =>
                       (reg_name_matches_prefix _s1585_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1586_ _)) =>
                           (match (string_drop _s1585_ _s1586_) with
                            | _s1587_ =>
                               (sep_matches_prefix _s1587_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1588_ _)) =>
                                   (match (string_drop _s1587_ _s1588_) with
                                    | _s1589_ =>
                                       (reg_name_matches_prefix _s1589_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       returnm ((match w__4 with
                                                 | Some (rs1,(existT _ _s1590_ _)) =>
                                                    match (string_drop _s1589_ _s1590_) with
                                                    | _s1591_ =>
                                                       match (hex_bits_6_matches_prefix _s1591_) with
                                                       | Some (shamt,(existT _ _s1592_ _)) =>
                                                          match (string_drop _s1591_ _s1592_) with
                                                          | s_ => Some ((op, rd, rs1, shamt, s_))
                                                          end
                                                       | _ => None
                                                       end
                                                    end
                                                 | _ => None
                                                 end)
                                        : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                        | _ =>
                           returnm (None  : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6 * string)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 6 * string))).

Definition _s1562_ (_s1563_ : string) 
: M (option ((iop * mword 5 * mword 5 * mword 12 * string))) :=
   
   (match _s1563_ with
    | _s1564_ =>
       (itype_mnemonic_matches_prefix _s1564_) >>= fun w__0 : option ((iop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1565_ _)) =>
           (match (string_drop _s1564_ _s1565_) with
            | _s1566_ =>
               (spc_matches_prefix _s1566_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1567_ _)) =>
                   (match (string_drop _s1566_ _s1567_) with
                    | _s1568_ =>
                       (reg_name_matches_prefix _s1568_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1569_ _)) =>
                           (match (string_drop _s1568_ _s1569_) with
                            | _s1570_ =>
                               (sep_matches_prefix _s1570_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1571_ _)) =>
                                   (match (string_drop _s1570_ _s1571_) with
                                    | _s1572_ =>
                                       (reg_name_matches_prefix _s1572_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs1,(existT _ _s1573_ _)) =>
                                           (match (string_drop _s1572_ _s1573_) with
                                            | _s1574_ =>
                                               (sep_matches_prefix _s1574_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s1575_ _)) =>
                                                            match (string_drop _s1574_ _s1575_) with
                                                            | _s1576_ =>
                                                               match (hex_bits_12_matches_prefix
                                                                        _s1576_) with
                                                               | Some (imm,(existT _ _s1577_ _)) =>
                                                                  match (string_drop _s1576_ _s1577_) with
                                                                  | s_ =>
                                                                     Some ((op, rd, rs1, imm, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                            end)
                                            : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                        end)
                                        : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                    end)
                                    : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                end)
                                : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                            end)
                            : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                        | _ =>
                           returnm (None  : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                        end)
                        : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                    end)
                    : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                end)
                : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
            end)
            : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12 * string)))
        end)
        : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
    end)
    : M (option ((iop * mword 5 * mword 5 * mword 12 * string))).

Definition _s1545_ (_s1546_ : string) 
: M (option ((bop * mword 5 * mword 5 * mword 13 * string))) :=
   
   (match _s1546_ with
    | _s1547_ =>
       (btype_mnemonic_matches_prefix _s1547_) >>= fun w__0 : option ((bop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1548_ _)) =>
           (match (string_drop _s1547_ _s1548_) with
            | _s1549_ =>
               (spc_matches_prefix _s1549_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1550_ _)) =>
                   (match (string_drop _s1549_ _s1550_) with
                    | _s1551_ =>
                       (reg_name_matches_prefix _s1551_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rs1,(existT _ _s1552_ _)) =>
                           (match (string_drop _s1551_ _s1552_) with
                            | _s1553_ =>
                               (sep_matches_prefix _s1553_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some (tt,(existT _ _s1554_ _)) =>
                                   (match (string_drop _s1553_ _s1554_) with
                                    | _s1555_ =>
                                       (reg_name_matches_prefix _s1555_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some (rs2,(existT _ _s1556_ _)) =>
                                           (match (string_drop _s1555_ _s1556_) with
                                            | _s1557_ =>
                                               (sep_matches_prefix _s1557_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some (tt,(existT _ _s1558_ _)) =>
                                                            match (string_drop _s1557_ _s1558_) with
                                                            | _s1559_ =>
                                                               match (hex_bits_13_matches_prefix
                                                                        _s1559_) with
                                                               | Some (imm,(existT _ _s1560_ _)) =>
                                                                  match (string_drop _s1559_ _s1560_) with
                                                                  | s_ =>
                                                                     Some ((op, rs1, rs2, imm, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                            end)
                                            : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                        end)
                                        : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                    end)
                                    : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                end)
                                : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                            end)
                            : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                        | _ =>
                           returnm (None  : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                        end)
                        : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                    end)
                    : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                end)
                : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
            end)
            : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13 * string)))
        end)
        : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
    end)
    : M (option ((bop * mword 5 * mword 5 * mword 13 * string))).

Definition _s1529_ (_s1530_ : string) 
: M (option ((mword 5 * mword 5 * mword 12 * string))) :=
   
   let _s1531_ := _s1530_ in
   (if ((string_startswith _s1531_ "jalr")) then
      (match (string_drop _s1531_ (projT1 (string_length "jalr"))) with
       | _s1532_ =>
          (spc_matches_prefix _s1532_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1533_ _)) =>
              (match (string_drop _s1532_ _s1533_) with
               | _s1534_ =>
                  (reg_name_matches_prefix _s1534_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1535_ _)) =>
                      (match (string_drop _s1534_ _s1535_) with
                       | _s1536_ =>
                          (sep_matches_prefix _s1536_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some (tt,(existT _ _s1537_ _)) =>
                              (match (string_drop _s1536_ _s1537_) with
                               | _s1538_ =>
                                  (reg_name_matches_prefix _s1538_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some (rs1,(existT _ _s1539_ _)) =>
                                      (match (string_drop _s1538_ _s1539_) with
                                       | _s1540_ =>
                                          (sep_matches_prefix _s1540_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some (tt,(existT _ _s1541_ _)) =>
                                                       match (string_drop _s1540_ _s1541_) with
                                                       | _s1542_ =>
                                                          match (hex_bits_12_matches_prefix _s1542_) with
                                                          | Some (imm,(existT _ _s1543_ _)) =>
                                                             match (string_drop _s1542_ _s1543_) with
                                                             | s_ => Some ((rd, rs1, imm, s_))
                                                             end
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12 * string))))
    : M (option ((mword 5 * mword 5 * mword 12 * string))).

Definition _s1517_ (_s1518_ : string) 
: M (option ((mword 5 * mword 21 * string))) :=
   
   let _s1519_ := _s1518_ in
   (if ((string_startswith _s1519_ "jal")) then
      (match (string_drop _s1519_ (projT1 (string_length "jal"))) with
       | _s1520_ =>
          (spc_matches_prefix _s1520_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some (tt,(existT _ _s1521_ _)) =>
              (match (string_drop _s1520_ _s1521_) with
               | _s1522_ =>
                  (reg_name_matches_prefix _s1522_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some (rd,(existT _ _s1523_ _)) =>
                      (match (string_drop _s1522_ _s1523_) with
                       | _s1524_ =>
                          (sep_matches_prefix _s1524_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some (tt,(existT _ _s1525_ _)) =>
                                       match (string_drop _s1524_ _s1525_) with
                                       | _s1526_ =>
                                          match (hex_bits_21_matches_prefix _s1526_) with
                                          | Some (imm,(existT _ _s1527_ _)) =>
                                             match (string_drop _s1526_ _s1527_) with
                                             | s_ => Some ((rd, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 21 * string)))
                       end)
                       : M (option ((mword 5 * mword 21 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 21 * string)))
                   end)
                   : M (option ((mword 5 * mword 21 * string)))
               end)
               : M (option ((mword 5 * mword 21 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 21 * string)))
           end)
           : M (option ((mword 5 * mword 21 * string)))
       end)
       : M (option ((mword 5 * mword 21 * string)))
    else returnm (None  : option ((mword 5 * mword 21 * string))))
    : M (option ((mword 5 * mword 21 * string))).

Definition _s1504_ (_s1505_ : string) 
: M (option ((uop * mword 5 * mword 20 * string))) :=
   
   (match _s1505_ with
    | _s1506_ =>
       (utype_mnemonic_matches_prefix _s1506_) >>= fun w__0 : option ((uop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (op,(existT _ _s1507_ _)) =>
           (match (string_drop _s1506_ _s1507_) with
            | _s1508_ =>
               (spc_matches_prefix _s1508_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some (tt,(existT _ _s1509_ _)) =>
                   (match (string_drop _s1508_ _s1509_) with
                    | _s1510_ =>
                       (reg_name_matches_prefix _s1510_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some (rd,(existT _ _s1511_ _)) =>
                           (match (string_drop _s1510_ _s1511_) with
                            | _s1512_ =>
                               (sep_matches_prefix _s1512_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some (tt,(existT _ _s1513_ _)) =>
                                            match (string_drop _s1512_ _s1513_) with
                                            | _s1514_ =>
                                               match (hex_bits_20_matches_prefix _s1514_) with
                                               | Some (imm,(existT _ _s1515_ _)) =>
                                                  match (string_drop _s1514_ _s1515_) with
                                                  | s_ => Some ((op, rd, imm, s_))
                                                  end
                                               | _ => None
                                               end
                                            end
                                         | _ => None
                                         end)
                                : option ((uop * mword 5 * mword 20 * string)))
                            end)
                            : M (option ((uop * mword 5 * mword 20 * string)))
                        | _ => returnm (None  : option ((uop * mword 5 * mword 20 * string)))
                        end)
                        : M (option ((uop * mword 5 * mword 20 * string)))
                    end)
                    : M (option ((uop * mword 5 * mword 20 * string)))
                | _ => returnm (None  : option ((uop * mword 5 * mword 20 * string)))
                end)
                : M (option ((uop * mword 5 * mword 20 * string)))
            end)
            : M (option ((uop * mword 5 * mword 20 * string)))
        | _ => returnm (None  : option ((uop * mword 5 * mword 20 * string)))
        end)
        : M (option ((uop * mword 5 * mword 20 * string)))
    end)
    : M (option ((uop * mword 5 * mword 20 * string))).

Definition assembly_matches_prefix (arg_ : string) 
: M (option ((ast * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s1516_ := arg_ in
   (_s1504_ _s1516_) >>= fun w__0 : option ((uop * mword 5 * mword 20 * string)) =>
   (if ((match w__0 with | Some (op,rd,imm,s_) => true | _ => false end)) then
      (_s1504_ _s1516_) >>= fun w__1 : option ((uop * mword 5 * mword 20 * string)) =>
      (match w__1 with
       | Some (op,rd,imm,s_) =>
          returnm ((Some
                      ((UTYPE
                          ((imm, rd, op)), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ast * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
    else
      (_s1517_ _s1516_) >>= fun w__4 : option ((mword 5 * mword 21 * string)) =>
      (if ((match w__4 with | Some (rd,imm,s_) => true | _ => false end)) then
         (_s1517_ _s1516_) >>= fun w__5 : option ((mword 5 * mword 21 * string)) =>
         (match w__5 with
          | Some (rd,imm,s_) =>
             returnm ((Some
                         ((RISCV_JAL
                             ((imm, rd)), build_ex
                         (projT1
                          (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
              : option ((ast * {n : Z & ArithFact (n >= 0)})))
          | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
          end)
          : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
       else
         (_s1529_ _s1516_) >>= fun w__8 : option ((mword 5 * mword 5 * mword 12 * string)) =>
         (if ((match w__8 with | Some (rd,rs1,imm,s_) => true | _ => false end)) then
            (_s1529_ _s1516_) >>= fun w__9 : option ((mword 5 * mword 5 * mword 12 * string)) =>
            (match w__9 with
             | Some (rd,rs1,imm,s_) =>
                returnm ((Some
                            ((RISCV_JALR
                                ((imm, rs1, rd)), build_ex
                            (projT1
                             (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
                 : option ((ast * {n : Z & ArithFact (n >= 0)})))
             | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
             end)
             : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
          else
            (_s1545_ _s1516_) >>= fun w__12 : option ((bop * mword 5 * mword 5 * mword 13 * string)) =>
            (if ((match w__12 with | Some (op,rs1,rs2,imm,s_) => true | _ => false end)) then
               (_s1545_ _s1516_) >>= fun w__13 : option ((bop * mword 5 * mword 5 * mword 13 * string)) =>
               (match w__13 with
                | Some (op,rs1,rs2,imm,s_) =>
                   returnm ((Some
                               ((BTYPE
                                   ((imm, rs2, rs1, op)), build_ex
                               (projT1
                                (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
                    : option ((ast * {n : Z & ArithFact (n >= 0)})))
                | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                end)
                : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
             else
               (_s1562_ _s1516_) >>= fun w__16 : option ((iop * mword 5 * mword 5 * mword 12 * string)) =>
               (if ((match w__16 with | Some (op,rd,rs1,imm,s_) => true | _ => false end)) then
                  (_s1562_ _s1516_) >>= fun w__17 : option ((iop * mword 5 * mword 5 * mword 12 * string)) =>
                  (match w__17 with
                   | Some (op,rd,rs1,imm,s_) =>
                      returnm ((Some
                                  ((ITYPE
                                      ((imm, rs1, rd, op)), build_ex
                                  (projT1
                                   (sub_nat (projT1 (string_length arg_))
                                      (projT1
                                       (string_length s_)))))))
                       : option ((ast * {n : Z & ArithFact (n >= 0)})))
                   | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                   end)
                   : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                else
                  (_s1579_ _s1516_) >>= fun w__20 : option ((sop * mword 5 * mword 5 * mword 6 * string)) =>
                  (if ((match w__20 with | Some (op,rd,rs1,shamt,s_) => true | _ => false end)) then
                     (_s1579_ _s1516_) >>= fun w__21 : option ((sop * mword 5 * mword 5 * mword 6 * string)) =>
                     (match w__21 with
                      | Some (op,rd,rs1,shamt,s_) =>
                         returnm ((Some
                                     ((SHIFTIOP
                                         ((shamt, rs1, rd, op)), build_ex
                                     (projT1
                                      (sub_nat (projT1 (string_length arg_))
                                         (projT1
                                          (string_length s_)))))))
                          : option ((ast * {n : Z & ArithFact (n >= 0)})))
                      | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                      end)
                      : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                   else
                     (_s1594_ _s1516_) >>= fun w__24 : option ((rop * mword 5 * mword 5 * mword 5 * string)) =>
                     (if ((match w__24 with | Some (op,rd,rs1,rs2,s_) => true | _ => false end))
                      then
                        (_s1594_ _s1516_) >>= fun w__25 : option ((rop * mword 5 * mword 5 * mword 5 * string)) =>
                        (match w__25 with
                         | Some (op,rd,rs1,rs2,s_) =>
                            returnm ((Some
                                        ((RTYPE
                                            ((rs2, rs1, rd, op)), build_ex
                                        (projT1
                                         (sub_nat (projT1 (string_length arg_))
                                            (projT1
                                             (string_length s_)))))))
                             : option ((ast * {n : Z & ArithFact (n >= 0)})))
                         | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                         end)
                         : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                      else
                        (_s1611_ _s1516_) >>= fun w__28 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                        (if ((match w__28 with | Some (rd,rs1,imm,s_) => true | _ => false end))
                         then
                           (_s1611_ _s1516_) >>= fun w__29 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                           (match w__29 with
                            | Some (rd,rs1,imm,s_) =>
                               returnm ((Some
                                           ((ADDIW
                                               ((imm, rs1, rd)), build_ex
                                           (projT1
                                            (sub_nat (projT1 (string_length arg_))
                                               (projT1
                                                (string_length s_)))))))
                                : option ((ast * {n : Z & ArithFact (n >= 0)})))
                            | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                            end)
                            : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                         else
                           (_s1627_ _s1516_) >>= fun w__32 : option ((sop * mword 5 * mword 5 * mword 5 * string)) =>
                           (if ((match w__32 with
                                 | Some (op,rd,rs1,shamt,s_) => true
                                 | _ => false
                                 end)) then
                              (_s1627_ _s1516_) >>= fun w__33 : option ((sop * mword 5 * mword 5 * mword 5 * string)) =>
                              (match w__33 with
                               | Some (op,rd,rs1,shamt,s_) =>
                                  returnm ((Some
                                              ((SHIFTW
                                                  ((shamt, rs1, rd, op)), build_ex
                                              (projT1
                                               (sub_nat (projT1 (string_length arg_))
                                                  (projT1
                                                   (string_length s_)))))))
                                   : option ((ast * {n : Z & ArithFact (n >= 0)})))
                               | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                               end)
                               : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                            else
                              (_s1644_ _s1516_) >>= fun w__36 : option ((ropw * mword 5 * mword 5 * mword 5 * string)) =>
                              (if ((match w__36 with
                                    | Some (op,rd,rs1,rs2,s_) => true
                                    | _ => false
                                    end)) then
                                 (_s1644_ _s1516_) >>= fun w__37 : option ((ropw * mword 5 * mword 5 * mword 5 * string)) =>
                                 (match w__37 with
                                  | Some (op,rd,rs1,rs2,s_) =>
                                     returnm ((Some
                                                 ((RTYPEW
                                                     ((rs2, rs1, rd, op)), build_ex
                                                 (projT1
                                                  (sub_nat (projT1 (string_length arg_))
                                                     (projT1
                                                      (string_length s_)))))))
                                      : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                  | _ =>
                                     exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                  end)
                                  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                               else
                                 (_s1661_ _s1516_) >>= fun w__40 : option ((sopw * mword 5 * mword 5 * mword 5 * string)) =>
                                 (if ((match w__40 with
                                       | Some (op,rd,rs1,shamt,s_) => true
                                       | _ => false
                                       end)) then
                                    (_s1661_ _s1516_) >>= fun w__41 : option ((sopw * mword 5 * mword 5 * mword 5 * string)) =>
                                    (match w__41 with
                                     | Some (op,rd,rs1,shamt,s_) =>
                                        returnm ((Some
                                                    ((SHIFTIWOP
                                                        ((shamt, rs1, rd, op)), build_ex
                                                    (projT1
                                                     (sub_nat (projT1 (string_length arg_))
                                                        (projT1
                                                         (string_length s_)))))))
                                         : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                     | _ =>
                                        exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                     end)
                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                  else
                                    (_s1676_ _s1516_) >>= fun w__44 : option ((mword 5 * mword 5 * string)) =>
                                    (if ((match w__44 with
                                          | Some (rd,cb,s_) => true
                                          | _ => false
                                          end)) then
                                       (_s1676_ _s1516_) >>= fun w__45 : option ((mword 5 * mword 5 * string)) =>
                                       (match w__45 with
                                        | Some (rd,cb,s_) =>
                                           returnm ((Some
                                                       ((CGetPerm
                                                           ((rd, cb)), build_ex
                                                       (projT1
                                                        (sub_nat (projT1 (string_length arg_))
                                                           (projT1
                                                            (string_length s_)))))))
                                            : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                        | _ =>
                                           exit tt
                                            : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                        end)
                                        : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                     else
                                       (_s1688_ _s1516_) >>= fun w__48 : option ((mword 5 * mword 5 * string)) =>
                                       (if ((match w__48 with
                                             | Some (rd,cb,s_) => true
                                             | _ => false
                                             end)) then
                                          (_s1688_ _s1516_) >>= fun w__49 : option ((mword 5 * mword 5 * string)) =>
                                          (match w__49 with
                                           | Some (rd,cb,s_) =>
                                              returnm ((Some
                                                          ((CGetType
                                                              ((rd, cb)), build_ex
                                                          (projT1
                                                           (sub_nat (projT1 (string_length arg_))
                                                              (projT1
                                                               (string_length s_)))))))
                                               : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                           | _ =>
                                              exit tt
                                               : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                           end)
                                           : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                        else
                                          (_s1700_ _s1516_) >>= fun w__52 : option ((mword 5 * mword 5 * string)) =>
                                          (if ((match w__52 with
                                                | Some (rd,cb,s_) => true
                                                | _ => false
                                                end)) then
                                             (_s1700_ _s1516_) >>= fun w__53 : option ((mword 5 * mword 5 * string)) =>
                                             (match w__53 with
                                              | Some (rd,cb,s_) =>
                                                 returnm ((Some
                                                             ((CGetBase
                                                                 ((rd, cb)), build_ex
                                                             (projT1
                                                              (sub_nat (projT1 (string_length arg_))
                                                                 (projT1
                                                                  (string_length s_)))))))
                                                  : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              | _ =>
                                                 exit tt
                                                  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              end)
                                              : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                           else
                                             (_s1712_ _s1516_) >>= fun w__56 : option ((mword 5 * mword 5 * string)) =>
                                             (if ((match w__56 with
                                                   | Some (rd,cb,s_) => true
                                                   | _ => false
                                                   end)) then
                                                (_s1712_ _s1516_) >>= fun w__57 : option ((mword 5 * mword 5 * string)) =>
                                                (match w__57 with
                                                 | Some (rd,cb,s_) =>
                                                    returnm ((Some
                                                                ((CGetLen
                                                                    ((rd, cb)), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else
                                                (_s1724_ _s1516_) >>= fun w__60 : option ((mword 5 * mword 5 * string)) =>
                                                (if ((match w__60 with
                                                      | Some (rd,cb,s_) => true
                                                      | _ => false
                                                      end)) then
                                                   (_s1724_ _s1516_) >>= fun w__61 : option ((mword 5 * mword 5 * string)) =>
                                                   (match w__61 with
                                                    | Some (rd,cb,s_) =>
                                                       returnm ((Some
                                                                   ((CGetTag
                                                                       ((rd, cb)), build_ex
                                                                   (projT1
                                                                    (sub_nat
                                                                       (projT1
                                                                        (string_length arg_))
                                                                       (projT1
                                                                        (string_length s_)))))))
                                                        : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                    | _ =>
                                                       exit tt
                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                         0)})))
                                                    end)
                                                    : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 else
                                                   (_s1736_ _s1516_) >>= fun w__64 : option ((mword 5 * mword 5 * string)) =>
                                                   (if ((match w__64 with
                                                         | Some (rd,cb,s_) => true
                                                         | _ => false
                                                         end)) then
                                                      (_s1736_ _s1516_) >>= fun w__65 : option ((mword 5 * mword 5 * string)) =>
                                                      (match w__65 with
                                                       | Some (rd,cb,s_) =>
                                                          returnm ((Some
                                                                      ((CGetSealed
                                                                          ((rd, cb)), build_ex
                                                                      (projT1
                                                                       (sub_nat
                                                                          (projT1
                                                                           (string_length arg_))
                                                                          (projT1
                                                                           (string_length s_)))))))
                                                           : option ((ast * {n : Z & ArithFact (n >=
                                                            0)})))
                                                       | _ =>
                                                          exit tt
                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                            0)})))
                                                       end)
                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                        0)})))
                                                    else
                                                      (_s1748_ _s1516_) >>= fun w__68 : option ((mword 5 * mword 5 * string)) =>
                                                      (if ((match w__68 with
                                                            | Some (rd,cb,s_) => true
                                                            | _ => false
                                                            end)) then
                                                         (_s1748_ _s1516_) >>= fun w__69 : option ((mword 5 * mword 5 * string)) =>
                                                         (match w__69 with
                                                          | Some (rd,cb,s_) =>
                                                             returnm ((Some
                                                                         ((CGetOffset
                                                                             ((rd, cb)), build_ex
                                                                         (projT1
                                                                          (sub_nat
                                                                             (projT1
                                                                              (string_length arg_))
                                                                             (projT1
                                                                              (string_length s_)))))))
                                                              : option ((ast * {n : Z & ArithFact (n >=
                                                               0)})))
                                                          | _ =>
                                                             exit tt
                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                               0)})))
                                                          end)
                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                           0)})))
                                                       else
                                                         (_s1760_ _s1516_) >>= fun w__72 : option ((mword 5 * mword 5 * string)) =>
                                                         (if ((match w__72 with
                                                               | Some (rd,cb,s_) => true
                                                               | _ => false
                                                               end)) then
                                                            (_s1760_ _s1516_) >>= fun w__73 : option ((mword 5 * mword 5 * string)) =>
                                                            (match w__73 with
                                                             | Some (rd,cb,s_) =>
                                                                returnm ((Some
                                                                            ((CGetAddr
                                                                                ((rd, cb)), build_ex
                                                                            (projT1
                                                                             (sub_nat
                                                                                (projT1
                                                                                 (string_length arg_))
                                                                                (projT1
                                                                                 (string_length s_)))))))
                                                                 : option ((ast * {n : Z & ArithFact (n >=
                                                                  0)})))
                                                             | _ =>
                                                                exit tt
                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                  0)})))
                                                             end)
                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                              0)})))
                                                          else
                                                            (_s1772_ _s1516_) >>= fun w__76 : option ((mword 5 * mword 5 * string)) =>
                                                            (if ((match w__76 with
                                                                  | Some (cd,cs,s_) => true
                                                                  | _ => false
                                                                  end)) then
                                                               (_s1772_ _s1516_) >>= fun w__77 : option ((mword 5 * mword 5 * string)) =>
                                                               (match w__77 with
                                                                | Some (cd,cs,s_) =>
                                                                   returnm ((Some
                                                                               ((CMove
                                                                                   ((cd, cs)), build_ex
                                                                               (projT1
                                                                                (sub_nat
                                                                                   (projT1
                                                                                    (string_length
                                                                                       arg_))
                                                                                   (projT1
                                                                                    (string_length
                                                                                       s_)))))))
                                                                    : option ((ast * {n : Z & ArithFact (n >=
                                                                     0)})))
                                                                | _ =>
                                                                   exit tt
                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                     0)})))
                                                                end)
                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                 0)})))
                                                             else
                                                               (_s1784_ _s1516_) >>= fun w__80 : option ((mword 5 * mword 5 * string)) =>
                                                               (if ((match w__80 with
                                                                     | Some (cd,cs,s_) => true
                                                                     | _ => false
                                                                     end)) then
                                                                  (_s1784_ _s1516_) >>= fun w__81 : option ((mword 5 * mword 5 * string)) =>
                                                                  (match w__81 with
                                                                   | Some (cd,cs,s_) =>
                                                                      returnm ((Some
                                                                                  ((CClearTag
                                                                                      ((cd, cs)), build_ex
                                                                                  (projT1
                                                                                   (sub_nat
                                                                                      (projT1
                                                                                       (string_length
                                                                                          arg_))
                                                                                      (projT1
                                                                                       (string_length
                                                                                          s_)))))))
                                                                       : option ((ast * {n : Z & ArithFact (n >=
                                                                        0)})))
                                                                   | _ =>
                                                                      exit tt
                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                        0)})))
                                                                   end)
                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                    0)})))
                                                                else
                                                                  (_s1796_ _s1516_) >>= fun w__84 : option ((mword 5 * string)) =>
                                                                  (if ((match w__84 with
                                                                        | Some (cb,s_) => true
                                                                        | _ => false
                                                                        end)) then
                                                                     (_s1796_ _s1516_) >>= fun w__85 : option ((mword 5 * string)) =>
                                                                     (match w__85 with
                                                                      | Some (cb,s_) =>
                                                                         returnm ((Some
                                                                                     ((CJALR
                                                                                         (((vec_of_bits [B0;B0;B0;B0;B0]
                                                                                             : mword 5), cb)), build_ex
                                                                                     (projT1
                                                                                      (sub_nat
                                                                                         (projT1
                                                                                          (string_length
                                                                                             arg_))
                                                                                         (projT1
                                                                                          (string_length
                                                                                             s_)))))))
                                                                          : option ((ast * {n : Z & ArithFact (n >=
                                                                           0)})))
                                                                      | _ =>
                                                                         exit tt
                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                           0)})))
                                                                      end)
                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                       0)})))
                                                                   else
                                                                     (_s1804_ _s1516_) >>= fun w__88 : option ((mword 5 * mword 5 * string)) =>
                                                                     (if ((match w__88 with
                                                                           | Some (cd,cb,s_) => true
                                                                           | _ => false
                                                                           end)) then
                                                                        (_s1804_ _s1516_) >>= fun w__89 : option ((mword 5 * mword 5 * string)) =>
                                                                        (match w__89 with
                                                                         | Some (cd,cb,s_) =>
                                                                            returnm ((Some
                                                                                        ((CJALR
                                                                                            ((cd, cb)), build_ex
                                                                                        (projT1
                                                                                         (sub_nat
                                                                                            (projT1
                                                                                             (string_length
                                                                                                arg_))
                                                                                            (projT1
                                                                                             (string_length
                                                                                                s_)))))))
                                                                             : option ((ast * {n : Z & ArithFact (n >=
                                                                              0)})))
                                                                         | _ =>
                                                                            exit tt
                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                              0)})))
                                                                         end)
                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                          0)})))
                                                                      else
                                                                        (_s1816_ _s1516_) >>= fun w__92 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                        (if ((match w__92 with
                                                                              | Some (cd,cs,ct,s_) =>
                                                                                 true
                                                                              | _ => false
                                                                              end)) then
                                                                           (_s1816_ _s1516_) >>= fun w__93 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                           (match w__93 with
                                                                            | Some (cd,cs,ct,s_) =>
                                                                               returnm ((Some
                                                                                           ((CSeal
                                                                                               ((cd, cs, ct)), build_ex
                                                                                           (projT1
                                                                                            (sub_nat
                                                                                               (projT1
                                                                                                (string_length
                                                                                                   arg_))
                                                                                               (projT1
                                                                                                (string_length
                                                                                                   s_)))))))
                                                                                : option ((ast * {n : Z & ArithFact (n >=
                                                                                 0)})))
                                                                            | _ =>
                                                                               exit tt
                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                 0)})))
                                                                            end)
                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                             0)})))
                                                                         else
                                                                           (_s1832_ _s1516_) >>= fun w__96 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                           (if ((match w__96 with
                                                                                 | Some
                                                                                   (cd,cs,ct,s_) =>
                                                                                    true
                                                                                 | _ => false
                                                                                 end)) then
                                                                              (_s1832_ _s1516_) >>= fun w__97 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                              (match w__97 with
                                                                               | Some (cd,cs,ct,s_) =>
                                                                                  returnm ((Some
                                                                                              ((CUnseal
                                                                                                  ((cd, cs, ct)), build_ex
                                                                                              (projT1
                                                                                               (sub_nat
                                                                                                  (projT1
                                                                                                   (string_length
                                                                                                      arg_))
                                                                                                  (projT1
                                                                                                   (string_length
                                                                                                      s_)))))))
                                                                                   : option ((ast * {n : Z & ArithFact (n >=
                                                                                    0)})))
                                                                               | _ =>
                                                                                  exit tt
                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                    0)})))
                                                                               end)
                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                0)})))
                                                                            else
                                                                              (_s1848_ _s1516_) >>= fun w__100 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                              (if ((match w__100 with
                                                                                    | Some
                                                                                      (cd,cs,rt,s_) =>
                                                                                       true
                                                                                    | _ => false
                                                                                    end)) then
                                                                                 (_s1848_ _s1516_) >>= fun w__101 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                 (match w__101 with
                                                                                  | Some
                                                                                    (cd,cs,rt,s_) =>
                                                                                     returnm ((Some
                                                                                                 ((CAndPerm
                                                                                                     ((cd, cs, rt)), build_ex
                                                                                                 (projT1
                                                                                                  (sub_nat
                                                                                                     (projT1
                                                                                                      (string_length
                                                                                                         arg_))
                                                                                                     (projT1
                                                                                                      (string_length
                                                                                                         s_)))))))
                                                                                      : option ((ast * {n : Z & ArithFact (n >=
                                                                                       0)})))
                                                                                  | _ =>
                                                                                     exit tt
                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                       0)})))
                                                                                  end)
                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                   0)})))
                                                                               else
                                                                                 (_s1864_ _s1516_) >>= fun w__104 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                 (if ((match w__104 with
                                                                                       | Some
                                                                                         (cd,cs,rt,s_) =>
                                                                                          true
                                                                                       | _ => false
                                                                                       end)) then
                                                                                    (_s1864_ _s1516_) >>= fun w__105 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                    (match w__105 with
                                                                                     | Some
                                                                                       (cd,cs,rt,s_) =>
                                                                                        returnm ((Some
                                                                                                    ((CSetOffset
                                                                                                        ((cd, cs, rt)), build_ex
                                                                                                    (projT1
                                                                                                     (sub_nat
                                                                                                        (projT1
                                                                                                         (string_length
                                                                                                            arg_))
                                                                                                        (projT1
                                                                                                         (string_length
                                                                                                            s_)))))))
                                                                                         : option ((ast * {n : Z & ArithFact (n >=
                                                                                          0)})))
                                                                                     | _ =>
                                                                                        exit tt
                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                          0)})))
                                                                                     end)
                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                      0)})))
                                                                                  else
                                                                                    (_s1880_ _s1516_) >>= fun w__108 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                    (if ((match w__108 with
                                                                                          | Some
                                                                                            (cd,cs,rt,s_) =>
                                                                                             true
                                                                                          | _ =>
                                                                                             false
                                                                                          end)) then
                                                                                       (_s1880_
                                                                                          _s1516_) >>= fun w__109 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                       (match w__109 with
                                                                                        | Some
                                                                                          (cd,cs,rt,s_) =>
                                                                                           returnm ((Some
                                                                                                       ((CIncOffset
                                                                                                           ((cd, cs, rt)), build_ex
                                                                                                       (projT1
                                                                                                        (sub_nat
                                                                                                           (projT1
                                                                                                            (string_length
                                                                                                               arg_))
                                                                                                           (projT1
                                                                                                            (string_length
                                                                                                               s_)))))))
                                                                                            : option ((ast * {n : Z & ArithFact (n >=
                                                                                             0)})))
                                                                                        | _ =>
                                                                                           exit tt
                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                             0)})))
                                                                                        end)
                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                         0)})))
                                                                                     else
                                                                                       (_s1896_
                                                                                          _s1516_) >>= fun w__112 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                       (if ((match w__112 with
                                                                                             | Some
                                                                                               (cd,cs,rt,s_) =>
                                                                                                true
                                                                                             | _ =>
                                                                                                false
                                                                                             end))
                                                                                        then
                                                                                          (_s1896_
                                                                                             _s1516_) >>= fun w__113 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                          (match w__113 with
                                                                                           | Some
                                                                                             (cd,cs,rt,s_) =>
                                                                                              returnm ((Some
                                                                                                          ((CSetBounds
                                                                                                              ((cd, cs, rt)), build_ex
                                                                                                          (projT1
                                                                                                           (sub_nat
                                                                                                              (projT1
                                                                                                               (string_length
                                                                                                                  arg_))
                                                                                                              (projT1
                                                                                                               (string_length
                                                                                                                  s_)))))))
                                                                                               : option ((ast * {n : Z & ArithFact (n >=
                                                                                                0)})))
                                                                                           | _ =>
                                                                                              exit tt
                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                0)})))
                                                                                           end)
                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                            0)})))
                                                                                        else
                                                                                          (_s1912_
                                                                                             _s1516_) >>= fun w__116 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                          (if ((match w__116 with
                                                                                                | Some
                                                                                                  (cd,cs,rt,s_) =>
                                                                                                   true
                                                                                                | _ =>
                                                                                                   false
                                                                                                end))
                                                                                           then
                                                                                             (_s1912_
                                                                                                _s1516_) >>= fun w__117 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                             (match w__117 with
                                                                                              | Some
                                                                                                (cd,cs,rt,s_) =>
                                                                                                 returnm ((Some
                                                                                                             ((CSetBoundsExact
                                                                                                                 ((cd, cs, rt)), build_ex
                                                                                                             (projT1
                                                                                                              (sub_nat
                                                                                                                 (projT1
                                                                                                                  (string_length
                                                                                                                     arg_))
                                                                                                                 (projT1
                                                                                                                  (string_length
                                                                                                                     s_)))))))
                                                                                                  : option ((ast * {n : Z & ArithFact (n >=
                                                                                                   0)})))
                                                                                              | _ =>
                                                                                                 exit tt
                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                   0)})))
                                                                                              end)
                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                               0)})))
                                                                                           else
                                                                                             (_s1928_
                                                                                                _s1516_) >>= fun w__120 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                             (if ((match w__120 with
                                                                                                   | Some
                                                                                                     (rd,cb,cs,s_) =>
                                                                                                      true
                                                                                                   | _ =>
                                                                                                      false
                                                                                                   end))
                                                                                              then
                                                                                                (_s1928_
                                                                                                   _s1516_) >>= fun w__121 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                (match w__121 with
                                                                                                 | Some
                                                                                                   (rd,cb,cs,s_) =>
                                                                                                    returnm ((Some
                                                                                                                ((CToPtr
                                                                                                                    ((rd, cb, cs)), build_ex
                                                                                                                (projT1
                                                                                                                 (sub_nat
                                                                                                                    (projT1
                                                                                                                     (string_length
                                                                                                                        arg_))
                                                                                                                    (projT1
                                                                                                                     (string_length
                                                                                                                        s_)))))))
                                                                                                     : option ((ast * {n : Z & ArithFact (n >=
                                                                                                      0)})))
                                                                                                 | _ =>
                                                                                                    exit tt
                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                      0)})))
                                                                                                 end)
                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                  0)})))
                                                                                              else
                                                                                                (_s1944_
                                                                                                   _s1516_) >>= fun w__124 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                (if ((match w__124 with
                                                                                                      | Some
                                                                                                        (cd,cb,rs,s_) =>
                                                                                                         true
                                                                                                      | _ =>
                                                                                                         false
                                                                                                      end))
                                                                                                 then
                                                                                                   (_s1944_
                                                                                                      _s1516_) >>= fun w__125 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                   (match w__125 with
                                                                                                    | Some
                                                                                                      (cd,cb,rs,s_) =>
                                                                                                       returnm ((Some
                                                                                                                   ((CFromPtr
                                                                                                                       ((cd, cb, rs)), build_ex
                                                                                                                   (projT1
                                                                                                                    (sub_nat
                                                                                                                       (projT1
                                                                                                                        (string_length
                                                                                                                           arg_))
                                                                                                                       (projT1
                                                                                                                        (string_length
                                                                                                                           s_)))))))
                                                                                                        : option ((ast * {n : Z & ArithFact (n >=
                                                                                                         0)})))
                                                                                                    | _ =>
                                                                                                       exit tt
                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                         0)})))
                                                                                                    end)
                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                     0)})))
                                                                                                 else
                                                                                                   (_s1960_
                                                                                                      _s1516_) >>= fun w__128 : option ((mword 5 * mword 5 * string)) =>
                                                                                                   (if
                                                                                                      ((match w__128 with
                                                                                                        | Some
                                                                                                          (cs,cb,s_) =>
                                                                                                           true
                                                                                                        | _ =>
                                                                                                           false
                                                                                                        end))
                                                                                                    then
                                                                                                      (_s1960_
                                                                                                         _s1516_) >>= fun w__129 : option ((mword 5 * mword 5 * string)) =>
                                                                                                      (match w__129 with
                                                                                                       | Some
                                                                                                         (cs,cb,s_) =>
                                                                                                          returnm ((Some
                                                                                                                      ((CCall
                                                                                                                          ((cs, cb, (vec_of_bits [B0;B0;B0;B0;B1]
                                                                                                                                      : mword 5))), build_ex
                                                                                                                      (projT1
                                                                                                                       (sub_nat
                                                                                                                          (projT1
                                                                                                                           (string_length
                                                                                                                              arg_))
                                                                                                                          (projT1
                                                                                                                           (string_length
                                                                                                                              s_)))))))
                                                                                                           : option ((ast * {n : Z & ArithFact (n >=
                                                                                                            0)})))
                                                                                                       | _ =>
                                                                                                          exit tt
                                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                            0)})))
                                                                                                       end)
                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                        0)})))
                                                                                                    else
                                                                                                      (_s1972_
                                                                                                         _s1516_) >>= fun w__132 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                      (if
                                                                                                         ((match w__132 with
                                                                                                           | Some
                                                                                                             (cd,cb,imm12,s_) =>
                                                                                                              true
                                                                                                           | _ =>
                                                                                                              false
                                                                                                           end))
                                                                                                       then
                                                                                                         (_s1972_
                                                                                                            _s1516_) >>= fun w__133 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                         (match w__133 with
                                                                                                          | Some
                                                                                                            (cd,cb,imm12,s_) =>
                                                                                                             returnm ((Some
                                                                                                                         ((CIncOffsetImmediate
                                                                                                                             ((cd, cb, imm12)), build_ex
                                                                                                                         (projT1
                                                                                                                          (sub_nat
                                                                                                                             (projT1
                                                                                                                              (string_length
                                                                                                                                 arg_))
                                                                                                                             (projT1
                                                                                                                              (string_length
                                                                                                                                 s_)))))))
                                                                                                              : option ((ast * {n : Z & ArithFact (n >=
                                                                                                               0)})))
                                                                                                          | _ =>
                                                                                                             exit tt
                                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                               0)})))
                                                                                                          end)
                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                           0)})))
                                                                                                       else
                                                                                                         (_s1988_
                                                                                                            _s1516_) >>= fun w__136 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                         (if
                                                                                                            ((match w__136 with
                                                                                                              | Some
                                                                                                                (cd,cb,imm12,s_) =>
                                                                                                                 true
                                                                                                              | _ =>
                                                                                                                 false
                                                                                                              end))
                                                                                                          then
                                                                                                            (_s1988_
                                                                                                               _s1516_) >>= fun w__137 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                            (match w__137 with
                                                                                                             | Some
                                                                                                               (cd,cb,imm12,s_) =>
                                                                                                                returnm ((Some
                                                                                                                            ((CSetBoundsImmediate
                                                                                                                                ((cd, cb, imm12)), build_ex
                                                                                                                            (projT1
                                                                                                                             (sub_nat
                                                                                                                                (projT1
                                                                                                                                 (string_length
                                                                                                                                    arg_))
                                                                                                                                (projT1
                                                                                                                                 (string_length
                                                                                                                                    s_)))))))
                                                                                                                 : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                  0)})))
                                                                                                             | _ =>
                                                                                                                exit tt
                                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                  0)})))
                                                                                                             end)
                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                              0)})))
                                                                                                          else
                                                                                                            (_s2004_
                                                                                                               _s1516_) >>= fun w__140 : option ((word_width * bool * mword 5 * mword 5 * string)) =>
                                                                                                            (if
                                                                                                               ((match w__140 with
                                                                                                                 | Some
                                                                                                                   (w,u,rd,cs,s_) =>
                                                                                                                    true
                                                                                                                 | _ =>
                                                                                                                    false
                                                                                                                 end))
                                                                                                             then
                                                                                                               (_s2004_
                                                                                                                  _s1516_) >>= fun w__141 : option ((word_width * bool * mword 5 * mword 5 * string)) =>
                                                                                                               (match w__141 with
                                                                                                                | Some
                                                                                                                  (w,u,rd,cs,s_) =>
                                                                                                                   returnm ((Some
                                                                                                                               ((CLoadCap
                                                                                                                                   ((rd, cs, u, w)), build_ex
                                                                                                                               (projT1
                                                                                                                                (sub_nat
                                                                                                                                   (projT1
                                                                                                                                    (string_length
                                                                                                                                       arg_))
                                                                                                                                   (projT1
                                                                                                                                    (string_length
                                                                                                                                       s_)))))))
                                                                                                                    : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                     0)})))
                                                                                                                | _ =>
                                                                                                                   exit tt
                                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                     0)})))
                                                                                                                end)
                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                 0)})))
                                                                                                             else
                                                                                                               (_s2021_
                                                                                                                  _s1516_) >>= fun w__144 : option ((word_width * mword 5 * mword 5 * string)) =>
                                                                                                               (if
                                                                                                                  ((match w__144 with
                                                                                                                    | Some
                                                                                                                      (w,rd,rs,s_) =>
                                                                                                                       true
                                                                                                                    | _ =>
                                                                                                                       false
                                                                                                                    end))
                                                                                                                then
                                                                                                                  (_s2021_
                                                                                                                     _s1516_) >>= fun w__145 : option ((word_width * mword 5 * mword 5 * string)) =>
                                                                                                                  (match w__145 with
                                                                                                                   | Some
                                                                                                                     (w,rd,rs,s_) =>
                                                                                                                      returnm ((Some
                                                                                                                                  ((CStoreCap
                                                                                                                                      ((rd, rs, w)), build_ex
                                                                                                                                  (projT1
                                                                                                                                   (sub_nat
                                                                                                                                      (projT1
                                                                                                                                       (string_length
                                                                                                                                          arg_))
                                                                                                                                      (projT1
                                                                                                                                       (string_length
                                                                                                                                          s_)))))))
                                                                                                                       : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                        0)})))
                                                                                                                   | _ =>
                                                                                                                      exit tt
                                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                        0)})))
                                                                                                                   end)
                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                    0)})))
                                                                                                                else
                                                                                                                  (_s2036_
                                                                                                                     _s1516_) >>= fun w__148 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                  (if
                                                                                                                     ((match w__148 with
                                                                                                                       | Some
                                                                                                                         (rd,rs,s_) =>
                                                                                                                          true
                                                                                                                       | _ =>
                                                                                                                          false
                                                                                                                       end))
                                                                                                                   then
                                                                                                                     (_s2036_
                                                                                                                        _s1516_) >>= fun w__149 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                     (match w__149 with
                                                                                                                      | Some
                                                                                                                        (rd,rs,s_) =>
                                                                                                                         returnm ((Some
                                                                                                                                     ((CStoreCapCap
                                                                                                                                         ((rd, rs)), build_ex
                                                                                                                                     (projT1
                                                                                                                                      (sub_nat
                                                                                                                                         (projT1
                                                                                                                                          (string_length
                                                                                                                                             arg_))
                                                                                                                                         (projT1
                                                                                                                                          (string_length
                                                                                                                                             s_)))))))
                                                                                                                          : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                           0)})))
                                                                                                                      | _ =>
                                                                                                                         exit tt
                                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                           0)})))
                                                                                                                      end)
                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                       0)})))
                                                                                                                   else
                                                                                                                     (_s2048_
                                                                                                                        _s1516_) >>= fun w__152 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                     (if
                                                                                                                        ((match w__152 with
                                                                                                                          | Some
                                                                                                                            (rd,rs,s_) =>
                                                                                                                             true
                                                                                                                          | _ =>
                                                                                                                             false
                                                                                                                          end))
                                                                                                                      then
                                                                                                                        (_s2048_
                                                                                                                           _s1516_) >>= fun w__153 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                        (match w__153 with
                                                                                                                         | Some
                                                                                                                           (rd,rs,s_) =>
                                                                                                                            returnm ((Some
                                                                                                                                        ((CLoadCapCap
                                                                                                                                            ((rd, rs)), build_ex
                                                                                                                                        (projT1
                                                                                                                                         (sub_nat
                                                                                                                                            (projT1
                                                                                                                                             (string_length
                                                                                                                                                arg_))
                                                                                                                                            (projT1
                                                                                                                                             (string_length
                                                                                                                                                s_)))))))
                                                                                                                             : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                              0)})))
                                                                                                                         | _ =>
                                                                                                                            exit tt
                                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                              0)})))
                                                                                                                         end)
                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                          0)})))
                                                                                                                      else
                                                                                                                        (_s2060_
                                                                                                                           _s1516_) >>= fun w__156 : option ((mword 32 * string)) =>
                                                                                                                        (if
                                                                                                                           ((match w__156 with
                                                                                                                             | Some
                                                                                                                               (s,s_) =>
                                                                                                                                true
                                                                                                                             | _ =>
                                                                                                                                false
                                                                                                                             end))
                                                                                                                         then
                                                                                                                           (_s2060_
                                                                                                                              _s1516_) >>= fun w__157 : option ((mword 32 * string)) =>
                                                                                                                           (match w__157 with
                                                                                                                            | Some
                                                                                                                              (s,s_) =>
                                                                                                                               returnm ((Some
                                                                                                                                           ((ILLEGAL
                                                                                                                                               (s), build_ex
                                                                                                                                           (projT1
                                                                                                                                            (sub_nat
                                                                                                                                               (projT1
                                                                                                                                                (string_length
                                                                                                                                                   arg_))
                                                                                                                                               (projT1
                                                                                                                                                (string_length
                                                                                                                                                   s_)))))))
                                                                                                                                : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                 0)})))
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                 0)})))
                                                                                                                            end)
                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                             0)})))
                                                                                                                         else
                                                                                                                           (_s2068_
                                                                                                                              _s1516_) >>= fun w__160 : option ((mword 16 * string)) =>
                                                                                                                           (if
                                                                                                                              ((match w__160 with
                                                                                                                                | Some
                                                                                                                                  (s,s_) =>
                                                                                                                                   true
                                                                                                                                | _ =>
                                                                                                                                   false
                                                                                                                                end))
                                                                                                                            then
                                                                                                                              (_s2068_
                                                                                                                                 _s1516_) >>= fun w__161 : option ((mword 16 * string)) =>
                                                                                                                              (match w__161 with
                                                                                                                               | Some
                                                                                                                                 (s,s_) =>
                                                                                                                                  returnm ((Some
                                                                                                                                              ((C_ILLEGAL
                                                                                                                                                  (s), build_ex
                                                                                                                                              (projT1
                                                                                                                                               (sub_nat
                                                                                                                                                  (projT1
                                                                                                                                                   (string_length
                                                                                                                                                      arg_))
                                                                                                                                                  (projT1
                                                                                                                                                   (string_length
                                                                                                                                                      s_)))))))
                                                                                                                                   : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                    0)})))
                                                                                                                               | _ =>
                                                                                                                                  exit tt
                                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                    0)})))
                                                                                                                               end)
                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                0)})))
                                                                                                                            else
                                                                                                                              returnm (None
                                                                                                                               : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                0)}))))
                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                             0)}))))
                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                          0)}))))
                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                       0)}))))
                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                    0)}))))
                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                 0)}))))
                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                              0)}))))
                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                           0)}))))
                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                        0)}))))
                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                     0)}))))
                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                  0)}))))
                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                               0)}))))
                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                            0)}))))
                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                         0)}))))
                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                      0)}))))
                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                   0)}))))
                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                0)}))))
                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                             0)}))))
                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                          0)}))))
                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                       0)}))))
                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                    0)}))))
                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                 0)}))))
                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                              0)}))))
                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                           0)}))))
                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                        0)}))))
                                                    : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                              : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                           : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                        : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                  : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                               : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                            : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                         : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                      : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                   : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
             : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
          : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
       : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((ast * {n : Z & ArithFact (n >= 0)}))).

Definition print_insn (insn : ast)  : M (string) :=  (assembly_forwards insn)  : M (string).

Definition decode (bv : mword 32)  : option ast :=  Some (encdec_backwards bv).

Definition decodeCompressed (bv : mword 16)  : option ast :=  Some (encdec_compressed_backwards bv).

Definition initial_cheri_cause : cheri_cause :=
{| cheri_cause_cap_idx := (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6); 
   cheri_cause_capEx := CapEx_None |}.
Hint Unfold initial_cheri_cause : sail.
Definition initial_Capability : Capability :=
{| Capability_tag := false; 
   Capability_padding := (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8); 
   Capability_otype :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
       : mword 24); 
   Capability_uperms := (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 16); 
   Capability_perm_reserved12_14 := (vec_of_bits [B0;B0;B0]  : mword 3); 
   Capability_permit_set_CID := false; 
   Capability_access_system_regs := false; 
   Capability_permit_unseal := false; 
   Capability_permit_ccall := false; 
   Capability_permit_seal := false; 
   Capability_permit_store_local_cap := false; 
   Capability_permit_store_cap := false; 
   Capability_permit_load_cap := false; 
   Capability_permit_store := false; 
   Capability_permit_load := false; 
   Capability_permit_execute := false; 
   Capability_global := false; 
   Capability_sealed := false; 
   Capability_address :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       : mword 64); 
   Capability_base :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       : mword 64); 
   Capability_length :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       : mword 64) |}.
Hint Unfold initial_Capability : sail.
Definition initial_regstate : regstate :=
{| x31 := initial_Capability; 
   x30 := initial_Capability; 
   x29 := initial_Capability; 
   x28 := initial_Capability; 
   x27 := initial_Capability; 
   x26 := initial_Capability; 
   x25 := initial_Capability; 
   x24 := initial_Capability; 
   x23 := initial_Capability; 
   x22 := initial_Capability; 
   x21 := initial_Capability; 
   x20 := initial_Capability; 
   x19 := initial_Capability; 
   x18 := initial_Capability; 
   x17 := initial_Capability; 
   x16 := initial_Capability; 
   x15 := initial_Capability; 
   x14 := initial_Capability; 
   x13 := initial_Capability; 
   x12 := initial_Capability; 
   x11 := initial_Capability; 
   x10 := initial_Capability; 
   x9 := initial_Capability; 
   x8 := initial_Capability; 
   x7 := initial_Capability; 
   x6 := initial_Capability; 
   x5 := initial_Capability; 
   x4 := initial_Capability; 
   x3 := initial_Capability; 
   x2 := initial_Capability; 
   x1 := initial_Capability; 
   DDC := initial_Capability; 
   nextPCC := initial_Capability; 
   PCC := initial_Capability; 
   instbits :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       : mword 64); 
   nextPC :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       : mword 64); 
   PC :=
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       : mword 64) |}.
Hint Unfold initial_regstate : sail.

End Content.
